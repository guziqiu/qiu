[TOC]







# 0.2020.12.22











# 1.顺序表与链表

## 1.1顺序表



![截屏2020-11-02 上午10.17.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.17.04.png)

![截屏2020-11-02 上午10.19.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.19.36.png)

![截屏2020-11-02 上午10.24.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.24.28.png)





![截屏2020-11-02 上午10.39.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.39.19.png)

![截屏2020-11-02 上午10.40.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8A%E5%8D%8810.40.05.png)



![截屏2020-11-02 下午3.42.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.42.57.png)

![截屏2020-11-02 下午3.43.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.43.57.png)

![截屏2020-11-02 下午3.45.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%883.45.11.png)





算法：在cpu资源有限的情况下，执行更多的命令

数据结构=结构定义+结构操作





顺序表：更高级的数组，连续的存储空间，可以存储任意类型



>malloc 仅开辟空间，calloc 开辟空间并且初始化，清空原来的值，realloc 重新划分空间
>realloc(地址,字节数)，返回值为新开辟空间的首地址，
>首先会在原来地址的后面开辟一倍的地址，并且返回原来的首地址，
>如果后面的取件无法扩建，找一个其他地方，为原来的两倍，将原来的内容拷贝到新开辟的空间，返回首地址
>不一定开辟成功，降低需求开1/2，如果无法开辟空间返回值为NULL,

 ![截屏2021-02-02 下午10.45.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.45.51.png)

![截屏2021-02-02 下午10.45.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.45.53.png)

![截屏2021-02-02 下午10.45.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.45.55.png)

![截屏2021-02-02 下午10.45.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.45.56.png)

![截屏2021-02-02 下午10.45.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.45.58.png)





## 1.2顺序表代码演示

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COLOR(a,b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)


//结构定义
typedef struct Vector {
    int *data;//存储数据，记录连续开辟的存储空间的首地址
    int size, length;//
} Vec;

Vec *init(int n) {
     Vec *v = (Vec *)malloc(sizeof(Vec));//动态开辟空间
     v->data = (int *)malloc(sizeof(int) * n);//data指向开辟空间的首地址
     v->size = n;//
     v->length = 0;
        return v;
}

int expand(Vec *v) {
    //malloc 仅开辟空间，calloc 开辟空间并且初始化，清空原来的值，realloc 重新划分空间
    //realloc(地址,字节数)，返回值为新开辟空间的首地址，
    //首先会在原来地址的后面开辟一倍的地址，并且返回原来的首地址，
    //如果后面的取件无法扩建，找一个其他地方，为原来的两倍，将原来的内容拷贝到新开辟的空间，返回首地址
    //不一定开辟成功，降低需求开1/2，如果无法开辟空间返回值为NULL,
    int extr_size = v->size;
    int *p;
    while (extr_size) {
        p = (int *)realloc(v->data, sizeof(int) * (v->size + extr_size));//开辟原来的2倍
        if (p) break;//开辟空间成功
        extr_size >>= 1;//开辟空间失败,降低需求，开辟1/2
    }
    if (extr_size == 0) return 0;
    v->data = p;
    v->size += extr_size;
    return 1;
}

//插入
int insert(Vec *v, int value, int index) {
    //在v中的index位置插入值value
    if (v == NULL) return 0;
    if (index < 0 || index > v->length) return 0;//插入位置不合法
    if (v->length == v->size) {//顺序表已满,扩容
        if (!expand(v)) return 0;
        printf(GREEN("success to expand! the Vector size is %d\n"), v->size);
    }
    for (int i = v->length; i > index; i--) {
        v->data[i] = v->data[i - 1];
    }
    v->data[index] = value;
    v->length +=1;
    return 1;
}

//删除顺序表中第index位置的值
int erase(Vec *v, int index) {
    if (v == NULL) return 0;
    if (index < 0 || index >= v->length) return 0;//插入位置不合法
    for (int i = index + 1; i < v->length; i++) {
        v->data[i - 1] = v->data[i];
    }
    v->length -= 1;
    return 1;
}

void clear(Vec *v) {
    if(v == NULL) return ;//如果v为空
    free(v->data);
    free(v);//释放malloc动态申请的内存
       return ;
}

//输出线性表
void output(Vec *v) {
    if (v == NULL) return ;
    printf("Vector : [");
    for (int i = 0; i < v->length; i++) {
        i && printf(",");
        printf("%d", v->data[i]);
    }
    printf("]\n");
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    Vec *v = init(2);
    for (int i = 0; i < max_op; i++) {
        ins
        int index = rand() % (v->length + 3) -1;//index = [-1, length + 2],测试用例
        int op = rand() % 4;
        switch (op) {//012插入3删除
        case 1:
        case 2:
        case 0:
            printf("insert %d at %d to Vector = %d\n", value, index, insert(v, value, index));
            break;
        case 3:
            printf("erase a iterm at %d from Vector = %d\n", index, erase(v, index));
            break;
        }
        output(v);
        printf("\n");
    }
    clear(v);
    #undef max_op

    return 0;
}

```







## 1.3链表



![截屏2020-11-03 下午4.30.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-03%20%E4%B8%8B%E5%8D%888.10.29.png)

![截屏2020-11-03 下午8.10.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-03%20%E4%B8%8B%E5%8D%888.10.29.png)







![](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8B%E5%8D%882.09.53.png)





链表内部有数据和记录下一个结点的地址



![截屏2021-02-02 下午10.46.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.01.png)

![截屏2021-02-02 下午10.46.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.02.png)

![截屏2021-02-02 下午10.46.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.03.png)

![截屏2021-02-02 下午10.46.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.05.png)

![截屏2021-02-02 下午10.46.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.06.png)

![截屏2021-02-02 下午10.46.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.07.png)

![截屏2021-02-02 下午10.46.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.09.png)

![截屏2021-02-02 下午10.46.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.10.png)



## 1.4链表代码演示

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//结构定义
typedef struct ListNode {//结点
    int data;//存储数据
    struct ListNode *next;//记录下一个结点的位置
} ListNode;

typedef struct List {//链表
    ListNode head;//虚拟头结点，list
    int length;
} List;

ListNode *createNewNode(int);//初始化结点
List *createLinkList();//初始化链表
void clear_node(ListNode *);//释放结点
void clear(List *);//释放链表
int insert(List *, int, int);//插入
int erase(List *, int);//删除
void output(List *);//打印链表
void reverse(List *); 

int main()
{
    srand(time(0));
    #define max_op 20
    List *list = createLinkList();
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        int index = rand() % (list->length + 3) - 1;
        int op = rand() % 5;
        switch (op) {
        case 0:
        case 1:
        case 2:{
            printf("insert %d at  %d to list = %d\n", value, index, insert(list, index, value));
               }
            break;
        case 3:
            printf("earse a iterm at %d from list = %d\n", index, erase(list, index));
            break;
        case 4:{
            printf("reverse the list!\n");
            reverse(list);
             }break;
        }
        output(list);
        printf("\n");
    }
    #undef max_op
    clear(list);
    return 0;
}

ListNode *createNewNode(int value){
    ListNode *node = (ListNode *)malloc(sizeof(ListNode));
    node->data = value;
    node->next = NULL;
    return node;
}

List *createLinkList() {
    List *list = (List *)malloc(sizeof(List));
    list->head.next = NULL;
    list->length = 0;
    return list;
}

int insert(List *list, int index, int value) {
    if (list == NULL) return 0;
    if (index < 0 || index > list->length) return 0;
    ListNode *p = &(list->head);//指向头结点
    ListNode *node = createNewNode(value);//初始化结点，准备插入链表中
    while (index--) p = p->next;
    node->next = p->next;
    p->next = node;
    list->length += 1;
    return 1;
}

int erase(List *list, int index) {
    if (list == NULL) return 0;
    if (index < 0 || index >= list->length) return 0;
    ListNode *p = &(list->head);
    ListNode *delete_node;
    while (index--) p = p->next;
    delete_node = p->next;
    p->next = delete_node->next;
    free(delete_node);
    list->length -=1;
    return 1;
}

void reverse(List *list) {
    if (list == NULL) return ;
    ListNode *p = list->head.next;
    ListNode *q;
    list->head.next = NULL;
    while (p) {
        q = p->next;
        p->next = list->head.next;
        list->head.next = p;
        p = q;
    }
    return ;
}

void output(List *list) {
    if (list == NULL) return ;
    printf("List(%d) = [", list->length);
    for (ListNode *p = list->head.next; p; p = p->next) {
        printf("%d->", p->data);
    }
    printf("NULL]\n");
    return ;
}

void clear_node(ListNode *node) {
    if (node == NULL) return ;
    free(node);
    return ;
}
void clear(List *list) {
    if(list == NULL) return ;
    ListNode *delete_node = list->head.next;
    ListNode *temp;
    while (delete_node) {
        temp = delete_node->next;
        free(delete_node);
        delete_node = temp;
    }
    free(list);
}
```



## 1.5单向循环链表

![截屏2021-02-02 下午10.46.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.12.png)

![截屏2021-02-02 下午10.46.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.13.png)

![截屏2021-02-02 下午10.46.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.14.png)

![截屏2021-02-02 下午10.46.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.15.png)

![截屏2021-02-02 下午10.46.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.46.16.png)









# 2.栈和队列



## 2.1栈

![截屏2020-11-04 下午3.19.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.19.10.png)

![截屏2020-11-04 下午3.20.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.20.10.png)

![截屏2020-11-04 下午3.20.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8B%E5%8D%883.20.41.png)

![截屏2020-11-05 上午10.37.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8A%E5%8D%8810.37.49.png)

![截屏2020-11-05 下午3.07.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%883.07.14.png)



线性数据结构

FILO (First In Last Out)先进后出



栈顶指针

对于一个空栈，栈顶指针下标为-1

![截屏2021-02-02 下午10.51.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.47.png)

![截屏2021-02-02 下午10.51.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.48.png)

![截屏2021-02-02 下午10.51.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.49.png)

## 2.2栈代码演示

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

typedef struct Stack{
    int *data;
    int top;
    int size;
} Stack;

Stack *init(int input_size) {//初始化栈
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    stack->data = (int *)malloc(sizeof(int) * input_size);
    stack->size = input_size;
    stack->top = -1;//栈顶指针初始值为-1
    return stack;
}

int top(Stack *stack) {//栈顶元素
    //if (empty(stack)) return 0;
    return stack->data[stack->top];
}

int empty(Stack *stack) {//判空
    return stack->top == -1;
}

int expand(Stack *stack) {//扩容
    int *temp_stack;
    int extr_size = stack->size;
    while (extr_size) {
        temp_stack = (int *)realloc(stack->data, sizeof(int) * (extr_size + stack->size));
        if (temp_stack) break;
        extr_size >= 1;
    }
    if (temp_stack == NULL) return 0; //扩容失败
    stack->size += extr_size;
    stack->data = temp_stack;
    return 1;
}

int push(Stack *stack, int value) {//入栈
    if (stack == NULL) return 0;
    if (stack->top == stack->size - 1){ //扩容
        if (!expand(stack)) return 0;
        printf(GREEN("expand successful! stack->size = %d \n"), stack->size);
    }
    stack->data[++stack->top] = value;
    return 1;
}

int pop(Stack *stack) {//出栈
    if (stack == NULL) return 0;
    if (empty(stack)) return 0;
    stack->top--;
    return 1;
}

void output(Stack *stack) {//打印栈
    if (stack == NULL) return ;
    if (empty(stack)) {
        printf("stack empty!\n");
        return ;
    }
    printf("[");
    for (int i = 0; i <= stack->top; i++) {
        i && printf(",");
        printf("%d", stack->data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Stack *stack) {//释放申请的内存
    if (stack == NULL) return ;
    free(stack->data);
    free(stack);
    return ;
}

int main()
{
    srand(time(0));
    #define max_op 20
    Stack *stack = init(2);
    for (int i = 0; i < max_op; i++) {
       int value = rand() % 100;
       int op = rand() % 4;
       switch (op) {
       case 0:
       case 1:
       case 2: {
                printf("push %d to the stack= %d\n", value, push(stack, value));
               }break;
       case 3: {
                   printf("pop %d from the stack!", top(stack));
                   printf("result = %d\n", pop(stack));
               }break;

       }
       output(stack);
       printf("\n");
    }
    #undef max_op
    clear(stack);

    return 0;
}
```





## 2.3队列

先进先出FIFO(First In First out)





![截屏2020-11-04 上午9.17.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.17.30.png)

![截屏2020-11-04 上午9.19.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.19.23.png)

![截屏2020-11-04 上午9.19.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.19.46.png)

![截屏2020-11-04 上午9.21.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%889.21.18.png)

![截屏2020-11-04 上午11.30.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-04%20%E4%B8%8A%E5%8D%8811.30.30.png)

![截屏2021-02-02 下午10.51.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.37.png)

![截屏2021-02-02 下午10.51.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.39.png)

![截屏2021-02-02 下午10.51.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.41.png)

![截屏2021-02-02 下午10.51.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.42.png)

![截屏2021-02-02 下午10.51.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.44.png)

![截屏2021-02-02 下午10.51.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.51.45.png)





## 2.4队列代码演示

### 1.简单队列

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//结构定义+结构操作
typedef struct Queue {
    int *data;
    int head;//头结点
    int tail;//尾结点，最后一个元素的下一个为空的位置
    int length;
} Queue;

//结构操作
Queue *init(int n) {//初始化队列
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->data = (int *)malloc(sizeof(int) * n);
    queue->head = queue->tail = 0;
    queue->length = n;
    return queue;
}

int front(Queue *queue) {
    return queue->data[queue->head];
}

int empty(Queue *queue){
    return queue->head == queue->tail;
}

int push(Queue *queue, int value) {
    if(queue == NULL) return 0;
    if(queue->tail == queue->length) return 0;
    queue->data[queue->tail++] = value;
    //queue->tail++;
    return 1;
}

int pop(Queue *queue) {
    if (queue == NULL) return 0;
    if (empty(queue)) return 0;
    queue->head++;
    return 1;
}

void output(Queue *queue) {
    if (queue == NULL) return ;
    printf("Queue : [");
    for (int i = queue->head, j = 0; i < queue->tail; i++,j++) {
        j && printf(",");
        printf("%d", queue->data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Queue *queue) {//清空队列
    if(queue == NULL) return ;
    free(queue->data);
    queue->data = NULL;
    free(queue);
    queue = NULL;
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    Queue *queue = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        int op = rand() % 4;
        switch (op) {
        case 0:
        case 1:
        case 2:{
            printf("push %d to the Queue !", value);
            printf("result = %d\n", push(queue, value));

        }break;
        case 3: {
             printf("pop %d from th Queue !", front(q));
             printf("result = %d\n", pop(queue));
        }break;
        }
        output(queue);
        printf("\n");
    }

    #undef max_op
    clear(queue);
    return 0;
}
```





### 2.循环队列

（解决假溢出，出队时，头指针往后走，会造成假溢出）



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//结构定义+结构操作
typedef struct Queue {
    int *data;
    int head;//头结点
    int tail;//尾结点，最后一个元素的下一个为空的位置
    int length;
    int count;//记录队列中元素的个数
} Queue;

//结构操作
Queue *init(int n) {//初始化队列
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->data = (int *)malloc(sizeof(int) * n);
    queue->head = queue->tail = 0;
    queue->length = n;
    queue->count = 0;
    return queue;
}

int front(Queue *queue) {
    return queue->data[queue->head];
}

int empty(Queue *queue){
   // return queue->head == queue->tail;
   return queue->count == 0;
}

int push(Queue *queue, int value) {
    if(queue == NULL) return 0;
    if(queue->count == queue->length) return 0;//
    queue->data[queue->tail++] = value;
    //queue->tail++;
    if (queue->tail == queue->length) queue->tail = 0;//queue->tail %= queue->length;
    queue->count += 1;
    return 1;
}

int pop(Queue *queue) {
    if (queue == NULL) return 0;
    if (empty(queue)) return 0;
    queue->head++;
    if (queue->head == queue->length) queue->head = 0;
    queue->count--;
    return 1;
}

void output(Queue *queue) {
    if (queue == NULL) return ;
    printf("Queue : [");
    for (int i = queue->head, j = 0; j < queue->count; i++,j++) {
        j && printf(",");
        printf("%d", queue->data[i % queue->length]);
    }
    printf("]\n");
    return ;
}

void clear(Queue *queue) {//清空队列
    if(queue == NULL) return ;
    free(queue->data);
    queue->data = NULL;
    free(queue);
    queue = NULL;
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    Queue *queue = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        int op = rand() % 4;
        switch (op) {
        case 0:
        case 1:
        case 2:{
            printf("push %d to the Queue !", value);
            printf("result = %d\n", push(queue, value));

        }break;
        case 3: {
             printf("pop %d from th Queue !", value);
             printf("result = %d\n", pop(queue));
        }break;
        }
        output(queue);
        printf("\n");
    }

    #undef max_op
    clear(queue);
    return 0;
}
```



解决了假溢出但是会出现真溢出



### 3.循环队列2



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COLOR(a,b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a,32)

//结构定义+结构操作
typedef struct Queue {
    int *data;
    int head;//头结点
    int tail;//尾结点，最后一个元素的下一个为空的位置
    int length;
    int count;//记录队列中元素的个数
} Queue;

//结构操作
Queue *init(int n) {//初始化队列
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->data = (int *)malloc(sizeof(int) * n);
    queue->head = queue->tail = 0;
    queue->length = n;
    queue->count = 0;
    return queue;
}

int front(Queue *queue) {
    return queue->data[queue->head];
}

int empty(Queue *queue){
   // return queue->head == queue->tail;
   return queue->count == 0;
}

int expand(Queue *queue) {
    int extr_size = queue->length;
    int *temp_queue;
    while (extr_size) {
        temp_queue = (int *)malloc(sizeof(int) * (extr_size + queue->length));
        if (temp_queue) break;
        extr_size >>= 1;
    }
    if (temp_queue == NULL) return 0;
    for (int i = queue->head, j = 0; j < queue->count; j++) {
        temp_queue[j] = queue->data[(i + j) % queue->length];
    }
    free(queue->data);
    queue->data = temp_queue;
    queue->length += extr_size;
    queue->head = 0;
    queue->tail = queue->count;
    return 1;
}

int push(Queue *queue, int value) {
    if(queue == NULL) return 0;
    if(queue->count == queue->length) {//扩容
        if(!expand(queue)) return 0;
        printf(GREEN("ecpand sucessfull!Queue->size = %d\n"), queue->length);
    }
    queue->data[queue->tail++] = value;
    //queue->tail++;
    if (queue->tail == queue->length) queue->tail = 0;//queue->tail %= queue->length;
    queue->count += 1;
    return 1;
}

int pop(Queue *queue) {
    if (queue == NULL) return 0;
    if (empty(queue)) return 0;
    queue->head++;
    if (queue->head == queue->length) queue->head = 0;
    queue->count--;
    return 1;
}

void output(Queue *queue) {
    if (queue == NULL) return ;
    printf("Queue : [");
    for (int i = queue->head, j = 0; j < queue->count; i++,j++) {
        j && printf(",");
        printf("%d", queue->data[i % queue->length]);
    }
    printf("]\n");
    return ;
}

void clear(Queue *queue) {//清空队列
    if(queue == NULL) return ;
    free(queue->data);
    queue->data = NULL;
    free(queue);
    queue = NULL;
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    Queue *queue = init(2);
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        int op = rand() % 4;
        switch (op) {
        case 0:
        case 1:
        case 2:{
            printf("push %d to the Queue !", value);
            printf("result = %d\n", push(queue, value));

        }break;
        case 3: {
             printf("pop %d from th Queue !", value);
             printf("result = %d\n", pop(queue));
        }break;
        }
        output(queue);
        printf("\n");
    }

    #undef max_op
    clear(queue);
    return 0;
}
```







# 3.树



## 3.1.二叉树





二叉树性质





![截屏2020-11-05 下午4.56.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%884.56.15.png)



![截屏2020-11-05 下午5.04.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.04.49.png)

![截屏2020-11-05 下午5.24.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.24.57.png)

![截屏2020-11-05 下午5.25.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.24.png)

![截屏2020-11-05 下午5.25.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.31.png)

![截屏2020-11-05 下午5.25.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.25.51.png)

![截屏2020-11-06 下午11.15.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-06%20%E4%B8%8B%E5%8D%8811.15.42.png)

![截屏2020-11-06 下午11.17.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-06%20%E4%B8%8B%E5%8D%8811.17.03.png)

![截屏2021-02-02 下午10.42.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.32.png)

![截屏2021-02-02 下午10.42.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.36.png)

![截屏2021-02-02 下午10.42.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.40.png)

![截屏2021-02-02 下午10.42.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.42.png)

![截屏2021-02-02 下午10.42.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.44.png)

![截屏2021-02-02 下午10.42.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.47.png)

![截屏2021-02-02 下午10.42.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.48.png)

![截屏2021-02-02 下午10.42.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.50.png)

## 3.2.二叉树代码演示

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Node {//定义节点
    int data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {//定义树
    Node *root;
    int n;//节点个数
} Tree;

Node *getNewNode (int value) {//节点初始化
    Node *node = (Node *)malloc(sizeof(Node));
    node->data = value;
    node->lchild = node->rchild = NULL;
    return node;
}

Tree *getNewTree() {//初始化树
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

Node *insert_node(Node *root, int value, int *flag) {//
    if (root == NULL) {
        *flag = 1;
        return getNewNode(value);
    }
    if (root->data == value) return root;
    if (root->data > value) root->lchild = insert_node(root->lchild, value, flag);//递归插入，直到节点为空
    else root->rchild = insert_node(root->rchild, value, flag);
    return root;
}

void insert(Tree *tree, int value) {//二叉查找树/二叉排序树
    int flag = 0;
    tree->root = insert_node(tree->root, value, &flag);
    tree->n += flag;
    return ;
}

void clearNode(Node *node) {//释放节点
    if (node == NULL) return ;
    clearNode(node->lchild);
    clearNode(node->rchild);
    free(node);
    return ;
}

void clear(Tree *tree) {//释放树申请的内存
    if (tree == NULL) return ;
    clearNode(tree->root);
    free(tree);
    return ;
}

//树的遍历
//1.先序遍历
void pre_order_node(Node *node) {//先序遍历（递归）
    if (node == NULL) return ;
    printf("%d ", node->data);
    pre_order_node(node->lchild);
    pre_order_node(node->rchild);
    return ;
}
void pre_order(Tree *tree) {//先序遍历
    if (tree == NULL) return ;
    printf("pre_order : ");
    pre_order_node(tree->root);
    printf("\n");
    return ;
}

//2.中序遍历
void in_order_node(Node *node) {
    if (node == NULL) return ;
    in_order_node(node->lchild);
    printf("%d ", node->data);
    in_order_node(node->rchild);
    return ;
}
void in_order(Tree *tree) {//中序遍历
    if (tree == NULL) return ;
    printf("pre_order : ");
    in_order_node(tree->root);
    printf("\n");
    return ;
}


//3.后序遍历
void post_order_node(Node *node) {
    if (node == NULL) return ;
    post_order_node(node->lchild);
    post_order_node(node->rchild);
    printf("%d ", node->data);
    return ;
}
void post_order(Tree *tree) {//后序遍历
    if (tree == NULL) return ;
    printf("pre_order : ");
    post_order_node(tree->root);
    printf("\n");
    return ;
}

void output_node(Node *root) {
    if (root == NULL) return ;
    printf("%d", root->data);
    if (root->lchild == NULL && root->rchild == NULL) return ;
    printf("(");
    output_node(root->lchild);
    printf(",");
    output_node(root->rchild);
    printf(")");
    return ;
}

void output(Tree *tree) {//输出广义表
    if (tree == NULL) return ;
    printf("tree(%d) : ", tree->n);
    output_node(tree->root);
    printf("\n");
    return ;
}


int main() {
    srand(time(0));
    Tree *tree = getNewTree();
    #define max_op 4
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        insert(tree, value);
        output(tree);
    }
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    #undef max_op
    clear(tree);

    return 0;
}
```









## 3.3.广义表转二叉树

![截屏2021-02-02 下午10.42.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.51.png)

![截屏2021-02-02 下午10.42.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.42.53.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef struct Node {
    char data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

typedef struct Stack {
    Node **data;
    int top;
    int size;
} Stack;

Node *getNewNode(char value) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = value;
    p->lchild = p->rchild = NULL;
    return p;
}

Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

Stack *init_stack(int n) {
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    stack->data = (Node **)malloc(sizeof(Node *) * n);
    stack->top = -1;
    stack->size = n;
    return stack;
}

Node *top(Stack *stack) {
    return stack->data[stack->top];
}

int empty(Stack *stack) {
    return stack->top == -1;
}

int push(Stack *stack, Node *value) {
    if (stack == NULL) return 0;
    if (stack->top == stack->size - 1) return 0;
    stack->data[++(stack->top)] = value;
    return 1;
}

int pop(Stack *stack) {
    if (stack == NULL) return 0;
    if (empty(stack)) return 0;
    stack->top--;
    return 1;
}

void clear_stack(Stack *stack) {
    if (stack == NULL) return ;
    free(stack->data);
    free(stack);
    return ;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    clear_node(node->lchild);
    clear_node(node->rchild);
    free(node);
    return ;
}

void clear_tree(Tree *tree) {
    if (tree == NULL) return ;
    clear_node(tree->root);
    free(tree);
    return ;
}
Node *build(char *str, int *node_num) {
    Stack *stack = init_stack(strlen(str));
    int flag = 0;//标记逗号，确定是左孩子还是右孩子,flag = 0,在逗号左侧，左孩子， 1 在逗号右侧右孩子
    Node *temp = NULL;//临时保存新节点
    Node *p = NULL;
    while (str[0]) {
        switch (str[0]) {
        case '(':{
            push(stack, temp);
            flag = 0;
        }break;
        case ')':{
            p = top(stack);
            pop(stack);
        }break;
        case ',': {
            flag = 1;
        } break;
        case ' ': break;
        default:
            temp = getNewNode(str[0]);
            if (!empty(stack) && flag == 0) {
                top(stack)->lchild = temp;
            }else if (!empty(stack) && flag == 1) {
                top(stack)->rchild = temp;
            }
            ++(*node_num);
            break;
        }
        ++str;
    }
    clear_stack(stack);
    if (temp && !p) p = temp;//判空
    return p;
}

void pre_order_node(Node *root) {
    if (root == NULL) return ;
    printf("%c ", root->data);
    pre_order_node(root->lchild);
    pre_order_node(root->rchild);
    return ;
}

void pre_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("pre_order : ");
    pre_order_node(tree->root);
    printf("\n");
    return ;
}

void in_order_node(Node *root) {
    if (root == NULL) return ;
    in_order_node(root->lchild);
    printf("%c ", root->data);
    in_order_node(root->rchild);
    return ;
}

void in_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("in_order : ");
    in_order_node(tree->root);
    printf("\n");
    return ;
}

void post_order_node(Node *root) {
    if (root == NULL) return ;
    post_order_node(root->lchild);
    printf("%c ", root->data);
    post_order_node(root->rchild);
    return ;
}

void post_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("post_order : ");
    post_order_node(tree->root);
    printf("\n");
    return ;
}


int main() {
    char str[1000] = {0};
    int node_num = 0;
    scanf("%[^\n]s", str);
    Tree *tree = getNewTree();
    tree->root = build(str, &node_num);
    tree->n = node_num;
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    clear_tree(tree);

    return 0;
}
```













```cpp
A(B(,D),C(E,))
pre_order : A B D C E
in_order : B D A E C
post_order : B D A E C
```





# 4.排序与查找



> 稳定排序：插入排序、冒泡排序、归并排序



## 4.1插入排序

![截屏2021-02-02 下午10.55.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.55.58.png)

![截屏2021-02-02 下午10.56.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.01.png)

![截屏2021-02-02 下午10.56.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.02.png)

![截屏2021-02-02 下午10.56.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.03.png)

![截屏2021-02-02 下午10.56.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.04.png)

![截屏2021-02-02 下午10.56.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.06.png)

![截屏2021-02-02 下午10.56.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.07.png)

![截屏2021-02-02 下午10.56.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.09.png)

![截屏2021-02-02 下午10.56.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.56.10.png)

$O(n^2)$



## 4.2冒泡排序O(N^2)

![截屏2021-02-02 下午10.57.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.57.50.png)

![截屏2021-02-02 下午10.57.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.57.53.png)

![截屏2021-02-02 下午10.57.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.57.59.png)

![截屏2021-02-02 下午10.58.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.00.png)

![截屏2021-02-02 下午10.58.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.02.png)

![截屏2021-02-02 下午10.58.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.04.png)

![截屏2021-02-02 下午10.58.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.05.png)

![截屏2021-02-02 下午10.58.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.06.png)

![截屏2021-02-02 下午10.58.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.09.png)

![截屏2021-02-02 下午10.58.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.11.png)

![截屏2021-02-02 下午10.58.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.13.png)

![截屏2021-02-02 下午10.58.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.14.png)

![截屏2021-02-02 下午10.58.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.16.png)















## 4.3归并排序O(n log n)

![截屏2021-02-02 下午10.58.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.20.png)

![截屏2021-02-02 下午10.58.22](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8810.58.22.png)

![截屏2021-02-02 下午11.00.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.36.png)

![截屏2021-02-02 下午11.00.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.37.png)

![截屏2021-02-02 下午11.00.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.39.png)

![截屏2021-02-02 下午11.00.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.40.png)

![截屏2021-02-02 下午11.00.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.41.png)

![截屏2021-02-02 下午11.00.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.43.png)![截屏2021-02-02 下午11.00.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.45.png)

![截屏2021-02-02 下午11.00.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.46.png)

![截屏2021-02-02 下午11.00.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.48.png)

![截屏2021-02-02 下午11.00.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.49.png)

![截屏2021-02-02 下午11.00.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.00.50.png)



## 4.4稳定排序代码演示

稳定排序：排序前a[i]=a[j]  (i<j),排序后a[i]=a[j]  (i<j)，相对位置没变，称为稳定排序

内部排序：插入排序、冒泡排序，完全加载到内存中，在内存中排序

外部排序：归并排序，完全可以对整块数据分段加载到内存中排序，外部排序，



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
using namespace std;

#define swap(a, b) {\
    a ^= b; b^= a; a ^= b;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s : \n", #func);\
    func(args);\
    output(num, n);\
    free(num);\
}

//插入排序
void insert_sort(int *num, int n) {
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0 && num[j] < num[j - 1]; j--) {
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}

//冒泡排序
void bubble_sort(int *num, int n) {
    int times;
    for (int i = 1; i < n && times; i++) {//times,如果有一轮排序没有发生互换位置，则终止循环
        times = 0;
        for (int j = 0; j < n - 1; j++) {
            if (num[j] <= num[j+ 1]) continue;
            swap(num[j], num[j + 1]);
            times++;
            //if (num[j] > num[j + 1]) {
            //    swap(num[j], num[j + 1]);
            //    times++;
            //}
        }
    }
}

//归并排序
void merage_sort(int *num, int l, int r) {
    if (r - l <= 1) {
        if (r - l == 1 && num[r] < num[l]) {
            swap(num[r], num[l]);
        }
        return ;
    }
    //数组分为两段
    int mid = (l + r) >> 1;
    merage_sort(num, l, mid);
    merage_sort(num, mid + 1, r);
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    //将两个有序的数组合并为一个
    int p1 = l, p2 = mid + 1, k = 0;
    while (p1 <= mid || p2 <= r) {//当数组中有元素时进行合并
        if (p2 > r || (p1 <= mid && num[p1] < num[p2])) {
            //p2 > r : 第二个数组已经没有元素了，p1 <= mid,第一个元素还有元素，
            temp[k++] = num[p1++];//将两个数组中较小的那个值，赋值给temp,temp成升序排列
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));//将temp拷贝到num中
    free(temp);
    return ;
}

void randint(int *num, int n) {//随机生成100以内的数字
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf("%d ", num[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    //随机生成数组
    srand(time(0));
    #define max_n 20
    int arr[max_n];
    randint(arr, max_n);
    TEST(arr, max_n, insert_sort, num, max_n);
    TEST(arr, max_n, bubble_sort, num, max_n);
    TEST(arr, max_n, merage_sort, num, 0, max_n - 1);

    #undef max_n



    return 0;
}
```



```
[12 81 49 86 84 56 82 94 97 49 10 69 53 80 77 83 99 22 80 26 ]
insert_sort :
[10 12 22 26 49 49 53 56 69 77 80 80 81 82 83 84 86 94 97 99 ]
[12 81 49 86 84 56 82 94 97 49 10 69 53 80 77 83 99 22 80 26 ]
bubble_sort :
[10 12 22 26 49 49 53 56 69 77 80 80 81 82 83 84 86 94 97 99 ]
[12 81 49 86 84 56 82 94 97 49 10 69 53 80 77 83 99 22 80 26 ]
merage_sort :
[10 12 22 26 49 49 53 56 69 77 80 80 81 82 83 84 86 94 97 99 ]
```



## 4.5选择排序(O(N^2))

![截屏2021-02-02 下午11.02.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.02.24.png)

![截屏2021-02-02 下午11.02.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.02.25.png)

![截屏2021-02-02 下午11.02.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.02.26.png)

![截屏2021-02-02 下午11.02.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.02.28.png)







## 4.6快速排序(O(NlogN) ~ O(N^2))

![截屏2021-02-02 下午11.03.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.33.png)

![截屏2021-02-02 下午11.03.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.35.png)

![截屏2021-02-02 下午11.03.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.36.png)

![截屏2021-02-02 下午11.03.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.38.png)

![截屏2021-02-02 下午11.03.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.39.png)

![截屏2021-02-02 下午11.03.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.41.png)

![截屏2021-02-02 下午11.03.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.42.png)

![截屏2021-02-02 下午11.03.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.44.png)

![截屏2021-02-02 下午11.03.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.45.png)

![截屏2021-02-02 下午11.03.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.47.png)

![截屏2021-02-02 下午11.03.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.48.png)







## 4.7非稳定排序代码演示



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
using namespace std;

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s = ", #func);\
    func(args);\
    output(num, n);\
    free(num);\
}


void select_sort(int *num, int n) { // 选择排序
    for (int i = 0; i < n - 1; i++) {
        int ind = i; //待排序去下标
        for (int j = i + 1; j < n; j++) {
            if (num[ind] > num[j]) ind = j;
        }
        swap(num[i], num[ind]);
    }
    return ;
}

void quick_sort(int *num, int l, int r) { // 快排
    if (l > r) return ;
    int x = l, y = r, z = num[x];
    while (x < y) {
        while (x < y && num[y] > z) y--;
        if (x < y) num[x++] = num[y];
        while (x < y && num[x] < z) x++;
        if (x < y) num[y--] = num[x]; 
    }
    num[x] = z;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return ;
}



void randint(int *num, int n) { // 生成n个100以内的随机数
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    cout << "[";
    for (int i = 0; i < n; i++) {
        cout << num[i] << " ";
    }
    cout << "]" << endl;
    return ;
}

int main() {
    srand(time(0));
    #define MAX_N 10
    int arr[MAX_N];
    randint(arr, MAX_N);

    TEST(arr, MAX_N, select_sort, num, MAX_N);
    TEST(arr, MAX_N, quick_sort, num, 0, MAX_N - 1);


    #undef MAX_N
    return 0;
}

```





```cpp
#include <iostream>
#include <algorithm>
using namespace std;

void print(int *num, int n) {
    for (int i = 0; i < n; i++) {
        cout << num[i] << " ";
    }
    cout << endl;
}

void quick_sort(int *num, int l, int r) { // 快排， 从左到右依次作为基准值， 将比基准值小的放左边， 大的放右边
    if (l > r) return ;
    int x = l, y = r, z = num[x]; // 左右区间， 基准值
    while (x < y) {
        while (x < y && num[y] > z) y--; // 如果尾指针 < 基准值，尾指针前移,找到第一个比基准值小的 
        if (x < y) num[x++] = num[y]; // 将找到的比基准值小的移动到头指针处,头指针后移
        while (x < y && num[x] < z) x++; // 如果头部指针 < 基准值，头部指针后移，找到第一个比基准值大的
        if (x < y) num[y--] = num[x]; // 将比基准值大的移动到到尾部指针的位置，尾部指针前移
        //num[x] = z; // 基准值放在 x == y 处
        //print(num, 10);
    }
    num[x] = z; // 基准值放在 x == y 处
    print(num, 10);
    //cout << "l = " << l << ", x - 1 = " << x - 1 << endl;
    quick_sort(num, l, x - 1);
    //cout << "x +1 = " << x + 1 << ", r = " << r << endl;
    quick_sort(num, x + 1, r);
}


int main() {
    int num[10] = {5, 7, 8, 6, 4, 3, 1, 2, 7, 5};
    int num1[10] = {5, 7, 8, 6, 4, 3, 1, 2, 7, 5};
    print(num, 10);
    quick_sort(num, 0, 9);

    cout << "sort" << endl;
    sort(num, num + 9);
    print(num, 10);
    
    return 0;
}


```



## 4.8快速排序的优化

```cpp
#include <iostream>
using namespace std;

#define swap(a, b) {\
    __typeof(a) __temp = b;\
    b = a, a = __temp;\
}


void quick_sort(int *num, int l, int r) { // 快速排序优化思路：基准值的选取可以随意选，可以先选择最中间的那个，2.递归改为循环
    if (l > r) return ;
    // 如果选第一个作为基准值， 如果完全逆序，时间复杂度会退化，基准值选谁不重要，可以选择中间值做为基准值(二分查找)
    //
    while (l < r) {
        int x = l, y = r, z = num[(l + r) >> 1]; // 左右指针， 基准值:以中间值作为基准值
        do { //
            while (x <= y && num[x] < z) x++;
            while (x <= y && num[y] > z) y--;
            if (x <= y) {
                swap(num[x], num[y]);
                x++, y--;
            }
        } while (x <= y);
        quick_sort(num, x, r);
        r = y;
    }

}


int main() {

    int num[10] = {5, 7, 8, 6, 3, 4, 1, 2, 7, 5};
    quick_sort(num, 0, 9);

    for (int i = 0; i < 10; i++) {
        cout << num[i] << " ";
    }

    return 0;
}
```

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <ctime>
using namespace std;

#define swap(a, b) {\
    __typeof(a) __temp = b;\
    b = a, a = __temp;\
}

void quick_sortPlus(int *num, int l, int r) {
    while (l < r) {
        int x = l, y = r, z = num[(l + r) >> 1];
        do {
            while (x <= y && num[x] < z) x++;
            while (x <= y && num[y] > z) y--;
            if (x <= y) {
                swap(num[x], num[y]);
                x++, y--;
            }
        } while (x <= y);
        quick_sortPlus(num, x, r);
        r = y;
    }
}

void randint(int *num, int n) {
    while (n--) num[n] = rand() % 100;
}


void output(int *num, int n) {
    cout << "[";
    for (int i = 0; i < n; i++) {
        cout << num[i] << " ";
    }
    cout << "]" << endl;
    return ;
}
int main() {

    srand(time(0));
    #define MAX_N 20
    int arr[MAX_N];
    randint(arr, MAX_N); // 初始化随机值 
    printf("        ===>   ");
    output(arr, MAX_N);\
    
    printf("quick_sort++ = ");
    quick_sortPlus(arr, 0, MAX_N - 1);
    output(arr, MAX_N);

    #undef MAX_N

    return 0;
}

```

```cpp
        ===>   [84 46 45 90 54 1 42 55 9 71 40 45 56 65 33 20 67 18 78 88 ]
quick_sort++ = [1 9 18 20 33 40 42 45 45 46 54 55 56 65 67 71 78 84 88 90 ]
 
```



## 4.9二分查找

![截屏2021-02-02 下午11.03.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.58.png)

![截屏2021-02-02 下午11.03.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.03.59.png)

![截屏2021-02-02 下午11.04.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.01.png)

![截屏2021-02-02 下午11.04.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.02.png)

![截屏2021-02-02 下午11.04.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.04.png)

![截屏2021-02-02 下午11.04.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.05.png)

![截屏2021-02-02 下午11.04.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.07.png)

![截屏2021-02-02 下午11.04.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.08.png)

![截屏2021-02-02 下午11.04.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.10.png)

![截屏2021-02-02 下午11.04.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.11.png)

![截屏2021-02-02 下午11.04.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.13.png)

![截屏2021-02-02 下午11.04.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.15.png)







## 4.10三分查找

![截屏2021-02-02 下午11.04.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.16.png)

![截屏2021-02-02 下午11.04.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-02%20%E4%B8%8B%E5%8D%8811.04.18.png)





## 4.11哈希表

数组的性质：数组是展开的函数，函数是压缩的数组

数组可以由下表索引到值，时间复杂度$O(1$)



> 哈希表：将任意类型的元素映射成数组下标

### 哈希表

![截屏2021-02-01 上午11.37.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.54.png)



通过哈希函数映射成数组下标

16 % 9 = 7

![截屏2021-02-01 上午11.37.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.57.png)





![截屏2021-02-01 上午11.37.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.37.59.png)

7 % 9 = 7 发生冲突

![截屏2021-02-01 上午11.38.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.01.png)

### 处理冲突

方法一：开放定值法：下一个位置是否有值，如果没有存放到下一个位置

方法二：再哈希：用第二种哈希方法处理

方法三：拉链法：值建立一个链表，所有的值都存放在链表中

方法四：建立公共溢出区

![截屏2021-02-01 上午11.38.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.03.png)



![截屏2021-02-01 上午11.38.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-01%20%E4%B8%8A%E5%8D%8811.38.05.png)



### 代码演示

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//对字符串建立哈希表：BKDRHash
//冲突处理方法：拉链法
//结构定义

typedef struct Node {
    char *str;
    struct Node *next;
} Node;//链表结点

typedef struct HashTable {//哈希表结构定义
    Node **data;//存Node*
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {//初始化结点,将str插入到以head为头结点的链表中,头插法,所有的新节点都会插入到头部
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);//符串拷贝
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {//初始化哈希表，大小n
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n << 1;//哈希表的利用率一定小于100%，一般为50%~90%
    h->data = (Node **)calloc(h->size, sizeof(Node *));
    return h;
}

int BKDRHash(char *str) {
    int seed = 31;//初始化映射种子
    int hash = 0;
    for (int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;//防止hash变成负数，将符号位变成正数
}

int insert(HashTable *h, char *str) {//
    int hash = BKDRHash(str);//将字符串映射成整型数组下表
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *p = h->data[ind];
    while (p && strcmp(p->str, str)) p = p->next;
    return p != NULL;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    Node *p = node, *q;
    while (p) {
        q = p->next;
        free(p->str);
        p = q;
    }
    return ;
}

void clear_hashtable(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i < h->size; i++) {
        clear_node(h->data[i]);
    }
    free(h->data);
    free(h);
    return ;
}

int main() {
    int op;
    #define max_n 100
    char str[max_n + 5] = {0};
    HashTable *h = init_hashtable(max_n + 5);
    while (~scanf("%d%s", &op, str)) {
        switch(op) {
        case 0:
            printf("insert %s to HashTable\n", str);
            insert(h, str);
            break;
        case 1:
            printf("search %s fromm HashTable result = %d \n", str, search(h, str));
            break;
        }

    }
    #undef max_n
    clear_hashtable(h);



    return 0;
}
```



```
0 hello
insert hello to HashTable
0 haizei
insert haizei to HashTable
0 nihao
insert nihao to HashTable
1 haizei
search haizei fromm HashTable result = 1
1 haizeix
search haizeix fromm HashTable result = 0
1 nihao
search nihao fromm HashTable result = 1
1 hello
search hello fromm HashTable result = 1
^C
```

















































































# 5.堆与优先队列

## 5.1完全二叉树



![截屏2021-01-31 下午9.36.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.20.png)



完全二叉树:每一层都是满的，只有在最后一层不是满的

![截屏2021-01-31 下午9.36.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.23.png)

二叉树可以用数组存储



![截屏2021-01-31 下午9.36.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.29.png)

## 5.2堆

![截屏2021-01-31 下午9.36.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.31.png)



##  5.3堆尾部插入

自下向上调整

![截屏2021-01-31 下午9.36.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.35.png)

![截屏2021-01-31 下午9.36.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.37.png)

![](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.38.png)

![截屏2021-01-31 下午9.36.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.40.png)





## 5.4堆头部弹出/删除元素



![截屏2021-01-31 下午9.36.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.42.png)

取出最后一个元素当做头部元素

![截屏2021-01-31 下午9.36.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.44.png)

维护堆性质

![截屏2021-01-31 下午9.36.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.45.png)

![截屏2021-01-31 下午9.36.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.47.png)





## 5.5堆排序O(NlogN)

![截屏2021-01-31 下午9.36.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.48.png)

![截屏2021-01-31 下午9.36.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.50.png)

![截屏2021-01-31 下午9.36.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.52.png)

![截屏2021-01-31 下午9.36.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.53.png)



## 5.6堆/优先队列

![截屏2021-01-31 下午9.36.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.55.png)

![截屏2021-01-31 下午9.36.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-31%20%E4%B8%8B%E5%8D%889.36.56.png)

## 5.7优先队列代码实现

```c
// 大顶堆
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b, b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;//记录当前元素个数、全部元素数量
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));//下标从1开始
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {//输出队首元素
    return q->data[1];
}

int push(priority_queue *q, int val ) { //插入元素val
    if (q == NULL) return 0;//优先队列不存在
    if (q->cnt == q->size) return 0;//优先队列满了，不能插入
    //q->cnt++;
    q->data[++q->cnt] = val;
    //优先队列调整，自下向上
    int ind = q->cnt;
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {//当当前节点有父节点，且当前节点>父节点的值(大顶堆)
        swap(q->data[ind], q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}
int pop(priority_queue *q) {//头部弹出,堆顶弹出且调整
    if (q == NULL) return 0;//优先队列不存在
    if (empty(q)) return 0;//优先队列为空
    q->data[1] = q->data[q->cnt--];//取优先队列的最后一个元素赋值给头部，头部弹出
    //q->cnt--;
    //维护优先队列，自顶向下
    int ind = 1;
    while ((ind << 1) <= q->cnt) {//当前优先队列还有子节点
        int temp = ind, l = ind << 1, r = ind << 1 | 1;// r = ind * 2 + 1
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;//不一定有右孩子
        if (temp == ind) break;//当前节点就是三元组中最大的
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue * q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to the priority_queue !\n", val);
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    #undef man_op
    clear(q);
    return 0;
}

```



```shell
insert 9 to the priority_queue !
insert 33 to the priority_queue !
insert 31 to the priority_queue !
insert 51 to the priority_queue !
insert 86 to the priority_queue !
insert 36 to the priority_queue !
insert 68 to the priority_queue !
insert 46 to the priority_queue !
insert 65 to the priority_queue !
insert 32 to the priority_queue !
insert 64 to the priority_queue !
insert 9 to the priority_queue !
insert 42 to the priority_queue !
insert 64 to the priority_queue !
insert 28 to the priority_queue !
insert 77 to the priority_queue !
insert 48 to the priority_queue !
insert 66 to the priority_queue !
insert 27 to the priority_queue !
insert 5 to the priority_queue !
86 77 68 66 65 64 64 51 48 46 42 36 33 32 31 28 27 9 9 5
//弹出元素从大到小
```



## 5.8线性建堆

```cpp

```











# 6.森林与并查集O(n)



森林与并查集存在的意义：连通性

## 6.1Quick-Find算法

![截屏2021-04-24 上午9.39.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.00.png)

![截屏2021-04-24 上午9.39.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.03.png)

![截屏2021-04-24 上午9.39.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.04.png)

![截屏2021-04-24 上午9.39.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.06.png)

![截屏2021-04-24 上午9.39.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.08.png)

![截屏2021-04-24 上午9.39.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.09.png)

![截屏2021-04-24 上午9.39.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.10.png)

![截屏2021-04-24 上午9.39.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.12.png)

![截屏2021-04-24 上午9.39.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.13.png)

![截屏2021-04-24 上午9.39.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.15.png)

![截屏2021-04-24 上午9.39.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.16.png)

![截屏2021-04-24 上午9.39.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.18.png)

## 6.2Quick-Find代码演示

```cpp
#include <iostream>
using namespace std;

typedef struct UnionSet {
    int *color; // 标记颜色
    int n; // 大小
} UnionSet;

UnionSet *init(int n) { // 并查集初始化
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); // 初始化
    u->color = (int *)malloc(sizeof(int) * (n + 1)); // 从1号位开始存储
    u->n = n;
    // 初始化颜色
    for (int i = 1; i <= n; i++) {
        u->color[i] = i;
    }
    return u;
}

int find(UnionSet *u, int x) { // 查找操作，查找x
    return u->color[x]; // 返回当前元素的颜色
}

int merage(UnionSet *u, int a, int b) { // 合并操作, 合并a,b
    if (find(u, a) == find(u, b)) return 0; // a,b本身就有连通关系
    // 染色
    int color_a = u->color[a];
    for (int i = 1; i <= u->n; i++) {
        if (u->color[i] != color_a) continue; // if (u->color[i] - color_a)
        u->color[i] = u->color[b]; // 找到和u->color[a] 一样的颜色
    }
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->color);
    free(u);
    return ;
}


int main() {

    return 0;
}
```



## 6.3Quick-Find解题

![截屏2021-04-24 上午10.23.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%8810.23.41.png)

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

typedef struct UnionSet {
    int *color; // 标记颜色
    int n; // 大小
} UnionSet;

UnionSet *init(int n) { // 并查集初始化
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); // 初始化
    u->color = (int *)malloc(sizeof(int) * (n + 1)); // 从1号位开始存储
    u->n = n;
    // 初始化颜色
    for (int i = 1; i <= n; i++) {
        u->color[i] = i;
    }
    return u;
}

int find(UnionSet *u, int x) { // 查找操作，查找x
    return u->color[x]; // 返回当前元素的颜色
}

int merage(UnionSet *u, int a, int b) { // 合并操作, 合并a,b
    if (find(u, a) == find(u, b)) return 0; // a,b本身就有连通关系
    // 染色
    int color_a = u->color[a];
    for (int i = 1; i <= u->n; i++) {
        if (u->color[i] != color_a) continue; // if (u->color[i] - color_a)
        u->color[i] = u->color[b]; // 找到和u->color[a] 一样的颜色
    }
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->color);
    free(u);
    return ;
}


int main() {
    int n, m;
    scanf("%d%d", &n, &m); // 分别代表人数和操作数。
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        switch (a) {
        case 1:// 代表新增一条已知信息，𝑏,𝑐 是朋友
            merage(u, b, c); break;
        case 2: // 代表根据以上信息，询问 𝑏,𝑐 是否是朋友
            cout << (find(u, b) == find(u, c) ? "Yes" : "No") << endl;
            break;
        }
    }

    return 0;
}
```



## 6.4Quick-Union算法

Quick-Find 找代表元素

Quick-Union 找大哥



将6，5连通

![截屏2021-04-24 上午9.39.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.19.png)

![截屏2021-04-24 上午9.39.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.20.png)

![截屏2021-04-24 上午9.39.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.21.png)

![截屏2021-04-24 上午9.39.22](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.22.png)

![截屏2021-04-24 上午9.39.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.23.png)

![截屏2021-04-24 上午9.39.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.25.png)

![截屏2021-04-24 上午9.39.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.26.png)

![截屏2021-04-24 上午9.39.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.27.png)

![截屏2021-04-24 上午9.39.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.28.png)

![截屏2021-04-24 上午9.39.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.29.png)



## 6.5Quick-Union代码演示

```

```











![截屏2021-04-24 上午9.39.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-04-24%20%E4%B8%8A%E5%8D%889.39.31.png)

























































------





 
