\---

title: 网络编程

date: 2020-12-29 08:08:15

tags: 网络编程

categories: 网络编程

\---



> 2020.12.29
>
> 说明:本文档的部分图片来至于开课吧宿船长PPT

# 一、系统编程

# 1.Linux下命令行解析



## 1.getopt函数

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.48.49.png" alt="截屏2021-01-05 上午9.48.49" style="zoom:80%;" />



![截屏2021-01-05 上午9.58.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.40.png)



![截屏2021-01-05 上午9.58.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.58.59.png)



## 2.getopt函数代码演示

### 演示1

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv) {
    int opt;
    while ((opt = getopt(argc, argv, "al")) != -1) {
      //循环把参数读入opt中，直到函数返回值为-1
        switch (opt) {
        case 'a':
            printf("a found!\n");
            break;
        case 'l':
            printf("l found!\n");
            break;
        default:
            fprintf(stderr, "Usage : %s -al\n", argv[0]);
            exit(-1);
        }
    }
    return 0;
}
```





编译后运行结果

```c
./a.out ls -al -d                                                                                        
a found!
l found!
./a.out: invalid option -- 'd'
Usage : ./a.out -al
```

<!--more-->

### 演示2：可选和不可选参数

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv) {
    int opt;
    while ((opt = getopt(argc, argv, "alm:o::")) != -1) {
        switch (opt) {
        case 'a':
            printf("a found!\n");
            break;
        case 'l':
            printf("l found!\n");
            break;
        case 'm':
            printf("msg = %s \n", optarg);
            break;
        case 'o':
            printf("opt = %s\n", optarg);
            break;
        default:
            fprintf(stderr, "Usage : %s -al\n", argv[0]);
            exit(-1);
        }
    }
    return 0;
}
```



```shell
#运行结果
./a.out -m "lsm1" -m"lsm2" -o"lso1" -o "lso2"               
msg = lsm1
msg = lsm2
opt = lso1
opt = (null)
#加入m后面没有参数
./a.out   -m              
./a.out: option requires an argument -- 'm'
Usage : ./a.out -al
```





## 3.extern



## 4.optind,optopt

```cpp
#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv) {
    printf("optind = %d \noptopt = %d\n", optind, optopt);
    return 0;
}
```



```zsh
#运行结果
optind = 1
optopt = 0
```







# 2.文件与IO

## 0.概述

>所有执行 I/O 操作的系统调用都以文件描述符，一个非负整数（通常是小整数），来指代 打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、 设备和普通文件。针对每个进程，文件描述符都自成一套。



>按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符，见表 4-1。在程序开始运 行之前，shell 代表程序打开这 3 个文件描述符。更确切地说，程序继承了 shell 文件描述符的 副本—在 shell 的日常操作中，这 3 个文件描述符始终是打开的。（在交互式 shell 中，这 3 个文件描述符通常指向 shell 运行所在的终端。）如果命令行指定对输入/输出进行重定向操作， 那么 shell 会对文件描述符做适当修改，然后再启动程序。

![截屏2021-01-07 下午3.51.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.51.09.png)





下面介绍执行文件 I/O 操作的 4 个主要系统调用（编程语言和软件包通常会利用 I/O 函数 库对它们进行间接调用）。 

1.  fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描 述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以 创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式：只 读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限， 如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。 

   

2. numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的 数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节 可读（例如：读到文件结尾符 EOF 时），则返回值为 0。 

   

3. numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由 fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可 能小于 count。 

   

4. status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及 与之相关的内核资源。





## 1.打开一个文件:open函数



### 1.open简介

`int open(const char *pathname, int flags)`

![截屏2021-01-07 下午3.55.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.55.29.png)

​		

​		要打开的文件由参数 pathname 来标识。如果 pathname 是一符号链接，会对其进行解引用。 如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。若发生错误， 则返回−1，并将 errno 置为相应的错误标志。

​		

​		参数 flags 为位掩码，用于指定文件的访问模式，

![截屏2021-01-07 下午3.57.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.57.06.png)

​		

​		当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode 的数据类型 mode_t 属于整数类型。）如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。

​		SUSv3 规定，如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最 小者。可以利用该特性以特定文件描述符打开某一文件。



### 2.open()调用中的 flags 参数

![截屏2021-01-07 下午4.07.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.07.42.png)

![截屏2021-01-07 下午4.13.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.13.14.png)



### 3.open()函数的错误

若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能 发生的错误（除了在上节参数描述中已经提及的错误之外）。 

EACCES 

​		文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原 因有目录权限的限制、文件不存在并且也无法创建该文件。 

EISDIR 

​		所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。

 EMFILE 

​		进程已打开的文件描述符数量达到了进程资源限制所设定的上限

 ENFILE 

​		文件打开数量已经达到系统允许的上限。 

ENOENT 

​		要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存 在（空链接）。

EROFS 

​		所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。 

ETXTBSY 

​		所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如 以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）



### 4.open代码演示

> `open, read, write, close`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main() {
    int fd;
    char buff[512] = {0};
    ssize_t nread;
    if ((fd = open("./a.txt", O_CREAT | O_RDONLY)) < 0) {//打开文件
        perror("open");
        exit(1);//return 1;
    }
    while ((nread = read(fd, buff, sizeof(buff))) > 0) {//从fd读入到buff，每次的大小为buff的大小
        printf("read %ld\n buffer =  %s", nread, buff);
        memset(buff, 0, sizeof(buff));
    }
    close(fd);
    return 0;
}
```

`perror : perror - print a system error message`

打印系统错误信息



## 2.读取文件内容:read() 

> read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。

![截屏2021-01-07 下午4.15.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.15.35.png)

​		count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。

​		如果 read()调用成功，将==返回实际读取的字节数==，如果遇到文件结束（EOF）则返回 0， 如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数 或-1（表示错误）。

​		一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是 因为当前读取位置靠近文件尾部。 

​		当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会 出现 read()调用读取的字节数小于请求字节数的情况。

![截屏2021-01-07 下午4.22.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.22.37.png)

## 3.数据写入文件:write()

> write()系统调用将数据写入一个已打开的文件中。

![截屏2021-01-07 下午4.24.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.24.18.png)



​		write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count 参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。 

​		如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。 这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因 为进程资源对文件大小的限制。 

​		对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减 少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作。



## 4.关闭文件：close() 

> ​		close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。 当一进程终止时，将自动关闭其已打开的所有文件描述符。

![截屏2021-01-07 下午4.26.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%884.26.46.png)

​		显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可 读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导 致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比 如 shell 或者网络服务器软件，需要特别加以关注。



小结：为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用 read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系 统调用可对所有类型的文件执行 I/O 操作。 所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时 也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。



## 5.fopen函数

> `fopen, fwrite, fread, fclose`



```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


int main() {

    FILE *fp = NULL;
    if ((fp = fopen("./b.txt", "r")) == NULL) {
        perror("fopen");//fopen: No such file or directory
        exit(1);
    }
    while (1) {//循环读入，直到文件结尾
        char buff[512] = {0};
        size_t nread = fread(buff, 1, sizeof(buff), fp);
        printf("%s", buff);
        if (nread <= 0) break;
    }
    fclose(fp);

    return 0;
}

```



标准IO都是缓冲IO

标准错误输出都会无缓冲输出



```c
#include <unistd.h>
int main() {
    sleep(2);
    fprintf(stderr, "Hello world!\n");
    printf("Hello world!\n");
    fflush(stdout);
    sleep(2);
    sleep(5);

    return 0;
}
```

sleep()库函数可将当前执行的进程挂起指定的秒数。



# 3.阻塞IO与非阻塞IO

## 1.阻塞和非阻塞的概念

> 什么是阻塞、什么是非阻塞

阻塞操作是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。非阻塞操作的进程在不能进行设备操作时并不挂起，它或者放弃，或者不停地查询，直至可以进行操作为止。



阻塞就是数据给了内核，内核没有返回结果之前，你必须等待。非阻塞就是数据给了内核，不论结果如何。

阻塞的代价：必须等待，等待会占用系统资源

非阻塞的优点：不会占用系统资源

非阻塞的代价



## 2.对阻塞非阻塞的理解



>废话不说，老张爱喝茶，煮开水，有两个水壶，普通水壶，响水壶（水开会提示）

**同步**就是普通水壶烧开水，要没事儿自己过来来看开没开；
**异步**就是响水壶烧开水，水开了水壶响了通知你。
**阻塞**是烧开水的过程中，你不能干其他事情（即你被阻塞住了），只能站那等水开；
**非阻塞**是烧开水的过程里可以干其他事情。比如去客厅看看电视；

> 同步与异步说的是你获得水开了的方式不同。
> 阻塞与非阻塞说的是你得到结果之前能不能干其他事情。
> 两组概念描述的是不同的内容。

这里你看明白了，就会发现：

> 效率最高的办法是 **响水壶烧水（异步）**
> **水烧开提示你之前可以去干别的事儿（非阻塞）**
> 等到水开了提示你你再去拿水
> 所以异步和非阻塞常常在一起大大提高每个线程的效率



摘自[阻塞](https://blog.csdn.net/evanxuhe/article/details/79627709)

## 3.非阻塞IO有什么用

当我们告诉内核，如果数据没有到来，你立马给我返回，不用等待数据了。设置成非阻塞的方法如下。

```c
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);   //设置成非阻塞模式；
```

其实非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。、



用户态下沉到内核态

内核是一个快缓冲

fcntl



## 4.fcntl()

fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。

函数原型

![截屏2021-01-08 上午10.55.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.21.png)

函数描述

![截屏2021-01-08 上午10.55.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8810.55.49.png)

​		cmd 参数所支持的操作范围很广。

​		fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省 略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。



​		fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是 通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为 F_GETFL。

fcntl函数有5种功能：

　 1.复制一个现有的描述符（cmd=F_DUPFD）.

　 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).

​      3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).

​      4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).

​      5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).



## 5.fcntl()代码演示

### 1.00.head.h

头文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "05.common.h"
```

### 2.04.common.c

阻塞与非阻塞的实现

```c
#include "00.head.h"


int make_nonblock(int fd) {//设置非阻塞
    //fcntl(fd, F_SETFL, O_NONBLOCK);
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {//获得文件状态标记
        return -1;
    }
    flag |= O_NONBLOCK;//flag = O_NONBLOCK,以非阻塞方式打开，在原先flag的基础加上非阻塞方式
    return fcntl(fd, F_SETFL, flag);//设置文件状态标记
}

int make_block(int fd) {//设置阻塞方式
    //fcntl(fd, F_SETFL, O_NONBLOCK);
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {//获得文件状态标记flag
        return -1;
    }
    flag &= ~O_NONBLOCK;//flag = O_NONBLOCK,以非阻塞方式打开，设置非阻塞方式
    return fcntl(fd, F_SETFL, flag);//设置文件状态标记
}

```

### 3.05.common.h

```

#ifdef _COMMON_H
#define _COMMON_H
int make_nonblock(int fd);
int make_block(int fd);
#endif
```

### 4.07.testblock.c

//测试阻塞和非阻塞

```c
#include "00.head.h"
//test1
int make_nonblock(int fd);
int main() {
    int age;
    make_nonblock(0);//设置当前文件打开方式为非阻塞

    int ret = scanf("%d", &age);
    printf("guziqiu is %d years old!, ret = %d \n", age, ret);
    perror("scanf");//打印scanf错误信息

    return 0;
}

//输出结果
guziqiu is -151492080 years old!, ret = -1
scanf: Resource temporarily unavailable
  //sacnf返回值是成功读入变量的个数，-1为报错
  //文件资源占时不可访问
  
 //test 2 
int make_nonblock(int fd);
int main() {
    int age;
    make_nonblock(0);//设置当前文件打开方式为非阻塞
		sleep(5);
    int ret = scanf("%d", &age);
    printf("guziqiu is %d years old!, ret = %d \n", age, ret);
    perror("scanf");//打印scanf错误信息

    return 0;
}
//输出结果
18
guziqiu is 18 years old!, ret = 1
scanf: Success
```



## 6.select()

部分内容来至于[linux select函数解析以及事例](https://zhuanlan.zhihu.com/p/57518857)

### 6.1select详解

IO感知

![截屏2021-01-08 下午4.25.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8B%E5%8D%884.25.54.png)

```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int nfd, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);
/*
nfds：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；

readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。

timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间
*/
```



参数说明

- nfds：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错。在linux系统中，select的默认最大值为1024。设置这个值的目的是为了不用每次都去轮询这1024个fd，假设我们只需要几个套接字，我们就可以用最大的那个套接字的值加上1作为这个参数的值，当我们在等待是否有套接字准备就绪时，只需要监测maxfd+1个套接字就可以了，这样可以减少轮询时间以及系统的开销。
- readfds：首先需要明白，fd_set是什么数据类型，有一点像int，又有点像struct，其实，fd_set声明的是一个集合，也就是说，readfs是一个容器，里面可以容纳多个文件描述符，把==需要监视的描述符==放入这个集合中，==当有文件描述符可读时，select就会返回一个大于0的值，表示有文件可读==；
- writefds：和readfs类似，表示有一个==可写的文件描述符==集合，当有文件可写时，select就会返回一个大于0的值，表示有文件可写；
- fd_set*errorfds同上面两个参数的意图，用来==监视文件错误异常文件==。
- timeout：这个参数一出来就可以知道，可以选择阻塞，可以选择非阻塞，还可以选择定时返回。当将timeout置为NULL时，表明此时select是阻塞的；当将tineout设置为timeout->tv_sec = 0，timeout->tv_usec = 0时，表明这个函数为非阻塞；当将timeout设置为非0的时间，表明select有超时时间，当这个时间走完，select函数就会返回。从这个角度看，个人觉得可以用select来做超时处理，因为你如果使用recv函数的话，你还需要去设置recv的模式，麻烦的很。



```c
struct timeval{      

                long tv_sec;   /*秒 */

                long tv_usec;  /*微秒 */   

            }
```

返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目

fd_set的几个宏：

```c
void FD_ZERO(fd_set *set);//一个 fd_set类型变量的所有位都设为 0
void FD_SET(int fd, fd_set *set);//清除某个位时可以使用
void FD_CLR(int fd, fd_set *set); //设置变量的某个位置位
int  FD_ISSET(int fd, fd_set *set);//测试某个位是否被置位
```



对fd_set的理解：fd_set可以理解为一个集合，那么集合就会有一个数量，在<sys/select.h>总定义了一个常量FD_SETSIZE，默认为1024，也就是说在这个集合内默认最多有1024个文件描述符，但是通常你用不了这么多，你通常只是关心nfds个描述符。也就是说你现在有nfds个文件描述符在这个集合里，那么我怎么知道集合里的哪个文件描述符有消息来了呢？你可以将fd_set中的集合看成是二进制bit位，一位代表着一个文件描述符。==0代表文件描述符处于睡眠状态，没有数据到来；1代表文件描述符处于准备状态，可以被应用层处理。==我觉得select函数可以分下面几步进行理解

1. 在你开始监测这些描述符时，你先将这些文件描述符全部置为0
2. 当你需要监测的描述符置为1
3. 使用select函数监听置为1的文件描述符是否有数据到来
4. ==当状态为1的文件描述符有数据到来时，此时你的状态仍然为1，但是其他状态为1的文件描述如果没有数据到来，那么此时会将这些文件描述符置为0==
5. 当select函数返回后，可能有一个或者多个文件描述符为1，那么你怎么知道是哪个文件描述符准备好了呢？其实select并不会告诉你说，我哪个文件描述符准备好了，他只会告诉你他的那些bit为位哪些是0，哪些是1。也就是说你需要自己用逻辑去判断你要的那个文件描是否准备好了

理解了上面几步的话，下面这些宏就比较好理解了。

- FD_ZERO：将指定集合里面所有的描述符全部置为0，==在对文件描述符集合进行设置前，必须对其进行初始化==，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的
- FD_SET：用于在文件描述符集合中增加一个新的文件描述符，将相应的位置置为1
- FD_CLR：用来清除集合里面的某个文件描述符
- FD_ISSET：用来检测指定的某个描述符是否有数据到来。- 那么假如在我们的程序中有5个客户端已经连接上了服务器，这个时候突然有一条数据过来了。select返回了，但是此时你并不知道是哪个客户发过来的消息，因为你每个客户发过来的消息都是一样重要的。所以你没法去只针对一个套接字使用FD_ISSET，你需要做的是用一个循环去检测（FD_ISSET）到底是哪一个客户发过来的消息，因为如果此时你监测一个套接字的话，其他客户的信息你会丢失。这个也是select的一个缺点，你需要去检测所有的套接字，看看这个套接字到底是谁来的数据。



### 6.2对fd_set的理解

理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。

（1）执行fd_set set; FD_ZERO(&set); 则set用位表示是0000,0000。

（2）若fd＝5,执行FD_SET(fd,&set);后set变为0001,0000(第5位置为1)

（3）若再加入fd＝2，fd=1,则set变为0001,0011

（4）执行select(6,&set,0,0,0)阻塞等待

（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。



内容来自[Linux编程之select](https://www.cnblogs.com/skyfsm/p/7079458.html)

### 6.3select代码演示

**select的使用流程**

1.先调用宏FD_ZERO将指定的fd_set清零，

2.然后调用宏FD_SET将需要测试的fd加入fd_set，

3.接着调用函数select监测fd_set中的所有fd，

4.最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1，然后做相应的逻辑处理。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int main(void) {
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Watch stdin (fd 0) to see when it has input. */

    FD_ZERO(&rfds);//将rdfs的fd_set清零，
    FD_SET(0, &rfds);//fd = 0

    /* Wait up to five seconds. */

    tv.tv_sec = 5;//等待5秒
    tv.tv_usec = 0;//设置等待微秒

    retval = select(1, &rfds, NULL, NULL, &tv);//fd + 1
    /* Don't rely on the value of tv now! */

    if (retval == -1)
        perror("select()");//失败
    else if (retval)
        printf("Data is available now.\n");//成功
        /* FD_ISSET(0, &rfds) will be true. */
    else
        printf("No data within five seconds.\n");//超时

    exit(EXIT_SUCCESS);
}
```





```shell
./a.out                                                  
ls
Data is available now.
apricity@Apricity% ls
00.head.h  01.open.c  02.fopen.c  03.fflush.c  04.common.c  05.common.h  06.fork.c  07.testblock.c  08.select.c  a.out  b.txt
```



==>为什么会出现 ls命令

输入ls,select感知IO成功,程序执行完毕，ls被zsh执行

```c
else if (retval) {
   char buff[512] = {0};
   printf("Data is available now.\n");//成功
   scanf("%s", buff);//吃掉输入的数据
}
       
```



## 6.补充:用户态和内核态















# 4.多进程

## 1.什么是进程



> 什么是程序

程序是编译好的可执行的二进制文件。应用是程序的集合。



> 什么是进程

一种说法是进程是程序在内存中的镜像，另一种常见的说法是进程是运行中的程序。

进程（process）是一个可执行程序（program）的实例。



**进程号和父进程号**

​		每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。对 各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。

​		系统调用 getpid()返回调用进程的进程号。

```c
#include <unistd.h>
pid_t  getpid(void);
pid_t  getppid(void);
```

​		getpid()返回值的数据类型为 pid_t，该类型是由 SUSv3 所规定的整数类型，专用于存储进 程号。 

​		除了少数系统进程外，比如 init 进程（进程号为 1），程序与运行该程序进程的进程号之 间没有固定关系。

​		每个进程都有一个创建自己的父进程。使用系统调用 getppid()可以检索到父进程的进程号。

​		实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父 进程又有自己的父进程，以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。

​		如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程，子 进程后续对 getppid()的调用将返回进程号 1。



**孤儿进程与僵尸进程**

父进程与子进程的生命周期一般都不相同，父、子进程间互有长短。这就引出了下面两个问题。 

- 谁会是孤儿（orphan）子进程的父进程？进程 ID 为 1 的众进程之祖—init 会接管孤儿 进程。换言之，某一子进程的父进程终止后，对 getppid()的调用将返回 1。这是判定 某一子进程之“生父”是否“在世”的方法之一（前提是假设该子进程由 init 之外的 进程创建）。

- 在父进程执行 wait()之前，其子进程就已经终止，这将会发生什么？此处的要点在于，即使 子进程已经结束，系统仍然允许其父进程在之后的某一时刻去执行 wait()，以确定该子进程 是如何终止的。内核通过将子进程转为僵尸进程（zombie）来处理这种情况。这也意味着将 释放子进程所把持的大部分资源，以便供其他进程重新使用。该进程所唯一保留的是内核进 程表中的一条记录，其中包含了子进程ID、终止状态、资源使用数据等信息。

  ​		至于僵尸进程名称的由来，则源于 UNIX 系统对电影情节的效仿—无法通过信号来杀死 僵尸进程，即便(银弹）SIGKILL。这就确保了父进程总是可以执行 wait()方法。 

  ​		当父进程执行 wait()后，由于不再需要子进程所剩余的最后信息，故而内核将删除僵尸进 程。另一方面，如果父进程未执行 wait()随即退出，那么 init 进程将接管子进程并自动调用 wait()，从而从系统中移除僵尸进程.

  ​		如果父进程创建了某一子进程，但并未执行 wait()，那么在内核的进程表中将为该子进程永 久保留一条记录。如果存在大量此类僵尸进程，它们势必将填满内核进程表，从而阻碍新进程的 创建。既然无法用信号杀死僵尸进程，那么从系统中将其移除的唯一方法就是杀掉它们的父进程 （或等待其父进程终止），此时 init 进程将接管和等待这些僵尸进程，从而从系统中将它们清理掉。

  

## 2.fork()详解

>fork()创建一个子进程

![截屏2021-01-07 下午6.18.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%886.18.51.png)

​		系统调用 `fork()`允许一进程（父进程）创建一新进程（子进程）。具体做法是，新 的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文 本段的拷贝。可将此视为把父进程一分为二，术语 fork 也由此得名。

​		理解 fork()的诀窍是，要意识到，完成对其调用后将存在两个进程，且每个进程都会从 fork() 的返回处继续执行。 

​		这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。执行 fork() 之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。 

​		程序代码则可通过 fork()的返回值来区分父、子进程。在父进程中，fork()将返回新创建 子进程的进程 ID。鉴于父进程可能需要创建，进而追踪多个子进程（通过 wait()或类似方法）， 这种安排还是很实用的。而 fork()在子进程中则返回 0。如有必要，子进程可调用 getpid()以获 取自身的进程 ID，调用 getppid()以获取父进程 ID。 

​		当无法创建子进程时，fork()将返回-1。失败的原因可能在于，进程数量要么超出了系统 针对此真实用户（real user ID）在进程数量上所施加的限制，要么是触及允许该系统创建的最大进程数这一系统级上限。



**重点**

1.pid_t进程id

2.创建一个新的进程，复制了一份自己,新的进程被叫作子进程,父亲和孩子分别运行在一个完全独立隔离的内存空间，fork时，共用一样的内存空间，只有内存才发生变化时，拷贝才会真实发生(称为写拷贝)

子进程是一个严格的

3.==fork()的子进程返回值为0，父进程返回子进程pid==

4.子进程和父进程的区别：

子进程和父进程的进程ID不一样，且唯一

子进程的父亲ID和父亲pid一样

孩子不会继承父亲的内存锁

进程资源使用和CPU使用都会被清空

- 子进程不继承信号量

- 不会继承计时器

- 不会继承异步IO操作

  进程的属性

返回值：

父进程中返回子进程的pid,子进程返回0,

getpid获得自己的id

getppid获得父进程id







## 3.fork()代码演示

### 3.1fork()理解

#include "00.head.h"

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/time.h>
```



```c
#include "00.head.h"
int main() {

    char name[20] = {0};
    scanf("%s", name);
    printf("%s", name);
    fork();
    return 0;
}
//结果
guziqiu
guziqiuguziqiu%
```

==>输出2个`name变量`

原因:fork之后的代码会有两份，之前的代码只执行了一次,标准IO是缓冲IO(没有遇到换行或者缓冲区内容过多或者程序结束，printf的内容会留在输出缓冲区,缓冲区内容被fork,return  0 ;后输出缓冲区内容被释放，输出一个name变量)

```c
#include "00.head.h"
int main() {

    char name[20] = {0};
    scanf("%s", name);
    printf("%s\n", name);
    fork();
    return 0;
}
```

==>输出1个`name`

标准IO是缓冲IO,缓冲区被换行符刷新

```c
#include "00.head.h"
int main() {

    char name[20] = {0};
    scanf("%s", name);
    fork();
    printf("%s\n", name);
    
    return 0;
}
```

==>输出2个`name`

fork后的内容被复制

### 3.2.fork()进阶

```c
#include "00.head.h"
int main() {

    pid_t pid;
    if ((pid = fork()) < 0) {//必须有括号，否则逻辑会不同，子进程一生下来就在11行的位置
        perror("fork()");//fork出错，fork = -1,大部分是因为内存不够
        exit(1);
    }
     
    if (pid == 0) {//==>思考：一定是父进程先执行吗?
        //父进程和子进程空间相互独立，谁先跑都没有关系，由内核调度决定
        //基于内核算法，极大概率先执行父进程
        //原因:父进程正在执行，此时复制父进程，父进程执行完才会执行子进程，所以一般会先执行父进程
        //如果此时cpu强制停用父进程，先执行别的进程，则可能会出现子进程先执行
        printf("Child Process!\n");
    } else {
        printf("Parent Process\n");//父子进程有同一份代码，孩子从11行开始
    }
    //父进程管理子进程，
    return 0;
}
```







## 4.wait()详解

​		系统调用 `wait()`等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回 该子进程的终止状态。

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *wstatus);
```

系统调用 wait()执行如下动作。 

1． 如果调用进程并无之前未被等待的子进程终止 ，调用将一直阻塞，直至某个子进程终止。 如果调用时已有子进程终止，wait()则立即返回。

 2． 如果 status 非空，那么关于子进程如何终止的信息则会通过 status 指向的整型变量返回。 

 3． 内核将会为父进程下所有子进程的运行总量追加进程 CPU 时间以及资源使用 数据。 

4． 将终止子进程的 ID 作为 `wait()`的结果返回。

​		出错时，wait()返回-1。可能的错误原因之一是调用进程并无之前未被等待的1子进程，此 时会将 errno 置为 ECHILD。换言之，可使用如下代码中的循环来等待调用进程的所有子进程 退出。





子进程退出状态

所有的系统进程都在等待子进程的变化，并且获得状态变化（孩子被终结，杀死，唤醒），对于一个被终结的进程，执行wait，由系统释放孩子所关联的资源

孩子死了父进程没有为孩子收尸，孩子变成了僵尸进程，没有占用cpu但是会占用系统资源和pid，

wait没有被执行会变成僵尸进程

如果进程以及死了，wait会立马返回，孩子没死，父进程会一直等着，或者收到一个中断信号



​		父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。
注：

1. 当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.
2. wait()要与fork()配套出现,如果在使用fork()之前调用wait(),wait()的返回值则为-1,正常情况下wait()的返回值为子进程的PID.
3. 如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.
4. 参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就像下面这样：
   `pid = wait(NULL);`
   如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。
   　　如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作，下面我们来学习一下其中最常用的两个：
   1，WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。
   （请注意，虽然名字一样，这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数，切记不要搞混了。）
   2， WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。





## 5.wait()代码演示

### 产生僵尸进程

`fork.c`

```c
#include "00.head.h"
int main() {

    pid_t pid;
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }
    if (pid == 0) {
        printf("Child Process!\n");
    } else {
        printf("Parent Process\n");
        while(1) {
            printf("--sleep(5)");
            sleep(5);
            printf("--");
        }
    }

   return 0;
}
```



```shell

apricity@Apricity 00.课程代码 % ./a.out                                                                                                   
Parent Process
Child Process!
^Z
[1]  + 16838 suspended  ./a.out
apricity@Apricity 00.课程代码 % bg                            
[1]  + 16838 continued  ./a.out
apricity@Apricity 00.课程代码 % ps                                                                                                        
  PID TTY          TIME CMD
16342 pts/0    00:00:03 zsh
16838 pts/0    00:00:00 a.out
16839 pts/0    00:00:00 a.out <defunct>#僵尸进程
16842 pts/0    00:00:00 ps
apricity@Apricity 00.课程代码 %ps -aux | grep 16839                
apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] <defunct>
apricity 16852  0.0  0.0  14428  1044 pts/0    S+   11:15   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox 16839
apricity@Apricity 00.课程代码 % ps -aux | grep Z             
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
apricity 16839  0.0  0.0      0     0 pts/0    Z    11:12   0:00 [a.out] <defunct>
apricity 16858  0.0  0.0  14428   996 pts/0    S+   11:16   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox Z
#Z的意思就是僵尸进程
```



`fork.wait.c`

```c
#include "00.head.h"
int main() {

    pid_t pid;
    int status;
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }
    if (pid == 0) {
        sleep(5);
        printf("Child Process!\n");
        return 1;
    } else {
            printf("Parent Process\n");
            wait(&status);
            printf("--wait status = %d \n", status);
    }

   return 0;
}

```



```shell
./a.out                                                            
Parent Process
Child Process!
--wait status = 256
```



创建10个子进程,每个子进程打印自己是子进程

```c
#include "00.head.h"
int main() {

    pid_t pid;
    int status;
    int i;
    for (i = 1; i <= 9; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
    }
    if (pid == 0) {
        printf(" I am %d Child Process!\n", i);
        sleep(500);
    } 
   return 0;
}
```



```shell
ps -ef | grep  "./a.out" | grep -v "grep" | wc -l
1024
#一共产生1024个进程
#2^10 = 1024，会以子数倍增长
```



```c
#include "00.head.h"
int main() {

    pid_t pid;
    int status;
    int i;
    for (i = 1; i <= 10; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
        if (pid == 0) break;;
    }
    if (pid == 0) {
        printf(" I am %d Child Process!\n", i);

        sleep(500);
  
    }
   return 0;
}
```

```shell
./a.out                                                            
 I am 1 Child Process!
 I am 3 Child Process!
 I am 2 Child Process!
 I am 4 Child Process!
 I am 9 Child Process!
 I am 10 Child Process!
 I am 5 Child Process!
 I am 6 Child Process!
 I am 7 Child Process!
 I am 8 Child Process!
ps -aux | grep "a.out" | grep -v "grep" | wc -l                                              
10
```



## 6.exec()家族详解

​		系统调用 execve()可以将新程序加载到某一进程的内存空间。在这一操作过程中，将丢弃 旧有程序，而进程的栈、数据以及堆段会被新程序的相应部件所替换。

​		基于系统调用 execve()，还提供了一系列冠以 exec 来命名的上层库函数，虽然接口方式 各异，但功能相同。通常将调用这些函数加载一个新程序的过程称作 exec 操作，或是简单地 以 exec()来表示。

```c
#include <unistd.h>
extern char **environ;
int execl(const char *path, const char *arg, ...
                       /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
                       /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                       char *const envp[]);
```

​		

​		参数 pathname 包含准备载入当前进程空间的新程序的路径名，既可以是绝对路径（冠 之以/），也可以是相对于调用进程当前工作目录（current working directory）的相对路径。

​		参数 argv 则指定了传递给新进程的命令行参数。该数组对应于 C 语言 main()函数的第 2 个参数（argv），且格式也与之相同：是由字符串指针所组成的列表，以 NULL 结束。argv[0]的 值则对应于命令名。通常情况下，该值与 pathname 中的 basename（路径名的最后部分）相同。

​		最后一个参数 envp 指定了新程序的环境列表。参数 envp 对应于新程序的 environ 数组：也是由字符串指针组成的列表，以 NULL 结束，所指向的字符串格式为 name=value。



　exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件**。**这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。

　　与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行





exec族的任一函数都不创建一个新的进程，而是在调用进程里面去执行新的程序。所以进程id不变，还是调用exec函数前的进程id，但是用户空间的代码和数据都更新了，变为新程序的代码和数据了。 

​	extern char **environ;	//全局环境变量，导入到本文件即可直接使用

1. int execl(const char *path, const char *arg, ...);	

​	功能：通过路径+文件名来加载一个进程；path文件路径；arg文件名称；...可变参数，至少一个NULL

​	附：l即list 

​	返回值：成功的情况下是没有返回的，失败时返回-1 。

​	举例说明：

​		execl("/bin/ls", "ls", "-a", "-l", NULL);	//path绝对路径，如/bin/ls；文件名称ls；后面三个可变参数，最后必须以NULL结束

2. int execlp(const char *file, const char *arg, ...);	

​	功能：借助PATH环境变量加载一个进程，file要加载的程序的名称

​	附：l即list；p即path 

​	该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数file，则出错返回。

​	该函数通常用来调用系统程序。如：ls、cp、cat等命令。 

​	返回值：成功的情况下是没有返回的，失败时返回-1 。

​	举例说明：

​		execlp("ls", "ls", "-a", "-l", NULL);	//第一个ls是指查看PATH环境变量里的ls；第二个ls是名称文件；后面是可变参数，NULL结束

3. int execle(const char *path, const char *arg, ..., char * const envp[]);	

​	功能：加载指定路径的程序，并为新程序复制最后一个环境变量

 附：l即list；e即environment

​	举例说明：

​		char* envp[] = {NULL};

​		execlp("ls", "ls", "-a", "-l", NULL, envp);

4. int execv(const char *path, char *const argv[]);

​	功能：加载指定路径的程序 

​	附：v即vector，命令行参数列表

​	举例说明：

​		char* argv[] = {"ls", "-a", "-l", NULL}; 

​		execl("/bin/ls",argv);

5. int execvp(const char *file, char *const argv[]);

​	功能：加载path环境变量里的名称为file的程序 

​	附：v即命令行参数列表，p即path 

​	int main(int argc, char *argv[]) {

​		pid_t pid = fork();

​		if (pid == 0) {	//子进程里加载ls程序

​			char* argvv[] = {"ls", "-a", "-l", NULL};

​			execvp("ls", argvv);

​			perror("execlp");  exit(1);	//只有execl函数执行失败的情况下才有机会执行这两句代码，执行的成功话就有去无回了。

​		} else if (pid > 0) {

​			sleep(1);	printf("parent\n");

​		}

​		return 0;

​	}

6. int  execve(const  char  *filename, char *const argv[], char *const envp[]);

​	功能：加载指定的程序；filename必须是一个可执行程序或者一个以#! interpreter [optional-arg] 开始的脚本。

​		上面的五个exec函数是库函数，这个是系统函数；上面的五个exec函数最终都是调用这个函数实现的。 

 

总结：exec族函数的规律

​	exec函数一旦调用成功就有去无回了，去执行新的程序去了。只有失败时才有返回，返回值为-1。所以我们直接在exec函数调用后直接调用perror()和exit()，不需要if判断，因为失败的情况才会执行。

​	函数名的意义的理解： 

​		l (list) 命令行参数列表

​		p (path) 环境变量，环境变量搜素文件名称file

​		v (vector) 命令行参数数组

​		e (environment) 环境变量数组，给新加载程序设置指定的环境变量

​	函数的相似性： 

​		execlp——>execvp 

​				  |		 

​		execl  ——>execv

​				  | 

​		execle——>execve

​		从左往右，可变参数转为以NULL结尾的指针数组；从左往右， 从上往下，最后归根结底都是调用execve函数实现的。















替换当前进程映像用一个新的进程映像，

## 7.exec()代码演示



```c
#include "00.head.h"

int main() {
    pid_t pid;
    if ((pid = fork()) <  0) {
        perror("fork");
        exit(-1);
    }

    if (pid == 0) {
        printf("start\n");
        execlp("vim", "vim", "12.exec.c", NULL);//子进程，在子进程中执行vim,名字是vim,名字是12.exec.c
        sleep(10000000);//子进程中不存在
        printf("END!\n");//子进程中不存在
    } else {
        wait(NULL);
        printf("After child terminated!\n");
        sleep(4);
    }

    return 0;
}
```



```c
//12.exec.c
#include "00.head.h"

int main() {
    pid_t pid;
    if ((pid = fork()) <  0) {
        perror("fork");
        exit(-1);
    }

    if (pid == 0) {
        printf("start\n");
        execl("./a.out", "haha", "12.exec.c", NULL);
        sleep(10000000);
        printf("END!\n");
    } else {
        wait(NULL);
        printf("After child terminated!\n");
        sleep(4);
    }

    return 0;
}
//13.test_exec.c
#include <stdio.h>

int main(int argc, char **argv) {
    printf("arg0 = %s\n", argv[0]);
    return 0;
}

```



```shell
gcc 13.test_exec.c
./a.out                                   
arg0 = ./a.out
gcc 12.exec.c -o exec
 ./exec                                                        
start
arg0 = haha#习惯上将此处设置为文件名
After child terminated!
```



## 8.高级进程管理

进程调度

进程调度是一个内核子系统

进程调度的主要任务是决定哪一个“就绪”状态的进程来执行

就绪进程就是 非阻塞进程

阻塞进程就是正在睡眠的进程，需要内核唤醒的进程;



![截屏2021-01-21 下午2.43.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.43.53.png)



# 5.进程间通信上

## 5.1进程间通信

Linux 系统上运行有多个进程，其中许多都是独立运行。然而，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。 

​		读写磁盘文件中的信息是进程间通信的方法之一。可是，对许多程序来说，这种方法既 慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC） 机制，如下所示。 

-  信号（signal），用来表示事件的发生。 
-  管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。 
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。 
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以 锁定。 
- 消息队列，用于在进程间交换消息（数据包）。 
- 信号量（semaphore），用来同步进程动作。 
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容 时，其他所有进程会立即了解到这一变化。 

​		

## 5.2System V 共享内存

​		 共享内存允许两个或多个进程共享物理内存的同一块区 域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分 数据会对其他所有共享同一个段的进程可用。与管道或消息队列要求发送进程将数据从用户 空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法 相比，这种 IPC 技术的速度更快。（每个进程也存在通过系统调用来执行复制操作的开销。） 

​		 另一方面，共享内存这种 IPC 机制不由内核控制意味着通常需要通过某些同步方法使得 进程不会出现同时访问共享内存的情况（如两个进程同时执行更新操作或者一个进程在从共 享内存中获取数据的同时另一个进程正在更新这些数据）。System V 信号量天生就是用来完成 这种同步的一种方法。当然，还可以使用其他方法，如 POSIX 信号量和文件锁.



### 5.2.1共享内存的使用 

为使用一个共享内存段通常需要执行下面的步骤。 

- 调用 shmget()创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程 创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 
- 使用 shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 
- 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内 存，程序需要使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。
- 调用 shmdt()来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 
- 调用 shmctl()来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后 内存段才会被销毁。只有一个进程需要执行这一步。

### 5.2.2创建或打开一个共享内存段shmget()

shmget()系统调用创建一个新共享内存段或获取一个既有段的标识符。新创建的内存段中 的内容会被初始化为 0。

```cpp
NAME
       shmget - allocates a System V shared memory segment

SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

```



​		 当使用 shmget()创建一个新共享内存段时，size 则是一个正整数，它表示需分配的段的字 节数。内核是以系统分页大小的整数倍来分配共享内存的，因此实际上 size 会被提升到最近 的系统分页大小的整数倍。如果使用 shmget()来获取一个既有段的标识符，那么 size 对段不会 产生任何效果，但它必须要小于或等于段的大小。 

​		shmflg 参数执行的任务与其在其他 IPC get 调用中执行的任务一样，即指定施加于新共享 内存段上的权限或需检查的既有内存段的权限。此外，在 shmflg 中还可以对下列标 记中的零个或多个取 OR 来控制 shmget()的操作。 

​		IPC_CREAT 

如果不存在与指定的 key 对应的段，那么就创建一个新段。 

​		IPC_EXCL 

如果同时指定了IPC_CREAT 并且与指定的key 对应的段已经存在，那么返回EEXIST 错误。  SHM_HUGETLB（自 Linux 2.6 起） 

特权（CAP_IPC_LOCK）进程能够使用这个标记创建一个使用巨页（huge page）的共享内存 段。巨页是很多现代硬件架构提供的一项特性用来管理使用超大分页尺寸的内存。（如 x86-32 允 许使用 4MB 的分页大小来替代 4KB 的分页大小。）在那些拥有大量内存的系统上并且应用程序需 要使用大量内存块时，使用巨页可以降低硬件内存管理单元的超前转换缓冲器（translation look-aside buffer，TLB）中的条目数量。这之所以会带来益处是因为 TLB 中的条目通常是一种稀 缺资源。更多信息可参考内核源文件 Documentation/vm/ hugetlbpage.txt。 

SHM_NORESERVE（自 Linux 2.6.15 起）

 这个标记在 shmget()中所起的作用与 MAP_NORESERVE 标记在 mmap()中所起的作用一 样。 shmget()在成功时返回新或既有共享内存段的标识符。

### 5.2.3 使用共享内存shmat()

shmat()系统调用将 shmid 标识的共享内存段附加到调用进程的虚拟地址空间中。

```shell
NAME
       shmat, shmdt - System V shared memory operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);


```

```cpp

RETURN VALUE
       On success, a valid shared memory identifier is returned.  On error, -1 is returned, and errno is set to indicate the error.
```



shmaddr 参数和 shmflg 位掩码参数中 SHM_RND 位的设置控制着段是如何被附加上去的。 

- 如果 shmaddr 是 NULL，那么段会被附加到内核所选择的一个合适的地址处。这是附 加一个段的优选方法。 
- 如果 shmaddr 不为 NULL 并且没有设置 SHM_RND，那么段会被附加到由 shmaddr 指 定的地址处，它必须是系统分页大小的一个倍数（否则会发生 EINVAL 错误）。 
- 如果 shmaddr 不为 NULL 并且设置了 SHM_RND，那么段会被映射到的地址为在 shmaddr 中提供的地址被舍入到最近的常量 SHMLBA（shared memory low boundary address）的倍数。这个常量等于系统分页大小的某个倍数。将一个段附加到值为 SHMLBA 的倍数的地址处在一些架构上是有必要的，因为这样才能够提升 CPU 的快 速缓冲性能和防止出现同一个段的不同附加操作在 CPU 快速缓冲中存在不一致的视 图的情况

​	    shmat()的函数结果是返回附加共享内存段的地址。开发人员可以像对待普通的 C 指针那 样对待这个值，段与进程的虚拟内存的其他部分看起来毫无差异。通常会将 shmat()的返回值 赋给一个指向某个由程序员定义的结构的指针以便在该段上设定该结构。 

​		要附加一个共享内存段以供只读访问，那么就需要在 shmflg 中指定 SHM_RDONLY 标记。 试图更新只读段中的内容会导致段错误（SIGSEGV 信号）的发生。如果没有指定 SHM_ RDONLY，那么就既可以读取内存又可以修改内存。 

​		一个进程要附加一个共享内存段就需要在该段上具备读和写权限，除非指定了 SHM_ RDONLY 标记，那样的话就只需要具备读权限即可。

​		最后一个可以在 shmflg 中指定的值是 SHM_REMAP。在指定了这个标记之后 shmaddr 的值 必须为非 NULL。这个标记要求 shmat()调用替换起点在 shmaddr 处长度为共享内存段的长度的 任何既有共享内存段或内存映射。一般来讲，如果试图将一个共享内存段附加到一个已经在用 的地址范围时将会导致 EINVAL 错误的发生。SHM_REMAP 是一个非标准的 Linux 扩展。

![截屏2021-01-22 上午10.43.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.43.15.png)

​		

​		当一个进程不再需要访问一个共享内存段时就可以调用 shmdt()来讲该段分离出其虚拟地 址空间了。shmaddr 参数标识出了待分离的段，它应该是由之前的 shmat()调用返回的一个值。

```c
int shmdt(const void *shmaddr);
```

​		分离一个共享内存段与删除它是不同的。删除是通过 shmctl() IPC_ RMID 操作来完成的。

​		通过 fork()创建的子进程会继承其父进程附加的共享内存段。因此，共享内存为父进程和 子进程之间的通信提供了一种简单的 IPC 方法。 

​		在一个 exec()中，所有附加的共享内存段都会被分离。在进程终止之后共享内存段也会自 动被分离



### 5.2.4ipcs 和 ipcrm 命令

​		ipcs 和 ipcrm 命令是 System V IPC 领域中类似于 ls 和 rm 文件命令的命令。使用 ipcs 能够 获取系统上 IPC 对象的信息。在默认情况下，ipcs 会显示出所有对象，如下面的例子所示。

![截屏2021-01-22 上午10.52.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-22%20%E4%B8%8A%E5%8D%8810.52.09.png)

​		在 Linux 上，ipcs(1)只显示出拥有读权限的 IPC 对象的信息，而不管是否拥有这些对象。 在一些 UNIX 实现上，ipcs 的行为与它在 Linux 上的行为一样，但在其他实现上，ipcs 会显示 出所有对象，不管当前用户是否拥有这些对象上的读权限。 

​		在默认情况下，ipcs 会显示出每个对象的 key、标识符、所有者以及权限（用一个八进制 数字表示），后面跟着对象所特有的信息。 

- 对于共享内存，ipcs 会显示出共享内存区域的大小、当前将共享内存区域附加到自己 的虚拟地址空间的进程数以及状态标记。状态标记标识出了区域是否被锁进了 RAM 以防止交换以及在所有进程都与该区域分离之后是否已经将其标记为待销毁了。
- 对于信号量，ipcs 会显示出信号集的大小。 
- 对于消息队列，ipcs 会显示出队列中数据占据的字节总数以及消息数量。

 ipcs(1)手册对各种能够显示 IPC 对象的其他信息的选项进行了说明。 ipcrm 命令删除一个 IPC 对象。这个命令的常规形式为下面两种形式中的一种

```shell
ipcrm -X key
ipcrm -x id
```

​		在上面给出的命令中既可以将一个 IPC 对象的 key 指定为参数 key，也可以将一个 IPC 对象 的标识符指定为参数 id 并且使用小写的 x 替换其大写形式或使用小写的 q（用于消息队列）或 s （用于信号量）或 m（用于共享内存）。因此使用下面的命令可以删除标识符为 65538 的信号量集。

```shell
ipcrm -s 65538  #删除标识符为 65538 的信号量集
ipcrm -m 65538 #删除标识符为 65538 的共享内存
```



 

## 5.3互斥量(mutexe)和条件变量(condition variable)

​		互斥量可以帮助线程同步对共享资源的使用，以防如下情况发生：线程某甲试图访 问一共享变量时，线程某乙正在对其进行修改。条件变量则是在此之外的拾遗补缺，允许线 程相互通知共享变量（或其他共享资源）的状态发生了变化。

​		互斥量既可以像静态变量那样分配，也可以在运行时动态创建。

​		互斥量是属于 pthread_mutex_t 类型的变量。在使用之前必须对其初始化。对于静态分配 的互斥量而言，可将 PTHREAD_MUTEX_INITIALIZER 赋给互斥量。

​		初始化之后，互斥量处于未锁定状态。函数 pthread_mutex_lock()可以锁定某一互斥量，而 函数 pthread_mutex_unlock()则可以将一个互斥量解锁。

```cpp
NAME
       pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes

SYNOPSIS
       #include <pthread.h>

       pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;

       pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

       pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;

       int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);

       int pthread_mutex_lock(pthread_mutex_t *mutex);

       int pthread_mutex_trylock(pthread_mutex_t *mutex);

       int pthread_mutex_unlock(pthread_mutex_t *mutex);

       int pthread_mutex_destroy(pthread_mutex_t *mutex);
```



```cpp
RETURN VALUE
       pthread_mutex_init always returns 0. The other mutex functions return 0 on success and a non-zero error code on error.
```



​		要锁定互斥量，在调用 pthread_mutex_lock()时需要指定互斥量。如果互斥量当前处于未锁定 状态，该调用将锁定互斥量并立即返回。如果其他线程已经锁定了这一互斥量，那么 pthread_ mutex_lock()调用会一直堵塞，直至该互斥量被解锁，到那时，调用将锁定互斥量并返回。

​		如果发起 pthread_mutex_lock()调用的线程自身之前已然将目标互斥量锁定，对于互斥量 的默认类型而言，可能会产生两种后果—视具体实现而定：线程陷入死锁（deadlock），因 试图锁定已为自己所持有的互斥量而遭到阻塞；或者调用失败，返回 EDEADLK 错误。在 Linux 上，默认情况下线程会发生死锁。

​		函数 pthread_mutex_unlock()将解锁之前已遭调用线程锁定的互斥量。以下行为均属错误： 对处于未锁定状态的互斥量进行解锁，或者解锁由其他线程锁定的互斥量。



```c
 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
```



​		参数 mutex 指定函数执行初始化操作的目标互斥量。参数 attr 是指向pthread_mutexattr_t 类 型对象的指针，该对象在函数调用之前已经过了初始化处理，用于定义互斥量的属性。若将 attr 参数置为 NULL，则该互斥量的各种属性会取默认值。 

​		SUSv3 规定，初始化一个已初始化的互斥量将导致未定义的行为，应当避免这一行为。 

​		在如下情况下，必须使用函数 pthread_mutex_init()，而非静态初始化互斥量。 

- 动态分配于堆中的互斥量。例如，动态创建针对某一结构的链表，表中每个结构都包 含一个 pthread_mutex_t 类型的字段来存放互斥量，借以保护对该结构的访问。 

- 互斥量是在栈中分配的自动变量。 

- 初始化经由静态分配，且不使用默认属性的互斥量。

  当不再需要经由自动或动态分配的互斥量时，应使用 pthread_mutex_destroy()将其销毁。

​	  只有当互斥量处于未锁定状态，且后续也无任何线程企图锁定它时，将其销毁才是安全 的。若互斥量驻留于动态分配的一片内存区域中，应在释放（free）此内存区域前将其销毁。 对于自动分配的互斥量，也应在宿主函数返回前将其销毁。 

​		经由 pthread_mutex_destroy()销毁的互斥量，可调用 pthread_mutex_init()对其重新初始化。

 



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <pthread.h>
#define INS 5

struct Num {
    int now;
    int sum;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};
struct Num *share_memory;
void do_add(int x) {
    while (1) {
        pthread_mutex_lock(&share_memory->mutex);
        pthread_cond_wait(&share_memory->cond, &share_memory->mutex);
        int flag = 0;
        for (int i = 0; i < 100; i++) {
            if (share_memory->now > 1000) {
                pthread_mutex_unlock(&share_memory->mutex);
                pthread_cond_signal(&share_memory->cond);
                exit(0);
            }
            share_memory->sum += share_memory->now;
            share_memory->now++;
            printf("<%d> now = %d, sum = %d\n", x, share_memory->now, share_memory->sum);
            fflush(stdout);
            //pthread_mutex_unlock(&share_memory->mutex);
        }
        pthread_mutex_unlock(&share_memory->mutex);
        pthread_cond_signal(&share_memory->cond);
    }
    exit(0);
}

int main() {
    pid_t pid;
    int x = 0, shmid;
    key_t key = ftok(".", 2021);
    if ((shmid = shmget(key, sizeof(struct Num), IPC_CREAT | IPC_EXCL | 0666)) < 0) {
        perror("sshmget");
        exit(-1);
    }
    share_memory = (struct Num*)shmat(shmid, NULL, 0);
    if (share_memory == (struct Num*)-1) {
        perror("share_memory");
        exit(-1);
    }
    share_memory->now = 0;
    share_memory->sum = 0;


    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&share_memory->mutex, &attr);

    pthread_condattr_t condattr;
    pthread_condattr_init(&condattr);
    pthread_condattr_setpshared(&condattr, 1);
    pthread_cond_init(&share_memory->cond, &condattr);


    //printf("before fork()\n");
    for (int i = 1; i <= INS; i++) {
        if ((pid = fork()) < 0) {
            perror("fork");
        }
        x = i;
        if (pid == 0) break;
    }

    if (pid == 0) {
        do_add(x);
    } else {
        sleep(1);
        pthread_cond_signal(&share_memory->cond);
        for (int i = 1; i <= INS; i++) {
            wait(NULL);
        }
    }
    printf("end ==> share_memory->sum = %d \n", share_memory->sum);
    shmdt(share_memory);
    shmctl(shmid, IPC_RMID,NULL);

    return 0;
}
```



## 5.4进程调度



![截屏2021-01-21 下午2.47.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.47.16.png)



![截屏2021-01-21 下午2.49.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.49.36.png)

![截屏2021-01-21 下午2.52.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%882.52.55.png)

![截屏2021-01-21 下午3.02.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.02.41.png)

![截屏2021-01-21 下午3.06.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.06.29.png)

![截屏2021-01-21 下午3.08.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.08.34.png)

![截屏2021-01-21 下午3.09.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-21%20%E4%B8%8B%E5%8D%883.09.54.png)











# 6.进程间通信下

## 互斥锁

shmctl



ftok



## 简易聊天系统



`18.ipc.chat.server.c`

```c
#include "00.head.h"
#include "17.ipc.chat.h"

struct Msg *shar_memory = NULL;
//服务端
int main() {
    int shmid;
    key_t key = ftok(".", 202101);
    if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }

    if ((shar_memory = (struct Msg *)shmat(shmid, NULL, 0)) == (struct Msg *)-1) {
        perror("shmat");
        exit(-1);
    }
    //初始化
    memset(shar_memory, 0, sizeof(struct Msg));
    pthread_mutexattr_t m_attr;
    pthread_mutexattr_init(&m_attr);
    pthread_mutexattr_setpshared(&m_attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&shar_memory->mutex, &m_attr);
  	//初始化一个互斥锁     //互斥锁标识         //互斥锁属性  

    pthread_condattr_t c_attr;
    pthread_condattr_init(&c_attr);
    pthread_condattr_setpshared(&c_attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&shar_memory->cond, &c_attr);
    //初始化条件变量  

    while (1) {
       // 对互斥锁上锁，若互斥锁已经上锁，则调用者一直阻塞，// 直到互斥锁解锁后再上锁。  
        pthread_mutex_lock(&shar_memory->mutex);
        printf("Server got the Mutex!\n");
        //阻塞等待  
        pthread_cond_wait(&shar_memory->cond, &shar_memory->mutex);
        printf("Server got the cond signal!\n");
        printf("<%s> : %s.\n", shar_memory->name, shar_memory->msg);
        memset(shar_memory->msg, 0, sizeof(shar_memory->msg));
        pthread_mutex_unlock(&shar_memory->mutex);// 对指定的互斥锁解锁。  

    }

    return 0;
}
```



`19.ipc.chat.client.c`

```c
#include "00.head.h"
#include "17.ipc.chat.h"

struct Msg *shar_memory = NULL;

int main(int argc, char **argv) {

    int opt, shmid;//.,共享内存id
    char name[20] = {0};
    while ((opt = getopt(argc, argv, "n:")) != -1) {
        switch (opt) {
        case 'n':
            strcpy(name, optarg);
            break;
        default:
            fprintf(stderr, "Usage : %s -n name\n", argv[0]);
            exit(1);
        }
    }

    key_t key = ftok(".", 202101);
      //创建共享内存  
    if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }
    // 进程将共享内存连接到自身的地址空间
    if ((shar_memory = (struct Msg *)shmat(shmid, NULL, 0)) == (struct Msg *)-1) {
        perror("shmat");
        exit(1);
    }

    while (1) {
        char msg[1024] = {0};
        scanf("%[^\n]s", msg);
        getchar();//吃掉缓冲区的回车键
        if (!strlen(msg)) continue;//字符串为空
        while (1) {
            if (!strlen(shar_memory->msg)) {//当写入数据前，加锁  
                pthread_mutex_lock(&shar_memory->mutex);
            }
        }
        //pthread_mutex_lock(&shar_memory->mutex);
        printf("Sending : %s...\n", msg);
        strcpy(shar_memory->msg, msg);//向共享内存中写入数据  
        strcpy(shar_memory->name, name);
        pthread_cond_signal(&shar_memory->cond);//至少唤醒一个等待该条件的线程  
        pthread_mutex_unlock(&shar_memory->mutex);//  //写入数据后，解锁  
        printf("Client signaled the cond\n");
    }



    return 0;
}

```

`17.ipc.chat.h`

```c
struct Msg{
    char name[20];
    char msg[1024];
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};
```



`00.head.h`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <pthread.h>
```





## 线程

线程是进程的一个分支

pthread process thread

一个进程可以有多个线程，本质上是一种轻量级进程

共享内存，通信简单，调度成本低，

进程与进程之间调度成本高：

有时间局部性，运行一段时间，就将进程调度出去，换一个新的程序，缓冲也会被干掉

线程本质上的共享内存，一个进程的多个线程在调度的时候，不需要做切换，直接用就可以，原先线程建立起的缓冲信息可以直接用

pthread_create



argument参数

pthread_exit(3)线程自杀

线程创建

```c
#include "00.head.h"

struct MyArg {
    char name[20];
    int age;
};

void *print(void *arg) {
    struct MyArg copyMyarg;
    copyMyarg = *(struct MyArg *)arg;//防止在执行过程中会被其他线程改变，所以先拷贝下来
    struct MyArg *in;
    in = (struct MyArg *)arg;

    printf("In Thread\n");
    printf("%s is %d years old!\n", in->name, in->age);
    printf("%s is %d years old!\n", copyMyarg.name, copyMyarg.age);
}

int main() {
    pthread_t thread;
    char name[20];
    int age = 18;
    struct MyArg arg;
    strcpy(arg.name, "古子秋");
    arg.age = age;
    pthread_create(&thread, NULL, print, &arg);
    usleep(1);
    return 0;
}
```



## 线程池

线程是为了解决一个确定性的工作

用理发店举例

刚开始创业开理发店

只有我一个人会理发，如果来了一个人，就可以直接理发，如果来了多个人，除了第一个其他人就只能处于等待状态，就相当于早期的单线程或者单进程处理

现在我学会了一种神奇的技术，叫克隆(fork())，如果我正在理发，又有新客户新来了，那么我克隆一个自己，让他去服务，这就是多进程

但是我发现，克隆自己的代价太大了，系统只能同意我们打开1024个进程，而且拷贝进程会占内存，国家又禁止克隆技术

现在突然发现旁边的理发学院有的学生想做兼职，如果来了很多客人，我就在微信群里面喊多少人过来做兼职，做完了就让他们走。(多线程)

 但是创建进程或者线程比较麻烦，客人需要等待，又要创建又要销毁，

现在我发现店里面人很多。基本上天天都有人，然后我就在人才市场找了几个固定员工，签了合同，如果有人来就去照顾客人，没有人就在店里等待客人到来。（线程池）

所有的客人都处于等待理发的状态，一个员工理发之后继续处于等待状态，为了激励员工，如果多理发的员工会得到更多的薪资(饥渴的线程)，但是为了避免线程同事竞争同一个客户，我们将所有的客户放在一个房子里面(资源加锁)，客户一个一个出来，只有一个员工可以帮客人理发。

![截屏2021-01-26 下午5.22.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.22.46.png)



![截屏2021-01-26 下午5.29.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-26%20%E4%B8%8B%E5%8D%885.29.35.png)





23.thread_pool.c

```c
#include "00.head.h"
#include "24.thread_pool.h"

void task_queue_init(struct task_queue *taskQueue, int size) {//初始化队列
    taskQueue->size = size;
    taskQueue->total = 0;
    taskQueue->head = taskQueue->tail = 0;
    pthread_mutex_init(&taskQueue->mutex, NULL);
    pthread_cond_init(&taskQueue->cond, NULL);
    taskQueue->data = calloc(size, sizeof(void *));
}

void task_queue_push(struct task_queue *taskQueue, char *str) {
    pthread_mutex_lock(&taskQueue->mutex);
    if (taskQueue->total == taskQueue->size) {
        pthread_mutex_unlock(&taskQueue->mutex);
        printf("task queue is full!\n");
        return ;
    }
    printf("<push>:%s\n", str);
    taskQueue->data[taskQueue->tail] = str;
    taskQueue->total++;
    if (++taskQueue->tail == taskQueue->size) {
        printf("task queue reach end!\n");
        taskQueue->tail = 0;
    }
    pthread_cond_signal(&taskQueue->cond);
    pthread_mutex_unlock(&taskQueue->mutex);
}

char *task_queue_pop(struct task_queue *taskQueue) {
    pthread_mutex_lock(&taskQueue->mutex);
    while (taskQueue->total == 0) {
        printf("task queue is empty!\n");
        pthread_cond_wait(&taskQueue->cond, &taskQueue->mutex);
    }
    char *str = taskQueue->data[taskQueue->head];
    printf("<pop>:%s\n", str);
    taskQueue->total--;
    if (++taskQueue->head == taskQueue->size) {
        printf("task queue reach end!\n");
        taskQueue->head = 0;
    }
    pthread_mutex_unlock(&taskQueue->mutex);
    return str;
}

//循环打印

```

24.thread_pool.h

```c

struct task_queue{
    //循环队列
    int size;
    int total;
    int head;
    int tail;
    char **data;
    pthread_mutex_t mutex;//加锁
    pthread_cond_t cond;//检测是否又客人
};

void task_queue_init(struct task_queue *taskQueue, int size);//建立等待区，等待区又size大小
void task_queue_push(struct task_queue *taskQueue, char *str);//str入队列
char *task_queue_pop(struct task_queue *taskQueue);//str入队列


```





```c
#include "00.head.h"
#include "24.thread_pool.h"

#define THREAD 5
#define QUEUE 50

void *do_work(void *arg) {
    pthread_detach(pthread_self());//线程分离
    struct task_queue *taskQueue = (struct task_queue *)arg;
    while (1) {
        char *str = task_queue_pop(taskQueue);
        printf("<%d> : %s !\n", pthread_self, str);//线程拿到自己的id
    }

}

int main() {
    pthread_t tid[THREAD];
    struct task_queue taskQueue;
    task_queue_init(&taskQueue, QUEUE);
    char buff[QUEUE][1024] = {0};

    for (int i = 0; i < THREAD; i++) {
        pthread_create(&tid[i], NULL, do_work, (void *) &taskQueue);
    }
    int sub = 0;
    while (1) {
        FILE *fp = fopen("./25.thread_pool_text.c", "r");
        if (fp == NULL) {
            perror("fopen");
            exit(0);
        }
        while (fgets(buff[sub++], 1024, fp) != NULL) {
            task_queue_push(&taskQueue, buff[sub]);
            if (sub == QUEUE) {
                //满了
                sub = 0;
            }
            if (taskQueue.total == taskQueue.size) {
                //
                while (1) {
                    if (taskQueue.total< taskQueue.size) {
                        break;
                    }
                    usleep(10000);
                }
            }
        }
        fclose(fp);
    }

    return 0;
}

```





```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <pthread.h>

```





# 7.多线程编程基础

pthread_create产生线程

谁生的线程

线程模型

内核线程在内核上产生的

用户线程在用户空间上产生的



pthread_t线程ID

判断线程是否相等？

不能用线程ID判断，用pthread_equal

pthread_exit()线程自杀

pthread_cancel线程自杀

exit()

pthread_join()等待另一个线程结束，

成功0，

pthread_detach
标记一个分离的线程，线程结束后，所有的有关线程的内容都会被释放

同时分离同一个线程为被定义

attr线程属性

pthread_yield()

让出处理器，





# 8.socket编程

![截屏2021-01-30 下午5.39.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-30%20%E4%B8%8B%E5%8D%885.39.09.png)

![截屏2021-01-29 下午3.54.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%883.54.54.png)

![截屏2021-01-29 下午4.06.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.06.49.png)



连接的本质是双方都保存一些变量，用来描述双方之间的状态





端口是一种计算机设备，就像一个大楼(计算机)里面的一个房间，一个大楼都会有一个独立的地址，可能会与多个地址，如果有多个地址，端口就是具体的房间后

![截屏2021-01-29 下午4.22.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.22.00.png)

序列号：第几回发送

确认应答号：确认收到1可以发送2了

字：32位，4字节=1字

字节

RST=reset重置连接

SYN=1,对方收到包，建立请求连接，如果正确恢复SYN

SYN+ACK二次握手

ACK三次握手

FIN结束包

检验和：检验包是否有问题，



![image-20210129163616346](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/image-20210129163616346.png)





![截屏2021-01-29 下午4.40.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.40.49.png)



TCP的本质是字节流

listen切换套接字主动为被动

![截屏2021-01-29 下午4.46.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.46.27.png)

![截屏2021-01-29 下午4.54.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%884.54.09.png)

![截屏2021-01-29 下午5.02.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.02.56.png)



![截屏2021-01-29 下午5.04.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.04.51.png)



![截屏2021-01-29 下午5.14.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.14.09.png)



![截屏2021-01-29 下午5.20.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.20.19.png)



![截屏2021-01-29 下午5.22.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.22.03.png)



![截屏2021-01-29 下午5.24.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.24.01.png)

![截屏2021-01-29 下午5.25.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.23.png)



![截屏2021-01-29 下午5.25.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.25.44.png)



![截屏2021-01-29 下午5.26.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-29%20%E4%B8%8B%E5%8D%885.26.03.png)







26.tcp.server.c

```c
#include "00.head.h"


int socket_create(int port) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {//创建套接字
        return -1;
    }
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;//IPV4
    addr.sin_port = htons(port);//主机字节序转换成本地字节序
    addr.sin_addr.s_addr = inet_addr("0.0.0.0");
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        return -1;
    }

    if (listen(sockfd, 20) < 0) {
        return -1;
    }
    return sockfd;
}
```



27.tcp.server.h

```c

//定义函数接口
int socket_create(int port);//创建套接字，参数端口
```



28.tcp.client.h

```c
int socket_connect(char *ip, int port);
```



29.tcp.client.c

```c
#include "00.head.h"

int socket_connect(char *ip, int port) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        return -1;
    }
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr(ip);

    if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        return -1;
    }
    return sockfd;
}
```



30.tcp.main.server.c

```c
#include "00.head.h"

int main(int argc, char **argv) {
    int server_listen, sockfd, port;
    if (argc != 2) {
        fprintf(stderr, "Usage:%s port!\n", argv[0]);
        exit(1);
    }
    port = atoi(argv[1]);
    if ((server_listen = socket_create(port)) < 0) {
        perror("socket_create");
        exit(-1);
    }
    while (1) {
        if ((sockfd = accept(server_listen, NULL, NULL)) < 0) {
            perror("accept");
            exit(1);
        }
        printf("Something is online\n");
        pid_t pid;
        if ((pid = fork()) < 0) {
            exit(-1);
        }
        if (pid == 0) {//支持并发
            while (1) {
                char buff[512] = {0};
                recv(sockfd, buff, sizeof(buff), 0);
                printf("recv : %s\n", buff);
            }
        }
    }


    return 0;
}

```



32.tcp.main.client.c

```c
#include "00.head.h"


int main(int argc, char **argv) {
    int sockfd, port;
    char buff[512] = {0}, ip[20] = {0};
    if (argc != 3) {
        fprintf(stderr, "Usage:%s is port!\n", argv[0]);
    }
    strcpy(ip, argv[1]);
    port = atoi(argv[2]);
    if ((sockfd = socket_connect(ip, port)) < 0) {
        perror("socket_connect");
        exit(1);
    }
    printf("before loop!\n");
    while (1) {
        scanf("%[^\n]s", buff);
        getchar();
        if (!strlen(buff)) continue;
        send(sockfd, buff, strlen(buff), 0);
        bzero(buff, sizeof(buff));
    }


    return 0;
}
```





```shell
gcc 30.tcp.main.server.c 26.tcp.server.c -o 31.tcp.server
gcc 32.tcp.main.client.c 29.tcp.client.c -o 33.tcp.client

./31.tcp.server 9000                      [130]
Something is online
recv : hello
^C

./33.tcp.client 8.129.127.2 9000
before loop!
hello
^C
```





# 输入一个网址发生了什么？



端口复用：

from IP

from port

to ip

to port



singnal

```c
//26.tcp.server.c
#include "00.head.h"


int socket_create(int port) {//创建套接字
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {//创建套接字,ipv4，socker流
        return -1;//有太多的文件
    }
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;//协议组 IPV4
    addr.sin_port = htons(port);//端口，主机字节序转换成本地字节序
    addr.sin_addr.s_addr = inet_addr("0.0.0.0");//
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {//绑定
        return -1;//端口被占用
    }

    if (listen(sockfd, 20) < 0) {//
        return -1;
    }
    return sockfd;
}

//27.tcp.server.h
//定义函数接口
int socket_create(int port);//创建套接字，参数端口

//30.tcp.main.server.c
#include "00.head.h"

int main(int argc, char **argv) {
    int server_listen, sockfd, port;
    if (argc != 2) {
        fprintf(stderr, "Usage:%s port!\n", argv[0]);
        exit(1);
    }
    port = atoi(argv[1]);
    if ((server_listen = socket_create(port)) < 0) {//创建套接字
        perror("socket_create");
        exit(-1);
    }
    struct sockaddr_in client;
    socklen_t len = sizeof(client);
    while (1) {//用于等待接收数据
        if ((sockfd = accept(server_listen, (struct sockaddr *)&client, &len)) < 0) {//接受连接
            perror("accept");//三次握手失败
            exit(1);
        }
        printf("<%s> is online\n", inet_ntoa(client.sin_addr));
        pid_t pid;
        if ((pid = fork()) < 0) {
            exit(-1);
        }
        if (pid == 0) {
            close(server_listen);
            while (1) {//
                char buff[512] = {0};
                char tobuff[1024] = {0};
                size_t ret = recv(sockfd, buff, sizeof(buff), 0);
                if (ret <= 0) {
                    printf("<%s> is offline\n", inet_ntoa(client.sin_addr));
                    perror("recv");
                    close(sockfd);
                    exit(1);
                }
                printf("recv <%s>: %s\n", inet_ntoa(client.sin_addr), buff);
                sprintf(tobuff, "I've recvd your message : %s!\n", buff);
                send(sockfd, tobuff, strlen(tobuff), 0);//发送给客户端
            }
        } else {
            printf("<Parent> : 什么也不gan。。。\n");
            close(sockfd);//
        }
    }


    return 0;
}

gcc 30.tcp.main.server.c 26.tcp.server.c -o 31.tcp.server
```





```c
//28.tcp.client.h
int socket_connect(char *ip, int port);

//29.tcp.client.c
#include "00.head.h"

int socket_connect(char *ip, int port) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        return -1;
    }
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr(ip);

    if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        return -1;
    }
    return sockfd;
}

//32.tcp.main.client.c
#include "00.head.h"

int sockfd;
void logout(int signum) {
    close(sockfd);
    printf("ByeBye\n");
    exit(0);
}

int main(int argc, char **argv) {
    int port;
    char buff[512] = {0}, ip[20] = {0};
    if (argc != 3) {
        fprintf(stderr, "Usage:%s is port!\n", argv[0]);
    }
    strcpy(ip, argv[1]);
    port = atoi(argv[2]);
    signal(SIGINT, logout);
    if ((sockfd = socket_connect(ip, port)) < 0) {
        perror("socket_connect");
        exit(1);
    }
    printf("before loop!\n");
    while (1) {
        printf("<please> : ");
        scanf("%[^\n]s", buff);
        getchar();
        if (!strlen(buff)) continue;
        send(sockfd, buff, strlen(buff), 0);
        printf("sending %s ...\n", buff);
        bzero(buff, sizeof(buff));
        //sleep(1);
        recv(sockfd, buff, sizeof(buff), 0);
        printf("<server> : %s\n", buff);
        bzero(buff, sizeof(buff));
    }


    return 0;
}

gcc 32.tcp.main.client.c 29.tcp.client.c -o 33.tcp.client
```



```shell
./31.tcp.server 9000
<110.176.185.233> is online
<Parent> : 什么也不gan。。。
recv <110.176.185.233>: hello
recv <110.176.185.233>: hello 古子秋!
<110.176.185.233> is offline
recv: Success

./33.tcp.client 8.129.127.2 9000
before loop!
<please> : hello
sending hello ...
<server> : I've recvd your message : hello!

<please> : hello 古子秋!
sending hello 古子秋! ...
<server> : I've recvd your message : hello 古子秋!!

<please> : ^CByeBye
```





# 二、计算机网络

# 9.计算机网络概论  

![截屏2021-02-03 下午9.51.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%889.51.43.png)

![截屏2021-02-03 下午9.52.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%889.52.32.png)



![截屏2021-02-03 下午10.07.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.07.17.png)

封装：

![截屏2021-02-03 下午10.12.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.12.37.png)

![截屏2021-02-03 下午10.06.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.06.55.png)

![截屏2021-02-03 下午10.15.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.15.28.png)

![截屏2021-02-03 下午10.20.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.20.09.png)







语义：某个句子是什么意思

语法：

同步：事件发生的顺序有迹可循，eg.三次挥手，具体都做什么





## 分组交换

分组

分包(packet)有路由协议决定





![截屏2021-02-03 下午10.31.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.31.51.png)







![截屏2021-02-03 下午10.42.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.42.08.png)

转发表：进来的数据计算要去的地方



## 电路交换

![截屏2021-02-03 下午10.44.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.44.20.png)

接线员







![截屏2021-02-03 下午10.46.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.46.27.png)



FDM







![截屏2021-02-03 下午10.46.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.46.49.png)





## 分组交换与电路交换的对比

分组：提供更好的带宽共享，成本低，



## 时延掉包吞吐率

![截屏2021-02-03 下午10.49.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.49.59.png)

结点处理时延：处理包的时间

排队时延：进入端口，等待处理的时间

传输时延：一个包发到网络上的时间

传播时延：信号经由主机出去，到达对方主机后，再回来经历的传输介质中传输的时间





![截屏2021-02-03 下午10.56.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.56.00.png)

什么情况下丢包越来越严重

a分组到达队列的平均速率，所有分组都由Lbit构成，R为传输速率，La/R--->1

单位时间内到达的比特率





吞吐量





![截屏2021-02-03 下午10.58.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%8810.58.51.png)

取决于业务链路上传输速率最小的那个





# 10.应用层



应用层协议

![截屏2021-02-04 上午9.12.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.12.46.png)



P2P端到端：百度网盘

CS:王者荣耀、QQ.

![截屏2021-02-04 上午9.13.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.13.50.png)

![截屏2021-02-04 上午9.15.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.15.18.png)





![截屏2021-02-04 上午9.17.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.17.29.png)

![截屏2021-02-04 上午9.29.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.29.03.png)





![截屏2021-02-04 上午9.29.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.29.56.png)

![截屏2021-02-04 上午9.30.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.30.31.png)



![截屏2021-02-04 上午9.30.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.30.49.png)

可靠：一定送到

吞吐量：大小

定时：

安全性：



![截屏2021-02-04 上午9.34.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.34.15.png)





![截屏2021-02-04 上午9.36.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.36.12.png)





![截屏2021-02-04 上午9.36.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.36.04.png)



![截屏2021-02-04 上午9.36.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.36.23.png)



![截屏2021-02-04 上午9.37.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.37.25.png)





## HTTP与WEB协议



![截屏2021-02-04 上午9.51.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.51.51.png)

![截屏2021-02-04 上午9.52.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.52.27.png)

URL统一资源定位符

web浏览器：解析资源

web服务器：tomcat等



![截屏2021-02-04 上午9.54.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.54.21.png)





![截屏2021-02-04 上午9.54.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.54.56.png)



![截屏2021-02-04 上午9.56.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.56.47.png)

![截屏2021-02-04 上午9.58.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%889.58.45.png)



**为什么是三次握手？不是两次？不是四次？**



![截屏2021-02-04 上午10.00.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.00.33.png)

![截屏2021-02-04 上午10.02.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.02.52.png)





![截屏2021-02-04 上午10.03.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.03.04.png)



![截屏2021-02-04 上午10.03.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.03.50.png)

![截屏2021-02-04 上午10.06.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.06.07.png)

![截屏2021-02-04 上午10.07.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.07.56.png)



![截屏2021-02-04 上午10.15.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.15.34.png)

![截屏2021-02-04 上午10.28.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-04%20%E4%B8%8A%E5%8D%8810.28.39.png)



## HTTP协议和HTTPS协议

![截屏2021-02-05 下午1.37.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.37.44.png)

![截屏2021-02-05 下午1.38.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.38.09.png)

![截屏2021-02-05 下午1.41.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.41.05.png)

![截屏2021-02-05 下午1.43.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.43.47.png)



## FTP协议

在局域网传输

![截屏2021-02-05 下午1.45.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.45.36.png)



![截屏2021-02-05 下午1.47.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.47.03.png)



控制连接：传命令，指令，常连接

数据连接：传数据，短连接

为什么用两条：双连接使业务实现更加简单，eg:专线，指令确定什么时候结束，指令信息引发的数据传输不一定什么时候传输，需要预先判断，不确定下一步是命令还是数据，需要很步骤，如果有两个，不需要关注数据多大，不论文件多大，收到关闭结束就可以，性能得到提升，

![截屏2021-02-05 下午1.59.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%881.59.27.png)





## SMTP、POP3、IMAP协议

![截屏2021-02-05 下午2.02.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%882.02.37.png)

使用TCP传输



## DNS协议

![截屏2021-02-05 下午2.17.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%882.17.10.png)

![截屏2021-02-05 下午2.27.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%882.27.31.png)

![截屏2021-02-05 下午2.35.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%882.35.24.png)

![截屏2021-02-05 下午2.36.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%882.36.43.png)



主机发送请求(1.guziqiu.com)，先到本地DNS查找(没有)，然后到根DNS查找(2.是顶级域名)，回应去顶级域名查找(3.告知去com域名地址)，顶级域名回应(4/5.告知到权威DNS查找)，权威DNS阿里云维护(6/7告知IP地址)，本地DNS存一份，为了下一次访问，(域名过期时间10min)

本地递归，远程迭代

![截屏2021-02-05 下午3.11.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%883.11.25.png)

TTL域名有效时间：aliyun10min











# 11.可靠传输协议的实现

## 运输层协议

![截屏2021-02-05 下午4.00.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.00.29.png)

![截屏2021-02-05 下午4.04.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.04.28.png)



![截屏2021-02-05 下午4.15.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.15.14.png)

![截屏2021-02-05 下午4.15.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.15.47.png)

![截屏2021-02-05 下午4.17.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.17.14.png)



## 为什么会选择无连接运输

![截屏2021-02-05 下午4.19.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.19.17.png)

UDP由自己控制，TCP有控制机制



## UDP

![截屏2021-02-05 下午4.29.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.29.21.png)

![截屏2021-02-05 下午4.30.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.30.26.png)

![截屏2021-02-05 下午4.33.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.33.06.png)



## RDT可靠传输协议

信道可靠，上端不用考虑是否可靠，数据一定可靠

可靠的数据协议通过不可靠的信道

![截屏2021-02-05 下午4.36.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.36.31.png)

![截屏2021-02-05 下午4.37.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.37.10.png)



具有比特差错信道：能感知到比特级的错误

![截屏2021-02-05 下午4.39.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.39.20.png)

![截屏2021-02-05 下午4.43.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.43.41.png)

![截屏2021-02-05 下午4.44.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.44.56.png)

![截屏2021-02-05 下午4.46.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.46.51.png)

![](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.46.51.png)

![截屏2021-02-05 下午4.50.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%884.50.43.png)





























# 12.TCP协议

## 12.1 报文

通过套接字使用底层提供给我们的服务

![截屏2021-02-05 下午5.17.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%885.17.37.png)

![截屏2021-02-05 下午5.18.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8B%E5%8D%885.18.30.png)



序号：字节流序号(非连续)

确认号：希望得到的下一个正确得到的序号 



首部长度4bit

接收窗口的大小：

URG：紧急数据，

PSH:立即上交，收到数据立马上交应用层

ACK:确认码=1，对方发过来的确认

RST:连接远程服务器，拒绝连接，对方没有打开端口

SYN:同步，三次握手

FIN：四次挥手





![截屏2021-02-06 下午4.22.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%884.22.41.png)

用户键入x产生数据报，发送到服务器,





![截屏2021-02-06 下午4.26.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%884.26.07.png)



![截屏2021-02-06 下午4.59.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%884.59.42.png)

主要针对双方



## 12.2 三次握手

![截屏2021-02-06 下午5.05.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.05.55.png)

为什么是三次握手：

因为双方都能确定能发送能接收，如果是两次，客户端能发能收，服务端无法确定发送的消息能否被收到，四次也可以，但是多余



## 12.3 四次挥手

![截屏2021-02-06 下午5.10.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.10.57.png)



为什么要四次：

客户端发了FIN，服务端没有返回ACK，服务端发送FIN，客户端没有回复ACK,半关闭连接，连接还在，生成一种特殊状态的套接字，有害的，占用套接字

为什么发起方多等待30s~2min,两个最大生命周期：

1.避免ACK丢失，服务器会发送ACK,（有可能发送给对方的ACK丢失）

2.避免刚断开连接，（四次挥手完成）随机新端口(和之前的一样，端口重用)跑起来之后，收到之前已经断开的端口发送的FIN包或者数据，新端口数据还没有发送完成就断开，所以需要四次挥手



## 12.4 TCP状态转换图

![截屏2021-02-06 下午5.23.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.23.48.png)

![截屏2021-02-06 下午5.29.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.29.26.png)



## 12.5 拥塞控制方法

![截屏2021-02-06 下午5.32.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.32.58.png)





![截屏2021-02-06 下午5.34.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.34.18.png)

资源管理信元：每32个信元有一个资源管理信元，返回拥塞状态





![截屏2021-02-06 下午5.40.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.40.49.png)



![截屏2021-02-06 下午5.42.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.42.32.png)





## 12.6 拥塞控制:慢启动

![截屏2021-02-06 下午5.45.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.45.03.png)

MMS最大报文段长度，TCP一次放的最大数据量

RTT往返时间

![截屏2021-02-06 下午5.48.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.48.47.png)



发送超时为什么会变成1MSS,合理吗，为什么

不合理，

为什么3个冗余ACK快速重传:包出问题





![截屏2021-02-06 下午5.49.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.49.58.png)



TCP拥塞控制流程转换

![截屏2021-02-06 下午5.52.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%885.52.11.png)

慢启动：收到冗余ACK，







 

# 13.IP地址



## 13.1 IP地址的基本结构

![截屏2021-02-24 下午5.53.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%885.53.10.png)



## 13.2 MAC地址

![截屏2021-02-24 下午8.34.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%888.34.52.png)



网卡：网络适配器

## 13.3 IP地址的分类

![截屏2021-02-24 下午8.40.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%888.40.58.png)



本地通讯靠吼，子网掩码来区分是否在一个子网中

广播：



## 13.4 ARP协议

![截屏2021-02-24 下午8.55.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%888.55.17.png)



ARP:将IP地址转换为MAC地址



# 14 网络层



## 14.1 转发和路由选择

![截屏2021-02-24 下午9.03.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.03.04.png)



![截屏2021-02-24 下午9.06.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.06.14.png)





## 14.2 路由选择算法



![截屏2021-02-24 下午9.08.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.08.24.png)



路由选择算法决定整个网络范围内的端到端的路径选择



转发表决定本地路由器内部转发的出口



## 14.3 分组网络

![截屏2021-02-24 下午9.15.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.15.21.png)



虚拟电路网络

![截屏2021-02-24 下午9.20.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.20.18.png)



![截屏2021-02-24 下午9.20.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.20.55.png)



![截屏2021-02-24 下午9.26.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.26.29.png)



## 14.4 路由器

![截屏2021-02-24 下午9.29.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.29.32.png)



交换结构：将出入端口输出到输出端口

路由选择处理器：只负责和 其他的路由器或者上层的管理软件 交互



![截屏2021-02-24 下午9.34.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.34.09.png)

线路端接：将传入到端口的信号转换成电信号



![截屏2021-02-24 下午9.39.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.39.13.png)

内存式：效率最低

总线：电信号可能抵消

纵横式：



![截屏2021-02-24 下午9.43.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.43.46.png)



排队：可能会发生数据丢失，丢包

排队时延不可控



## 14.5 网络层内容图

![截屏2021-02-24 下午9.46.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.46.02.png)





## 14.6 IP数据报

![截屏2021-02-24 下午9.49.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.49.14.png)



寿命TTL:经过一个路由器TTL-1,避免路由器找不到目的地，经过一个路由器TTL-1,最终消亡在网络中



## 14.7 DHCP

![截屏2021-02-24 下午9.52.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%889.52.13.png)



连上wifi时发生了什么事情？

接入wifi后，就可以和网络中的其他设备通信，MAC地址不变，通过MAC地址申请一个可以用的IP地址，接入网络后，通过广播dest请求地址,DHCP server收到请求后发送DHCP offer，可以有多个DHCP offer(多个DHCP服务器同时发送)，接收offer,发送请求IP地址，DHCP server确定，所有的报文都是广播，所有本地的设备都会知道他的IP地址





## 14.8 网络地址转换NAT



![截屏2021-02-24 下午10.04.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-24%20%E4%B8%8B%E5%8D%8810.04.00.png)







# 15.ICMP协议

![截屏2021-02-26 下午4.54.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-26%20%E4%B8%8B%E5%8D%884.54.49.png)

ping



![截屏2021-02-26 下午4.55.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-26%20%E4%B8%8B%E5%8D%884.55.13.png)

网络层ICMP尝试连接目的主机，但是无法到达



![截屏2021-02-26 下午4.56.46 1](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-26%20%E4%B8%8B%E5%8D%884.56.46%201.png)



u - v  1跳



D路由器的路由表

![截屏2021-02-27 下午4.39.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%884.39.35.png)

D->W 下一跳是A,需要两跳

![截屏2021-02-27 下午4.46.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%884.46.53.png)

需要一定的时间才可以收到改变，出现更新不及时的现象，网络波动







开放最短优先

![截屏2021-02-27 下午4.48.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%884.48.15.png)

范围的同时都可以收到





![截屏2021-02-27 下午4.51.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%884.51.52.png)

边界网关协议BGP：在自治系统和自治系统之间建立一条扩展的会话，它是一跳真实的TCP连接，这个连接会一直同步两段路由器的信息(如3a,和1c交换他两所知道的路由信息，及时获取自治系统内部的信息，TCP长连接)







# 重点：DHCP、NAT、IP数据报、路由器、转发表和转发



 

# 16.链路层

## 16.1网络适配器

![截屏2021-02-27 下午5.01.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.01.39.png)

主要设备：网络适配器 即 网卡



## 16.2链路层提供的服务

![截屏2021-02-27 下午5.01.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.01.51.png)

链路层也可以实现可靠交付



> 为什么我们不在数据链路层实现可靠交付？
>
> 如果在数据链路层实现可靠传输，那么在网络层、传输层、应用层也就实现了可靠传输， 不可靠主要是因为物理链路不可靠
>
> 如果要在数据链路层实现可靠交付，就得超时重传、序号、确认ACK、差错检验，通信效率降低



## 16.3差错检测

![截屏2021-02-27 下午5.11.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.11.21.png)





![截屏2021-02-27 下午5.12.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.12.02.png)





![截屏2021-02-27 下午5.13.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.13.48.png)



## 16.4链路层协议集

![截屏2021-02-27 下午5.17.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.17.37.png)

链路层协议集：描述了链路层做了什么事情





## 16.5信道划分协议

![截屏2021-02-27 下午5.20.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.20.52.png)



## 16.6 信道划分 CDMA协议

![截屏2021-02-27 下午5.25.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.25.25.png)







![截屏2021-02-27 下午5.43.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.43.59.png)





![截屏2021-02-27 下午5.48.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.48.23.png)



两个发送者

![截屏2021-02-27 下午5.50.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%885.50.55.png)





## 16.7 随机接入协议 

![截屏2021-02-27 下午6.01.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-27%20%E4%B8%8B%E5%8D%886.01.52.png)



![截屏2021-02-28 下午7.37.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.37.17.png)



![截屏2021-02-28 下午7.39.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.39.10.png)





## 16.8 载波侦听多路访问 CSMA/CD

![截屏2021-02-28 下午7.41.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.41.51.png)

![截屏2021-02-28 下午7.47.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.47.36.png)



## 16.9 轮流协议 轮询协议 令牌传递协议

![截屏2021-02-28 下午7.48.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.48.48.png)







![截屏2021-02-28 下午7.50.22](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.50.22.png)



## 16.10 以太网技术

![截屏2021-02-28 下午7.51.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%887.51.16.png)



## 16.11 交换机表

![截屏2021-02-28 下午8.03.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%888.03.40.png)

MAC地址，接口

路由器工作在网络层，通过转发表转发，到达路由器的输出链路。

交换机：一般指数据链路层的交换机，交换机里面有交换机表



集线器：扩展坞

网桥：网络层



## 通电后局域网内部发生了什么事情？

有线网络：机器检测到链路正常可以交互，缺IP地址，需要用DHCP协议(应用层)在网络中申请一个IP地址 ，通过广播的形式发送给所有人,数据链路层收到包后发出去，交换机数据链路层收到包，并且知道广播的人是谁，解开包发现是一个广播包(目的地址是fffff),给他的接口的每一个机器发一个包，其中一个人是DHCP服务器，DHCP服务器收到后回一个包，以广播的形式发送，交换机收到后更新交换机表，并且以广播的形式发送，然后机器拿到了IP地址。

## 此时访问一个网站会发生什么事情？

首先需要做DNS解析，首先是本地host文件，直接从本地host文件解析网站找到IP地址，没找到就会用DNS,本地DNS,DNS是对DHCP服务器请求时由DHCP服务器告知的。跟DHCP服务器通讯，拿到一个IP(谷歌8.8.8.8)，给谷歌DNS发数据,通过子网掩码判断是否在一个子网中，不在掩码中，然后就要去网关(即找到路由器)，包先到达交换机，如果不知道就广播形式发送给每一个机器，找到后对照路由表查询出口，从输出链路出来之后，最后从DNS拿到一个IP地址(百度的IP地址)，发送HTTP请求，底层TCP，TCP三次握手，

第一个数据报经过哪些服务器，贴上目标端口后交给IP层，网络层贴上目标IP地址，通过子网掩码判断是外网，到数据链路层，贴网关地址(通过ARP协议找到网关)，通过有线连接，直接到达交换机的某一个口，交换机进行转发，转发到服务器，(百度机房路由器收到包，出去后到达主机，解析后发现目的主机是他，原地址不是我的地址，我的地址是内网地址，他看到的是经过层层转发得到的一个公网IP地址以及一个对应的端口，)去掉头，交给运输层，运输层发现目的端口是80，是给HTTP服务器，然后交给HTTP，HTTP发现源端口是8731(通讯端口)，HTTP报文，get方法，资源是index.html,从本地读磁盘(一般会会在缓冲里面，资源比较火热)，拿到文件后封装到报文，头源端口是80，目的端口是8731，给网络层，贴上IP地址，交给数据链路层，发现不和本地服务器在一个网络，交给网关，然后经过一层一层到了我的NAT服务器，发现端口是8731，一层一层到了我的主机，然后呈现在我的电脑上面



过程中发生了交换机自学习(更新交换机表)，信息过滤(包发送到目标端口)，交换机表的时间是什么时候学习到的数据，可能会过期，过期后会删除重新学习。













# 三、网络和系统编程





# 17. IO多路复用

## 17.1 select

```cpp
NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       #include <sys/select.h>

       int pselect(int nfds, fd_set *readfds, fd_set *writefds,
                   fd_set *exceptfds, const struct timespec *timeout,
                   const sigset_t *sigmask);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pselect(): _POSIX_C_SOURCE >= 200112L
```





select 和 pselect 允许监控多个文件描述符，等待直到，或多个变成ready，(可以执行一个相关IO操作如：读)

select 和 pselect时间结构体不一样，pselect 有信号掩码sigmask，

三个独立的文件描述符集合，将会被监控查看是否有一些字符变得就绪，即读操作是否非阻塞的完成，

信号掩码：收到信号有三种处理方法：



## 17.2 poll ppoll epoll

epoll红黑树实现



poll



> 指针和数组有什么区别和关联？

> 指针如果作为函数的指针会退化为数组，









































































# 0000000







# 0作业



## 0.1 作业1:ls实现

![截屏2021-01-05 上午11.11.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%8811.11.26.png)





```

```





## 0.2 ls作业->opendir()

> opendir()
>
> readdir()
>
> closedir()
>
> ftell()
>
> readdir()





man getpwpid getpwuid getgrgid







0

锁：数据保护，互斥，

![fc73bb52fe85013f9d2b4713814cfa29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/fc73bb52fe85013f9d2b4713814cfa29.jpg)



```c
#include "00.head.h"
//#define INS 5

char num_file[] = "./.num";
char lock_file[] = "./.lock";
struct Msg {
    int now;
    int sum;
};

struct Msg num;

size_t set_num(struct Msg *msg) {
    FILE *f = fopen(num_file, "w");
    if (f == NULL) {
        fclose(f);
        perror("fopen");
        return -1;
    }
    size_t nwrite = fwrite(msg, 1, sizeof(struct Msg), f);
    fclose(f);
    return nwrite;
}

size_t get_num(struct Msg *msg) {
    FILE *f = fopen(num_file, "r");
    if (f == NULL) {
        fclose(f);
        perror("fopen()");
        return -1;
    }
    size_t nread = fread(msg, 1, sizeof(struct Msg), f);
    fclose(f);
    return nread;
}

void do_add(int end, int pid_num) {
    while (1) {
        FILE *lock = fopen(lock_file, "w");
        if (lock == NULL) {
            perror("fopen()");
            exit(1);
        }
        flock(lock->_fileno, LOCK_EX);
        if (get_num(&num) < 0) {
            fclose(lock);
            continue;
        }

        if (num.now > end) {
            fclose(lock);
            break;
        }
        num.sum += num.now;
        num.now++;
        printf("the %dth child : now = %d, sum = %d\n", pid_num, num.now, num.sum);
        set_num(&num);
        flock(lock->_fileno, LOCK_UN);
        fclose(lock);
    }

}

int main(int argc, char *argv[]) {

    int opt, start = 0, end = 0, ins = 0;
    while ((opt = getopt(argc, argv, "s:e:i:")) != -1) {
        switch (opt) {
        case 's':
            start = atoi(optarg);
            break;
        case 'e':
            end = atoi(optarg);
            break;
        case 'i':
            ins = atoi(optarg);
            break;
        default:
            fprintf(stderr, "Usage : %s -s start_num -e end_num -i\n", argv[0]);
            exit(1);
        }
    }
    printf("start = %d\n end = %d\n", start, end);

    num.now = 0;
    num.sum = 0;
    set_num(&num);

    pid_t pid;
    int x = 0;
    for (int i = 1; i <= ins; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(-1);
        }
        if (pid == 0) {//孩子
            x = i;
            break;
        }
    }
    if (pid != 0) {
        for (int i = 0; i < ins; i++) {
            wait(NULL);
        }

        //printf("I am father!\n");
        //sleep(100);
    } else {
        do_add(end, x);
    }
    get_num(&num);
    printf("sum = %d\n", num.sum);

    return 0;
}
```

```shell
./a.out -s 0 -e 100 -i 10                                                                   [0]
start = 0
 end = 100
the 1th child : now = 1, sum = 0
the 7th child : now = 2, sum = 1
the 1th child : now = 3, sum = 3
the 7th child : now = 4, sum = 6
the 1th child : now = 5, sum = 10
the 7th child : now = 6, sum = 15
the 1th child : now = 7, sum = 21
the 7th child : now = 8, sum = 28
the 1th child : now = 9, sum = 36
the 7th child : now = 10, sum = 45
the 1th child : now = 11, sum = 55
the 7th child : now = 12, sum = 66
the 7th child : now = 13, sum = 78
the 7th child : now = 14, sum = 91
the 1th child : now = 15, sum = 105
the 7th child : now = 16, sum = 120
the 1th child : now = 17, sum = 136
the 7th child : now = 18, sum = 153
the 1th child : now = 19, sum = 171
the 2th child : now = 20, sum = 190
the 1th child : now = 21, sum = 210
the 1th child : now = 22, sum = 231
the 3th child : now = 23, sum = 253
the 1th child : now = 24, sum = 276
the 3th child : now = 25, sum = 300
the 1th child : now = 26, sum = 325
the 3th child : now = 27, sum = 351
the 1th child : now = 28, sum = 378
the 3th child : now = 29, sum = 406
the 1th child : now = 30, sum = 435
the 6th child : now = 31, sum = 465
the 1th child : now = 32, sum = 496
the 3th child : now = 33, sum = 528
the 1th child : now = 34, sum = 561
the 6th child : now = 35, sum = 595
the 1th child : now = 36, sum = 630
the 3th child : now = 37, sum = 666
the 1th child : now = 38, sum = 703
the 6th child : now = 39, sum = 741
the 1th child : now = 40, sum = 780
the 2th child : now = 41, sum = 820
the 1th child : now = 42, sum = 861
the 2th child : now = 43, sum = 903
the 2th child : now = 44, sum = 946
the 3th child : now = 45, sum = 990
the 2th child : now = 46, sum = 1035
the 1th child : now = 47, sum = 1081
the 2th child : now = 48, sum = 1128
the 2th child : now = 49, sum = 1176
the 1th child : now = 50, sum = 1225
the 2th child : now = 51, sum = 1275
the 1th child : now = 52, sum = 1326
the 2th child : now = 53, sum = 1378
the 1th child : now = 54, sum = 1431
the 7th child : now = 55, sum = 1485
the 7th child : now = 56, sum = 1540
the 7th child : now = 57, sum = 1596
the 1th child : now = 58, sum = 1653
the 6th child : now = 59, sum = 1711
the 1th child : now = 60, sum = 1770
the 2th child : now = 61, sum = 1830
the 1th child : now = 62, sum = 1891
the 1th child : now = 63, sum = 1953
the 1th child : now = 64, sum = 2016
the 4th child : now = 65, sum = 2080
the 1th child : now = 66, sum = 2145
the 4th child : now = 67, sum = 2211
the 1th child : now = 68, sum = 2278
the 4th child : now = 69, sum = 2346
the 1th child : now = 70, sum = 2415
the 4th child : now = 71, sum = 2485
the 1th child : now = 72, sum = 2556
the 4th child : now = 73, sum = 2628
the 1th child : now = 74, sum = 2701
the 4th child : now = 75, sum = 2775
the 4th child : now = 76, sum = 2850
the 1th child : now = 77, sum = 2926
the 4th child : now = 78, sum = 3003
the 1th child : now = 79, sum = 3081
the 3th child : now = 80, sum = 3160
the 1th child : now = 81, sum = 3240
the 2th child : now = 82, sum = 3321
the 1th child : now = 83, sum = 3403
the 1th child : now = 84, sum = 3486
the 6th child : now = 85, sum = 3570
the 6th child : now = 86, sum = 3655
the 4th child : now = 87, sum = 3741
the 3th child : now = 88, sum = 3828
the 1th child : now = 89, sum = 3916
the 2th child : now = 90, sum = 4005
the 1th child : now = 91, sum = 4095
the 2th child : now = 92, sum = 4186
the 1th child : now = 93, sum = 4278
the 3th child : now = 94, sum = 4371
the 4th child : now = 95, sum = 4465
the 6th child : now = 96, sum = 4560
the 6th child : now = 97, sum = 4656
the 6th child : now = 98, sum = 4753
the 4th child : now = 99, sum = 4851
the 6th child : now = 100, sum = 4950
the 1th child : now = 101, sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
sum = 5050
```

flock













# 1.作业2

```
命令./test -m "msg"
结果输出：msg
命令./test
vim a.txt
input msg
printf msg
delete a.txt
模拟过程，可能需要3个进程
```



ls，ls -al,

分列显示，有排序

显示/不显示隐藏文件，























































































































# 0.end