# 1.C/C++

## 1.变量的内存布局模型

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617010890605/7AFBB1602613EC52B265D7A54AD27330)

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617010890605/7AFBB1602613EC52B265D7A54AD27330)

**从低地址到高地址，一个程序由代码段、数据段、** **BSS** **段组成。**

1. **代码段：**存放程序**执行代码**的一块内存区域。只读，代码段的头部还会包含一些**只读的常数变量**。

2. **数据段data：**存放程序中**已初始化**的**全局变量**和**静态变量**的一块内存区域。

3. **BSS** 段：存放程序中**未初始化**的**全局变量**和**静态变量**的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：**堆区**和**栈区。**

   **堆区：**动态申请内存用。堆从低地址向高地址增长。

   **栈区：**存储**局部变量**、**函数参数值**。栈从高地址向低地址增长。是一块连续的空间。

5. 最后还有一个**文件映射区（共享区）**，位于堆和栈之间。存放共享内存。。

## 2.**野指针与内存泄露**

### 有哪些情况下会产生**野指针**

（1）**指针变量的值未被初始化**：

声明一个指针的时候，没有显示的对其进行初始化，那么该指针所指向的地址空间是乱指一气的。如果指针声明在全局数据区，那么未初始化的指针缺省为空，如果指针声明在栈区，那么该指针会随意指向一个地址空间。

（2）**指针所指向的地址空间已经被free或delete**:

在堆上malloc或者new出来的地址空间，如果已经free或delete，那么此时堆上的内存已经被释放，但是指向该内存的指针如果没有人为的修改过，那么**指针还会继续指向这段堆上已经被释放的内存**，这时还通过该指针去访问堆上的内存，就会造成不可预知的结果，给程序带来隐患。

(3）**指针操作超越了作用域**：

### 何避免野指针呢？

(1）初始化置NULL

（2）申请内存后判空：malloc申请内存后需要判空，而在现行C++标准中，如C++11，使用new申请内存后不用判空，因为发生错误将抛出异常。

（3）指针释放后置NULL

（4）使用智能指针。 



## 3.什么是**内存泄露**？

（1）new和malloc申请资源使用后，没有用delete和free释放；

（2）子类继承父类时，父类析构函数不是虚函数

（3）Windows句柄资源使用后没有释放。

有以下几种避免方法：

第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：使用智能指针。

第四：一些常见的工具插件可以帮助检测内存泄露，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

## 4.内存碎片通常分为**内部碎片**和**外部碎片**：

（1）**内部碎片**是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免；

（2）**外部碎片**是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。再比如堆内存的频繁申请释放，也容易产生外部碎片。



## 5.说说new和malloc的区别，各自底层实现原理

1. new是操作符，而malloc是库函数。
2. new在调用的时候先分配内存，在调用构造函数，释放的时候用delete调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针一般需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null



## 6.封装、继承、多态

- 封装：隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互，将数据和操作数据的方法进行有机结合。被封装的元素隐藏了它们的实现细节–可以调用一个函数但是不能够访问函数所执行的语句。

  > 将成员方法和成员属性写在一个类里面，对外公开的是一些函数，但不会公开具体的实现细节,隐藏实现细节，使得代码模块化；

- 继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类函数，变量等

  > 子类继承父类的所有的属性和方法，子类创建对象后可以父类的部分属性和方法访问,扩展已存在的代码模块（类）；它们的目的都是为了代码重用

- 可以简单概括为“一个接口，多种方法”，即用的是同一个接口，但是效果各不相同，多态有两种形式的多态，一种是静态多态，一种是动态多态,实现的目的是为了接口重用



静态多态动态多态

虚函数-》虚函数表


## 7.const

> const和define的区别

const用于定义常量，define用于定义宏，也可以用于定义常量，

const运行与编译期，define运行于预处理期

const定义常量时需要带类型，define定义常量的时候不需要带类型。



```cpp
1. const int a;          //指的是a是一个常量，不允许修改。
2. const int *a;         //a指针所指向的内存里的值不变，即（*a）不变
3. int const *a;         //同const int *a;
4. int *const a;         //a指针所指向的内存地址不变，即a不变
5. const int *const a;   //都不变，即（*a）不变，a也不变
```



## static



## 引用与指针

## 智能指针

# STL标准模板库

基于模板实现

容器算法迭代器

容器、算法algorithm、迭代器iterator

指向容器的指针

## string

### 1.string 是一个类，char*是一个指针，

string封装了char\*,管理这个字符串，是一个char*类型的容器

### 2.string封装了很多实用的成员方法

查找find,拷贝copy，删除delete,替换replace,插入insert

### 3.不考虑内存释放和越界

string管理char*所分配的内存，每一次string复制，取值都是由string类负责维护，不用担心复制越界和取值越界

### 4.string和char*可以相互转换吗，如果能，怎么转换？

string转char *通过string提供c_str();



string复制

string find,rfind,append,replace,insert,erase,substr,compare

## vector

动态数组

单口容器

尾部插入不需要移动元素，效率高

vector增长原理：

插入新元素时，如果空间不足，申请更大的空间，原空间拷贝到新空间，释放旧空间，再把新元素插入新申请的空间realloc







# 2.操作系统

内存空间

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617011293853/7AFBB1602613EC52B265D7A54AD27330)



| 数据段     | 存放程序中**已初始化**的**全局变量**和**静态变量**的一块内存区域。 |      |
| ---------- | ------------------------------------------------------------ | ---- |
| 代码段     | 存放程序**执行代码**的一块内存区域。只读，代码段的头部还会包含一些**只读的常数变量** |      |
| **BSS** 段 | 全局/静态未初始化数据：存放程序中**未初始化**的**全局变量**和**静态变量**的一块内存区域。 |      |
| **堆区**   | 动态申请内存用。堆从低地址向高地址增长。                     |      |
| **栈区**   | 存储**局部变量**、**函数参数值**。栈从高地址向低地址增长。是一块连续的空间。 |      |



代码段：存放指令，全局区存放变量，堆栈区，内核空间

## 1.进程

### 进程

我们写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。

进程：程序是指令、数据及其组织形式的描述，而**进程**则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。



进程结构：一般分为**三部分**：**代码段、数据段和堆栈段**。也就是程序，数据，进程控制块PCB（进程控制块）

**代码段**用于存放程序代码，如果有多个进程运行相同的一个程序，那么它们可以使用同一个代码段。

（因为要进程是程序运行的实例，是程序就会有代码，所以就有代码段）

**数据段**则存放程序的全局变量、常量和静态变量。

（进程之间可能要切换，需要存储当前环境的值）

**堆栈段**中的栈用于函数调用，存放着函数的参数、局部变量。PCB

### 进程控制块PCB

进程控制块的以下信息分为四类：

- 进程的标识符
- 进程状态
- 进程调度信息
- 进程控制信息



### PCB 具体包含什么信息呢？

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 进程状态

**01 创建进程**

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

创建进程的过程如下：

- 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；
- 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；
- 初始化 PCB；
- 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；

**02 终止进程**

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。

终止进程的过程如下：

- 查找需要终止的进程的 PCB；
- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将其所有子进程终止；
- 将该进程所拥有的全部资源都归还给父进程或操作系统；
- 将其从 PCB 所在队列中删除；

**03 阻塞进程**

当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞进程的过程如下：

- 找到将要被阻塞进程标识号对应的 PCB；
- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；
- 将该 PCB 插入的阻塞队列中去；

**04 唤醒进程**

进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。

如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。

唤醒进程的过程如下：

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将其从阻塞队列中移出，并置其状态为就绪状态；
- 把该 PCB 插入到就绪队列中，等待调度程序调度；

进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。



### 程序是怎么转换为进程的呢？进程的创建

1. 内核将程序读入内存，为程序分配内存空间。
2. 内核为该进程分配进**程标识符**（**PID**，记住这个名称）和其他所需资源
3. 内核为进程保存PID及相应的状态信息，并且将进程放入运行队列中等待执行。
4. 由操作系统调度执行。





 

对进程的理解？

**进程**是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

进程结构一般分为**三部分**：**代码段、数据段和堆栈段**。

- **代码段**用于存放程序代码，如果有多个进程运行相同的一个程序，那么它们可以使用同一个代码段。
- **数据段**则存放程序的全局变量、常量和静态变量。
- **堆栈段**中的栈用于函数调用，存放着函数的参数、局部变量。







### 1.进程间通信方式

管道、IPC(消息队列、共享内存、信号量、信号)、套接字

管道：

fork创建的父子进程之间不共享数据段和堆栈段，它们之间是通过**管道**进行通信的。**管道是一种两个进程间进行单向通信的机制**。因为这种单向性，管道又称为半双工管道，所以其使用是有一定的局限性的。半双工是指数据只能由一个进程流向另一个进程（一个管道负责读，一个管道负责写）；如果是全双工通信，需要建立两个管道。**管道本质是一种文件**

消息队列:

**消息队列**是在一个系统内核中建立一个保存消息的队列，表现形式为消息链表。消息链表中节点的结构用msg声明。进程消息队列通信，需要两个进程，一个接受消息，一个发送消息，

### 2.进程同步的方式？

1. **信号量semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
2. **管道**：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
3. **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。
4. **互斥锁**



### 3.线程间通信

1. **互斥锁**。
2. **信号量**。
3. **条件变量**。
4. **读写锁**。



### 4.**进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的** 

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源



区别： 

1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 

2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 

3.进程是资源分配的最小单位，线程是CPU调度的最小单位； 

4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。 

5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 

6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 

7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉 

8.进程适应于多核、多机分布；线程适用于多核 

进程间通信的方式： 

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 

1.管道： 

管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 

1.1 普通管道PIPE： 

1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端 

2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间） 

3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 

1.2 命名管道FIFO： 

1)FIFO可以在无关的进程之间交换数据 

2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 



\2. 系统IPC： 

2.1 消息队列 

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 

特点： 

1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 

2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 

3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 



2.2 信号量semaphore 

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 

特点： 

1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 

2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 

3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 

4)支持信号量组。 



2.3 信号signal 

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 



2.4 共享内存（Shared Memory） 

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等 

特点： 

1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取 

2)因为多个进程可以同时操作，所以需要进行同步 

3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问 



3.套接字SOCKET： 

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 



线程间通信的方式: 

临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 

互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 

信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 

事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 5.进程的状态

**在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。**

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)进程的三种基本状态

上图中各个状态的意义：

- 运行状态（*Runing*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，但因为其他进程正在运行而暂停停止；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

当然，进程另外两个基本状态：

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

于是，一个完整的进程状态的变迁如下图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9gjKOC2IyZwLJXMcqzgvpKia0u1ezepiawX0iaFkrvsLeV6qsHplv5grnw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)进程五种状态的变迁

再来详细说明一下进程的状态变迁：

- *NULL -> 创建状态*：一个新进程被创建时的第一个状态；
- *创建状态 -> 就绪状态*：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- *就绪态 -> 运行状态*：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- *运行状态 -> 结束状态*：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- *运行状态 -> 就绪状态*：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- *运行状态 -> 阻塞状态*：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- *阻塞状态 -> 就绪状态*：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9dsvxg4PrqzwaWvVS4CUicfzjAvE4gqHib3duJQPD35CWNibNrzicEP8bwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)虚拟内存管理-换入换出

挂起状态可以分为两种：

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9OSw0O4hBZhsvyrPTCkXqwCg9QgtBfdrCsU90NaspiabyILN5QxmAYxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)七种状态变迁











### 7.同一个进程的线程共享哪些资源

> 1.进程代码段、
>
> 2.进程的数据段(利用这些共享的数据，线程很容易的实现相互之间的通讯)、
>
> 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。



### 8.同一个进程的线程不共享哪些资源

线程ID、寄存器组的值、线程的堆栈、错误返回码、线程的信号屏蔽码、线程的优先级

 1.线程ID
   每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

  2.寄存器组的值
    由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

  3.线程的堆栈
    堆栈是保证线程独立运行所必须的。
    线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。

  4.错误返回码
    由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。
    所以，不同的线程应该拥有自己的错误返回码变量。

  5.线程的信号屏蔽码
    由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。

  6.线程的优先级
    由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

### 9.**线程从用户态切换到内核态：**

什么情况下会造成线程从用户态到内核态的切换呢？

首先，如果在程序运行过程中发生中断或者异常，系统将自动切换到内核态来运行中断或异常处理机制。

此外，程序进行系统调用也会从用户态切换到内核态。



## 2.进程、线程通信方式

进程通信方式

管道、IPC（消息队列、共享内存、信号量、信号）、socket

信号量：

信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。



链接：https://zhuanlan.zhihu.com/p/104713463

为什么共享内存的方式比其他进程间通信的方式效率高？

消息队列，FIFO，管道的消息传递方式一般为 ：

1).服务器获取输入的信息；

2).通过管道，消息队列等写入数据至内存中，通常需要将该数据拷贝到内核中；

3).客户从内核中将数据拷贝到自己的客户端进程中；

4).然后再从进程中拷贝到输出文件；

上述过程通常要经过4次拷贝，才能完成文件的传递。

而共享内存只需要：

1).输入内容到共享内存区

2).从共享内存输出到文件

## 10.互斥、同步、并发和并行

### 1.并发

在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34yUqcPlbC7BA8K7uvbjMzlZDYPwYMZEbDxqjqZvU4YmdlxmKJmz6kvsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)并发

另外，操作系统也为每个进程创建巨大、私有的虚拟内存的假象，这种地址空间的抽象让每个程序好像拥有自己的内存，而实际上操作系统在背后秘密地让多个地址空间「复用」物理内存或者磁盘。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34ynrF1wCQKkQ7ziaZGqh2gialnS9eIcFPPtQQ4IrMpMs7engDdUuKUm6IQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)虚拟内存管理-换入换出

如果一个程序只有一个执行流程，也代表它是单线程的。当然一个程序可以有多个执行流程，也就是所谓的多线程程序，线程是调度的基本单位，进程则是资源分配的基本单位。

所以，线程之间是可以共享进程的资源，比如代码段、堆空间、数据段、打开的文件等资源，但每个线程都有自己独立的栈空间。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34ykr1lnBzhNotSn2QqeaK900M2fdR9NRhNJjt7KgTsH4hHX69utfC9iag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)多线程

那么问题就来了，多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱。

### 互斥

**保证一个线程在临界区执行时，其他线程应该被阻止进入临界区**，说白了，就是这段代码执行过程中，最多只能出现一个线程。

### 同步

**就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步**。

同步与互斥是两种不同的概念：

- 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；
- 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；



并发：两个或者多个事件在同一时刻发生

并行：两个或者多个事件在 ***同一个时间间隔*** 发生。



 

## 3.死锁

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

进程A获取资源的顺序是资源1、资源2，进程B获取资源的顺序是资源2、资源1，进程先获取资源1，给他上锁，然后获取资源2，但是现在资源2已结被进程B上锁了，进程B要获取资源1，资源1被进程A上锁了，就形成了死锁。

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247490551&idx=1&sn=21c2f1145baa32c0e501526191d77c54&chksm=f98e5f5dcef9d64be9d2c0bc25d69c8630f10760007a6b0b4f9fae41dfa3b8c5bbca6260d08d&scene=178&cur_album_id=1408057986861416450#rd

### 1.死锁的四个必要条件

- 互斥条件；
- 持有并等待条件；
- 不可剥夺条件；
- 环路等待条件；

##### 互斥条件

互斥条件是指**多个线程不能同时使用同一个资源**。

比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OyogHIgicpibhaswiathIvb5nWeVKPSfiaZJFiaC8MESxjYRGwtLdP1Xw3BQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 持有并等待条件

持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程  A 就会处于等待状态，但是**线程  A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OneC82tLlWEN0rZV0y82IUwbtNz0LApXkC7BBDrRQkroF9lHu7dlIKA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 不可剥夺条件

不可剥夺条件是指，当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。


![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OyYErAFzpQuuhic1N2ah7Th86DF12ibQIWVuia13IaqL8IQNIDv20YcIbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 环路等待条件

环路等待条件指都是，在死锁发生的时候，**两个线程获取资源的顺序构成了环形链**。

比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5Oe0DrWrpPyHavLTm023lkkc9ouk8bKDsLBcJyugQhoBs8bqN6zw0esg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### 2.请你说一说死锁发生的条件以及如何解决死锁

 

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：

互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源； 

请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源 

不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放 

环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链 

解决死锁的方法即破坏上述四个条件之一，主要方法如下： 

资源一次性分配，从而剥夺请求和保持条件 

可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件 

## 3.如何解决死锁

避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。

资源有序分配法：

系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 

那什么是资源有序分配法呢？

线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 1，然后尝试获取资源  2 的时候，线程 B 同样也是先尝试获取资源 1，然后尝试获取资源 2。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。

所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5O6gOodqCMPk7lXbwlTf1DtiaAw5ROVjeUichmerliaLHaFSmbPr9oS8QUw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 死锁总结

死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。

死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。

所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是使用资源有序分配法来破坏环路等待条件。







## 4.用户态与内核态

1. #### 内核态与用户态的区别 

   1. **内核态与用户态**：**内核态**（系统态）与**用户态**是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。
   2. **什么时候进入内核态**：共有三种方式：a、**系统调用**。b、**异常**。c、**设备中断**。其中，系统调用是主动的，另外两种是被动的。
   3. **为什么区分内核态与用户态**：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。

2. #### 什么是系统调用 

   Linux内核中设置了一组用于实现各种系统功能的子程序，称为**系统调用**。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。

   系统调用的机制其核心还是使用了操作系统为用户特别开放的一个**中断**来实现，该中断是程序人员自己开发出的一种正常的异常，这个异常具体就是调用int $0x80的汇编指令，这条汇编指令将产生向量为0x80的编程异常。

   产生中断（软中断）后，调用中断处理程序，调用System_call函数，就完成操作系统内核态的调用了。



 

**内核态和用户态的区别** 

当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于内核状态。此时处理器处于特权级最高的(0级)内核代码。当进程处于内核态时，执行的内核代码会使用当前的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序而突然中断时，此时用户程序也可以象征性地处于进程的内核态。因为中断处理程序将使用当前进程的内核态。

**用户态切换到内核态的3种方式** 

**a.系统调用** 

这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。

**b.异常** 

当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。 

**c.外围设备的中断** 

当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。





## 5.HTTP、HTTPS



# 3.计算机网络



## 1.TCP/IP ⽹络模型

应用层：手机

传输层：TCP/UDP

| TCP/IP网络模型 | 功能                                                         | 协议            |        | 交互的数据单元 |
| -------------- | ------------------------------------------------------------ | --------------- | ------ | -------------- |
| 应用层         | 应⽤就把应⽤数据传给下⼀层，也就是传输层。                   | HTTP、DNS、SMTP | 用户态 | 报文           |
| 传输层         | 为应用层提供网络支持                                         | TCP、UDP        | 内核态 | 数据段         |
| 网络层         |                                                              | IP协议、ICMP    |        | 包             |
| 数据链路层     | 标识⽹络中的设备，让数据在⼀个链路中传输，主要为⽹络层提供链路级别传输的服务 | ARP、RARP       |        | 帧             |
| 物理层         | 把数据包转换成电信号                                         |                 |        |                |



数据链路层：

每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再 通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。



##  2.计算机网络体系结构

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617019888021/BA6BEB7AE28EF0A97D7A0A038FEB5060)



（1）**应用层**：应用层是体系结构中的最高层。其任务是**通过应用进程间的交互来完成特定网络应用**。应用层协议定义了**应用进程间通信和交互的规则**。应用层协议如域名系统DNS，支持互联网Web应用的协议HTTP，支持电子邮件的协议SMTP等等。应用层交互的数据单元称为**报文**（message）。

（2）**传输层**。其任务是为**两台主机中进程之间的通信**提供**通用的数据传输服务**。主要有两种协议：**TCP（Transmission Control Protocol）**提供面向连接的、可靠的数据传输服务，其传输的基本单位是**报文段（segment）**。而**UDP（User Datagram Protocol）**提供无连接的、尽最大努力可靠交付的传输服务，其传输的基本单位是**用户数据报**。

（3）**网络层**：其任务是负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把**传输层**产生的**报文段**或**用户数据报**封装成**分组（包）（Packet）**进行传送。由于网络层使用IP协议，因此分组也称为IP数据报。网络层的另一个任务就是要**选择合适的路由**，使源主机传输层所传下来的分组，能够通过网络中的**路由器**找到目的主机。**路由（routing）**是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。

（4）**数据链路层**：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报**组装成帧（framing）**，在两个相邻结点间的链路上传送**帧（frame）**。每一帧包括数据和必要的**控制信息**（如同步信息、地址信息、差错控制等）。用于协作 IP 数据在已有网络介质上传输的协议，典型的是ARP/RARP。

**网络接口层包括用于协作 IP 数据在已有网络介质上传输的协议，典型的是ARP/RARP**。 网络接口层就相当于**OSI模型的物理层+数据链路层**，它定义了像 ARP (Address Resolution Protocol ，地址解析协议）这样的协议，提供 TCP/IP 协议的数据结构和实际物理硬件之间的接口 。

在接受数据时，控制信息使接受端能够知道一个帧从哪个比特开始到哪个比特结束。这样，数据链路层在收到一个帧后，从中提取数据，上交给网络层。

5）**物理层**：物理层传输的数据的单位是比特。传输的是电信号。

## 3.各层的协议

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617019911262/9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)

1. **应用层**：应用层是体系结构中的最高层。其任务是**通过应用进程间的交互来完成特定网络应用**。应用层协议定义了**应用进程间通信和交互的规则**。

   常用应用层协议如：

   域名系统**DNS**：DNS协议是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。

   支持互联网应用的协议**HTTP**：超文本传输协议，在浏览器与服务器间传送文档。

   **SMTP**协议：简单邮件传送协议

   **FTP**协议：文件传输协议

   **RIP** 协议：距离矢量路由选择协议。

2. **传输层**：其任务是为**两台主机中进程之间的通信**提供**通用的数据传输服务**。

   主要有两种协议：

   **TCP：**提供面向连接的、可靠的数据传输服务。

   **UDP：**提供无连接的、尽最大努力可靠交付的传输服务。

   **SCTP** (Stream Control Transmission Protocol)是一种传输协议，在TCP/IP协议栈中所处的位置和TCP、UDP类似，兼有TCP/UDP两者特征。

3. **网络层**：其**任务是负责为分组交换网上的不同主机提供通信服务**。

   常用协议如：

   **IP** 协议：（1） 寻址。（2） 路由选择。（3） 分段与组装。

   **ICMP**协议：用于在IP主机、路由器之间传递控制消息，用来提供网络诊断信息 。

4. **数据链路层**：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。

   **ARP**协议：ARP地址解析协议用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位）

   **RARP**协议：RARP协议（Reverse ARP，反向ARP协议），其功能是将MAC地址解析为对应的IP地址。



在**应用层**的数据称为**报文（message）**；在**传输层**的数据称为**段（segment）**；在**网络层**的数据叫 **分组包（packet）**，**网络接口层（链路层）**的数据称为**帧（frame）**。

## 4.TCP、UDP

## 为什么需要TCP？

IP层不可靠，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。

如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责

因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余 和按序的。

> ### 什么是 TCP ？

TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。 

- ⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀ 对多是⽆法做到的； 

- 可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端； 

- 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前 ⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的 报⽂会⾃动丢弃。 

  

  > ### 什么是 TCP连接？

⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝ ⼤⼩称为连接。

建⽴⼀个 TCP 连接是需要客户端与服务器端达成三个信息的共识。

 Socket：由 IP 地址和端⼝号组成 

序列号：⽤来解决乱序问题等 

窗⼝⼤⼩：⽤来做流量控制



> ### 如何唯⼀确定⼀个 TCP 连接呢？

源地址 源端⼝ ⽬的地址 ⽬的端⼝





## 5.TCP、UDP区别

1. 连接 

- TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。 

- UDP 是不需要连接，即刻传输数据。

2. 服务对象 
   - TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。序列号、确认应答、超时重传
   -  UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信 

3. 可靠性 
   - TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。 
   - UDP 是尽最⼤努⼒交付，不保证可靠交付数据。 
4. 拥塞控制、流量控制 
   - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 
   - UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。

5. ⾸部开销 
   - TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」 字段则会变⻓的,开销大。
   - UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。 
6. 传输⽅式 
   - TCP 是流式传输，没有边界，但保证顺序和可靠。 
   - UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。 

7. 分⽚不同 
   - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。
   -  UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再 传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样传输 效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU

8. 应用场景

- TCP提供可靠的服务，适用于通讯质量要求高的场景；
- UDP传输效率高，适用于高速传输和实时性要求的场景。

## 6.TCP、UDP应用场景

由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：

-  FTP ⽂件传输 
- HTTP / HTTPS

由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：

-  包总比较少的通信，如 DNS 、 SNMP 等 
- 视频、⾳频等多媒体通信 
- ⼴播通信





## 7.**TCP三次握手与四次挥手**

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617020287180/602E8F042F463DC47EBFDF6A94ED5A6D)



**三次握手**：

1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置1，ack=J+1，随机产生一个值seq=K，并将该数据包发给Client以确认连接请求，Server进入SYN_RCVD状态。
3. Client收到确认后，检测ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检测ack是否为K+1，ACK是否为1，如果正确则连接成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，

**四次挥手**：

1. 数据传输结束后，Client的应用进程发出连接释放报文段FIN，并停止发送数据，Client进入FIN_WAIT_1状态，此时Client依然可以接收Server发送来的数据。
2. Server接收到FIN后，发送一个ACK给Client，确认序号为收到的序号+1，Server进入CLOSE_WAIT状态。Client收到后进入FIN_WAIT_2状态。
3. 当Server没有数据要发送时，Server发送一个FIN报文，此时Server进入LAST_ACK状态，等待Client的确认。
4. Client收到Server的FIN报文后，给Server发送一个ACK报文，确认序列号为收到的序号+1。此时Client进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。









## 8.**TCP如何保证可靠性**

1. **序列号、确认应答、超时重传**
   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序列号，序列号说明了它下一次需要接收的数据序列号，保证数据传输有序。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一段时间后进行重传。

2. **窗口控制**
   TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。
   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；数据一旦丢失，接收端会一直提醒。

3. **拥塞控制**
   如果把窗口定的很大，发送端连续发送大量的数据，可能造成网络的拥堵。为了防止拥堵，进行拥塞控制。

   （1）**慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到一次确认应答，将拥塞窗口大小*2

   （2）**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是只当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是+1

   （3）**快恢复**：将报文段的超时重传看做拥塞，则一旦发生超时重传，我们就将阈值设为当前窗口大小的一半，并且窗口大小变为1，重新进入慢启动过程

   （4）**快速重传**：3次重复确认应答，立即重传。



## 9.TCP 第⼀次握⼿ SYN 丢包

当客户端发起的 TCP 第⼀次握⼿ SYN 包，在超时时间内没收到服务端的 ACK，就会在==超时重传 SYN 数据包，每次超时重传的 RTO (超时时间)是翻倍上涨的，直到 SYN 包的重传次数到达 tcp_syn_retries默认5 值后，客户端不再发送 SYN 包。==

## TCP 第⼆次握⼿ SYN、ACK 丢包

当 TCP 第⼆次握⼿ SYN、ACK 包丢了后，客户端 ==SYN 包会发⽣超时重 传==，==服务端 SYN、ACK 也会发⽣超时重传==。 

客户端 SYN 包超时重传的最⼤次数，是由 tcp_syn_retries 决定的，默认值是 5 次；服务端 SYN、ACK 包时重传 的最⼤次数，是由 tcp_synack_retries 决定的，默认值是 5 次。

## TCP 第三次握⼿ ACK 丢包

在建⽴ TCP 连接时，如果第三次握⼿的 ACK，服务端⽆法收到，则服务端就会短暂处于 SYN_RECV 状态，⽽客户 端会处于 ESTABLISHED 状态。 

由于服务端⼀直收不到 TCP 第三次握⼿的 ACK，则会==⼀直重传 SYN、ACK 包==，直到重传次数超过 tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。

⽽客户端则会有两种情况： 

- 如果客户端没发送数据包，⼀直处于 ESTABLISHED 状态，然后经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死 亡」连接，于是客户端连接就会断开连接。 
- 如果客户端发送了数据包，⼀直没有收到服务端对该数据包的确认报⽂，则会⼀直重传该数据包，直到中传次 数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。



## 10.TCP流量控制和拥塞避免、重传机制、滑动窗⼝

流量控制：防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理

**`2.流量控制的一些知识点`**

> （1）接收端抑制发送端的依据：接收端缓冲区的大小
> （2）流量控制的目标是接收端，是怕接收端来不及处理
> （3）流量控制的机制是丢包

**`3.怎么样实现流量控制？`**

> 使用滑动窗口
> **滑动窗口**
> **`1.滑动窗口是什么？`**
> 滑动窗口是类似于一个窗口一样的东西，是用来告诉发送端可以发送数据的大小或者说是窗口标记了接收端缓冲区的大小，这样就可以实现
> ps：窗口指的是一次批量的发送多少数据

2.为什么会出现滑动窗口？

在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候

使用滑动窗口，就可以一次发送多条数据，从而就提高了性能

3.滑动窗口的一些知识点

（1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
（2）窗口大小字段越大，说明网络的吞吐率越高
（3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
（4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉

ps：发送缓冲区如果太大，就会有空间开销

 **`4.滑动窗口的优点`**

> 可以高效可靠的发送大量的数据



拥塞控制：防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞





## 11.当在局域网中使用ping时，用到了哪些协议？

通过DNS协议，将ping后接的域名转换为ip地址。（DNS使用的传输层协议是UDP）

通过ARP解析服务，由ip地址解析出MAC地址，以在数据链路层传输。

ping是为了测试另一台主机是否可达，发送一份==**ICMP**==回显请求给目标主机，并等待ICMP回显应答。（ICMP用于在ip主机、路由器间传递网络是否通畅、主机是否可达等控制信息）



## 12.socket

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617020573807/586E508F161F26CE94633729AC56C602)





## 13.HTTP、HTTPS

 HTTP 请求/响应的**步骤**：

1. **客户端连接到Web服务器**
   一个HTTP**客户端**，通常是**浏览器**，与**Web服务器**的HTTP端口（默认为80）建立一个**TCP**套接字连接。例如，[http://www.baidu.com。](http://www.baidu.com./)

2. **发送HTTP请求**
   通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部（header）和请求数据 （可选）3部分组成。

3. **服务器接受请求并返回HTTP响应**
   Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。一个**响应**由状态行、响应头部和响应数据（请求体）3部分组成。

4. **处理TCP连接**
   若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

5. **解析数据，显示Web界面**
   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，并在浏览器窗口中显示。

   

## 14.在浏览器地址栏键入URL，按下回车之后会经历以下流程？

1. 解析 URL,浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 释放 TCP连接;
6. 浏览器解析html代码，并请求html代码中的资源，最后对页面进行渲染呈现给用户。



通过DNS获取IP地址

1.解析 URL,浏览器确定了 要请求的Web 服务器和⽂件名，

2.客户端⾸先会发出⼀个 DNS 请求，问本地域名服务器，如果缓存⾥的表格里面可以找到，则它直接返回 IP 地址。

3.如果没有，本地 DNS 会去问它的根域名服务器，根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。

4.根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“www.baidu.com 这个域名归 .com 区域管 理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

5.本地 DNS 收到顶级域名服务器的地址后，发起请求问“顶级域名服务器， 你能告诉我 www.baidu.com 的 IP 地址吗？”

6.顶级域名服务器说：“我给你负责 www.baidu.com 区域的权威 DNS 服务器的地址，你去问它应该能到”。

7.本地 DNS 于是转向问权威 DNS 服务器,www.baidu.com对应的IP是啥呀？baidu.com 的权威 DNS 服务器，它是域名解析结果的原出处,他一看这个是他负责的，

8.权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 

9.本地 DNS 再将 IP 地址返回客户端，客户端获得IP地址



10.通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。

( 协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托 ⼯作，下⾯的部分收到委托的⼯作并执⾏。)

11.应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。 

12.协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽ 将⽹络包发送给对⽅的操作就是由 IP 负责的。

13.数据报遇到了TCP，加上TCP头部，











# 4.简历项目



## 谷歌测试框架gtest

1.输出颜色``\033[    \033[0m`

格式颜色，数据统计，报错信息输出

宏定义避免a++,++a,typeof

执行RUN_ALL_TESTS()，函数里面统计了函数测试的总数和成功的测试数，循环输出结构体功能， Function结构体（函数指针和字符串，存储函数名字），将信息打包成结构体，声名一个结构体数组，将函数拷贝

通过RUN_ALL_TESTS()控制这个测试用例，有一个结构体，结构体里面存的函数指针和函数名，声名一个结构体类型的数组，存储每一组测试用例，每次输出一个测试用例，统计结果。

EXPECT,输出每一个测试用例的结果，同时统计测试样例的个数和失败的个数



## 简易聊天系统



```cpp
struct Msg{
    char name[20];
    char msg[1024];
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};

// ipc.chat.server.c
struct Msg *shar_memory = NULL;
//服务端
int main() {
    int shmid;
    key_t key = ftok(".", 202101);
    if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }

    if ((shar_memory = (struct Msg *)shmat(shmid, NULL, 0)) == (struct Msg *)-1) {
        perror("shmat");
        exit(-1);
    }
    //初始化
    memset(shar_memory, 0, sizeof(struct Msg));
    pthread_mutexattr_t m_attr;
    pthread_mutexattr_init(&m_attr);
    pthread_mutexattr_setpshared(&m_attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&shar_memory->mutex, &m_attr);
  	//初始化一个互斥锁     //互斥锁标识         //互斥锁属性  

    pthread_condattr_t c_attr;
    pthread_condattr_init(&c_attr);
    pthread_condattr_setpshared(&c_attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&shar_memory->cond, &c_attr);
    //初始化条件变量  

    while (1) {
       // 对互斥锁上锁，若互斥锁已经上锁，则调用者一直阻塞，// 直到互斥锁解锁后再上锁。  
        pthread_mutex_lock(&shar_memory->mutex);
        printf("Server got the Mutex!\n");
        //阻塞等待  
        pthread_cond_wait(&shar_memory->cond, &shar_memory->mutex);
        printf("Server got the cond signal!\n");
        printf("<%s> : %s.\n", shar_memory->name, shar_memory->msg);
        memset(shar_memory->msg, 0, sizeof(shar_memory->msg));
        pthread_mutex_unlock(&shar_memory->mutex);// 对指定的互斥锁解锁。  

    }

    return 0;
}

//ipc.chat.client.c
struct Msg *shar_memory = NULL;

int main(int argc, char **argv) {

    int opt, shmid;//.,共享内存id
    char name[20] = {0};
    while ((opt = getopt(argc, argv, "n:")) != -1) {
        switch (opt) {
        case 'n':
            strcpy(name, optarg);
            break;
        default:
            fprintf(stderr, "Usage : %s -n name\n", argv[0]);
            exit(1);
        }
    }

    key_t key = ftok(".", 202101);
      //创建共享内存  
    if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }
    // 进程将共享内存连接到自身的地址空间
    if ((shar_memory = (struct Msg *)shmat(shmid, NULL, 0)) == (struct Msg *)-1) {
        perror("shmat");
        exit(1);
    }

    while (1) {
        char msg[1024] = {0};
        scanf("%[^\n]s", msg);
        getchar();//吃掉缓冲区的回车键
        if (!strlen(msg)) continue;//字符串为空
        while (1) {
            if (!strlen(shar_memory->msg)) {//当写入数据前，加锁  
                pthread_mutex_lock(&shar_memory->mutex);
            }
        }
        //pthread_mutex_lock(&shar_memory->mutex);
        printf("Sending : %s...\n", msg);
        strcpy(shar_memory->msg, msg);//向共享内存中写入数据  
        strcpy(shar_memory->name, name);
        pthread_cond_signal(&shar_memory->cond);//至少唤醒一个等待该条件的线程  
        pthread_mutex_unlock(&shar_memory->mutex);//  //写入数据后，解锁  
        printf("Client signaled the cond\n");
    }



    return 0;
}



```





```cpp
pthread_mutex_t mutex; // 互斥锁
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);//互斥锁初始化，

int pthread_mutex_lock(pthread_mutex_t *mutex);//对互斥锁加锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
 
//线程互斥锁
//同一时间只有一个线程访问数据。互斥量(mutex)就是一把锁。

//多个线程只有一把锁一个钥匙，谁上的锁就只有谁能开锁。当一个线程要访问一个共享变量时，先用锁把变量锁住，然后再操作，操作完了之后再释放掉锁，完成。

//当另一个线程也要访问这个变量时，发现这个变量被锁住了，无法访问，它就会一直等待，直到锁没了，它再给这个变量上个锁，然后使用，使用完了释放锁，以此进行。
  
pthread_cond_t cond; // 条件变量
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);//初始化
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);//用于阻塞当前线程，等待别的线程使用pthread_cond_signal()或pthread_cond_broadcast来唤醒
pthread_cond_signal();//送一个信号给另外一个正在处于阻塞等待状态的线程,使其脱离阻塞状态,继续执行.如果没有线程处在阻塞等待状态,pthread_cond_signal也会成功返回。
  
//条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。条件变量是线程可用的另一种同步机制。

//条件本身是由互斥量保护的。线程在改变条件状态之前必须产生锁住互斥量，其他线程在获得互斥量之前不会到这种改变，因为互斥量必须在锁定以后才能计算条件。
 
// 共享内存函数（shmget、shmat、shmdt、shmctl）
shmget//得到一个共享内存标识符或创建一个共享内存对象
shmat//(把共享内存区对象映射到调用进程的地址空间)
```



```cpp
client
getopt// 获取名字
key_t ftok( char * fname, int id )
  //函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值，称为IPC键值（也称IPC key键值），系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过ftok函数得到。
int shmget( key_t, size_t, flag);
//成功获取到key之后，就可以使用该key作为shmget共享内存方法的进程间通信的key值， 返回共享内存的描述符
void *shmat(int shm_id, const void *shm_addr, int shmflg);
//第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。
pthread_mutex_lock()//互斥锁上锁
pthread_cond_signal()//激活等待列表中的线程，
pthread_mutex_unlock()// 解锁
 // pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变                   量满足条件，则会给线程上锁，继续执行pthread_cond_wait
```



```cpp
server
pthread_mutexattr_t// 互斥锁
pthread_mutexattr_init//   初始化互斥锁属性, 
pthread_mutexattr_setpshared//   互斥锁属性,指定是该进程与其他进程的同步
pthread_mutex_init//  动态的创建互斥锁
pthread_condattr_t //条件变量
pthread_condattr_init// 初始化条件变量属性
pthread_condattr_setpshared// 设置条件变量属性
pthread_cond_init// 动态初始化条件变量
pthread_cond_wait
```



实现了进程间通信，使用了共享内存、互斥锁、条件变量，客户端创建(shget)共享内存空间，绑定到(shmat)自身的地址，判断如果输入数据，就加锁pthread_mutex_lock，将信息拷贝共享内存空间，写入数据后，就向服务端发送一个信号pthread_cond_signal()，至少唤醒一个等待该条件的线程，解锁

服务端初始化互斥锁pthread_mutex_init、条件变量pthread_cond_init、上锁，阻塞等待pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，然后打印输出信息，memset清空内存，对互斥锁解锁



# 5.菜鸡春招面经成长之路



## 奇安信一面凉 C++服务器开发

由于第一次在牛客上视频面试，提前半小时来了直播间，然后有一个签到，

签到之后就有面试官了，当时我我也是懵逼了

准备了两天

上来先做一个自我介绍（主要是说简历）

然后问我哪块比较熟悉，就是自己觉得学的比较好

数据结构

说说一下常见的数据结构，介绍一下特点？

顺序表、链表、栈、队列、树、二叉树、BST、AVL、RBT。。。。

说一下红黑树的左旋？

此时的我已经有点紧张，我当时说了一个右旋方法，后来面试完才想起来



TCP、UDP优点缺点？

简单说一下TCP三次握手？

为什么是三次？

TCP三次握手过程中有一次失败会发生什么？

本来就紧张，然后就说了一个超时重传，

具体说一下，第二次、第三次没了会发生什么？



线程进程共享那些东西、线程独享哪些？

说一下死锁的四个必要条件？

用户态和内核态？(看我简历写了)

输入URL会发生什么，越详细越好？

脑子已经什么都没有了。。。然后那好吧差不多二十分钟了，就面道这里吧

后来面试完问的好简单，只有tcp三次握手没送达会发生什么不会，但是从那里不会就开始有点紧张，后面的就磕磕巴巴又紧张。

然后是反问

面试官说不要紧张，轻松一点没事。然后问了一个工作具体会做一些什么呀？

主要是做golang开发的，难怪没有问我c++，推荐大家面试前先看看这个公司的部门，如果可以的话可以了解一下部门是做什么的，可以预判一下面试官会问一些什么问题。二十分钟紧张就结束了



## 金美通信 C++开发

 hr面

做一下自我介绍

说了一遍简历

hr:普遍是电脑是吗，可以看出来您是在参考什么？

笑着说我这边是简历

 hr:把我的大多数问题都说了，那我们直接问一下其他问题吧

学校是一本还是二本？

学历有问题吗？可以毕业吗？

家里是哪里人？哪里人支持到北京吗？

技术面

项目

虚析构函数为什么必须是虚函数？

进程间通信方式？

计算机网络OSI七层模型都有哪些，每一层说一个协议？

ping用的是哪个协议？

STL用吗，map，set底层用什么实现？

socket如何实现通信，都有哪些函数？

遇到一个不会的问题怎么办？

虽然有点紧张，但是问的相对简单，所以基本上没什么问题，问的也相对简单



## 跟谁学|高途课堂 C++开发工程师

笔试题简单吧，5个过了三个

一面凉凉

自我介绍 

static关键字的作用

TCP、UDP区别

四次挥手

类的默认函数都有哪些?

类的构造和析构必须是虚函数吗？

STLvector、dequeue底层实现

vector如何释放内存

不太理解底层实现是什么鬼？说完vector,让我说dequeue,我说这个不会，好吧今天的面试结束了

马上学以一顿，不过这次心态超级好，没有紧张，还有遇到不会的可以往回的方向上说，比如我不太了解deque，可以说我了解set,底层用红黑树实现，搜索、移除、插入是拥有对数时间复杂度，map，底层通常用红黑树实现，他存储的是一个键值对，键值有序的，且唯一，

还有遇到会的一定要多说一点。(每次一个面试失败的小技巧)







## 中科创达

第一次记错时间了，当时是电话通知，我记到表格上，可能是记错了吧，然后hr和我说的时候我才知道记错了。然后安排第二次面试，然后他说是周一，然后给我发的周二的会议，然后我周二在会议室等了半小时，然后问hr，hr说我们约的是周一，然后我又没到。。。。认命了，可能是没缘分吧。





## 神策数据

笔试题忘了是什么，选择题和编程题吧

三个编程题都是暴力直接100%，有一个动态规划

一面

来一个自我介绍

先做一道题，在有序数组中去掉重复的数字，返回一共有多少个不重复的数字

迷迷糊糊的就过了，面完了也没看懂自己写的代码是什么意思，面试官让我解释代码，我说类似于快慢指针，

然后巴拉巴拉，他把我代码要走了，估计是过了，但是我说了一遍是什么意思，他可能没听懂。然后也没咋问我。

list,vector,set,map,实现原理和应用场景？(上次面试问到的，然后恶补了一下STL，问的都会，半天学会，也不是学会，是复习一下吧)

static有什么用?

C++为什么有虚构函数？

为什么有虚析构函数？

如何查看内存？是top吗?不会。。

那创建文件夹？mkdir

那说一个从服务器上远程复制吧？ scp

查看ip?ifconfig

进程间通信都有哪些？

线程中栈和堆都是共享吗？栈和堆的区别？

http,https的区别？说了一半，后面的忘了

然后提醒了我一下他两的端口都有啥？

443， 80(这个还不会，这个八股文面试前看见的)

那问一个实际情况的问题吧？100G限制数据内存100M，求top100?

典型topK问题，我说先把文件分开吧，他说怎么分，想了好久怎么分，

那假如已经分开呢，我说那可以用优先队列，排序树中序遍历也可以，100个节点，

然后反问？

怎么分啊？

确实需要分开，用哈希表分，每一个文件放一个单词（我想的是怎么把100G分开。。。方向错了）

这个工作会做什么呀？主要是大数据java,C++后端写什么高大上的东西我也听不懂，然后我说哦我们学校的课程就上过大数据hadoop,然后我会一些简单的用法

面试流程都有什么？两个技术面+hr吧

面试官好像挺着急走的，连着问我还有什么问题吗，可能要安排下一个面试吧？我说没有了，

可能是编程题做的时间比较短，面了40分钟左右就结束了，期待二面，菜鸡的我终于从八股文里面跳出来了

神策数据二面

因为这是最近的最后一次面试机会了吧，就搞得有点紧张，面试官人很好，一直听说有一种面试官看你紧张就会和帮你缓解一下紧张，我也是第一次遇到，运气真好，

问了一些vim的基本使用，都是不经常用的，然后我也忘得差不多了，(事后才反应过来应该说点自己会哪些命令)

说了一个递归创建文件夹，mkdir -p这个地方我说错了，其实紧张还是稍微有一点的

我说c++是自己学的，问我跟那里学的，我说就买的那种，然后问我名字，然后我说了，然后还问我有没有别的，我说了一个在B站学java的，有一个狂神说，

问我vim有没有安装插件，我说了一个最近安装了一个彩虹括号，其实我一般用vimplus,但是我当时就是没想起来了，好尴尬(感觉自己可能凉了吧，害，好事多磨吧)

问了一些数据，之前学linux命令，最近看到了这本书，我就说了鸟哥linux，然后问我看过哪块，我。。。好尴尬。这个好久没看了，，，

问了线程进程、僵尸进程,kill -9,kill

总结：其实面试官也不知道你会哪些，他只能试探你会哪里，然后继续深挖你会的地方，所以当面试官问到你不会的地方的时候，你要==主动表达自己会的地方==，引导面试官来问一些问题，这样证明你在这块学的还可以，让面试官认可你。增加自己面试成功的几率。

反问了，他说随便问，？

第一次遇到这么好的面试官，问了一些职业发展方向，问我为什么自己学c,项目有一个是用的c,其实是学校的，我以为所有的人都会c,我们大一的时候学的c,

我说c++还挺有意思的，我说学校学的是java，问我c++和java的区别，，都是一些自由的话题吧，不过也能看出一些个人对这个行业的了解和看法，毕竟思想是很重要的东西，我一直觉得

最后面试官电脑没电了，其实我还挺想和他唠一会的，面了不到三十分钟吧，被迫结束了。



## 浙江大华

体验不太好，刚开始是微信语言，对面网络不好，然后中途还接了几个电话，然后打电话继续聊，又接了一个电话，然后说我声音小，他问的问题让我产生了很多误解，就是自己想的和对面想的不一样，他说线程，我以为问的是线程函数，因为当时聊到了编程这块，然后其实他是想说线程的定义，我直接来了一个这块不经常用，进程用的多一点，然后他说了一个那说一下进程的定义吧。。。我这才反应过来。自然而然挂掉了。

最有意义的一个问题就是不用排序实现求第二个最大的元素？

## 上海英方软件

其实面这家的时候我都没有准备，毕竟面的有点自闭。然而面试官很好，我说对的时候，面试官总会说你这个说的挺好，那下一个。就这样总是会收到对面的反馈。挑了一个项目，问我那个比较好，挑一个，我觉得关于socket的项目能多说一点，然后就选了第二个，然后还问了一些其他的问题，还给我说了答案。第一次被问到很多关于C++的问题，其他的公司C++问的比较少。问到了智能指针，问到了虚函数的原理，我简历上写了，所以问了一下。问了一个阻塞，前面都没有问到，阻塞就是返回当前的一个状态，不管有没有结果。他说我这个答案说的很好。然后就是进程的五个基本状态，我漏掉了一个挂起，他提醒我，我说错了，然后告诉了我答案，挂起。属实忘了，还有死锁的四个必要条件。我答了三个，然后还有一个忘了，他还是说忘了没关系，我给你讲一下。第一次遇到这么好的面试官。其他的问题都是经常问到的。然后反问问了一些公司的基本情况。总之体验很好、

一面完事很快就收到了hr电话，说过了，然后说了一些公司的基本情况。说了四十分钟左右吧。然后hr下班了。我有收到了一个电话，说是技术二面，二面问了一些堆，栈，简单吧。上面都有了。说了一些项目的事情。然后说了一些部门都会干些什么。然后二十分钟左右吧，就结束了。下班了。

周一收到了offer,hr先是说你通过了技术面，基础过关，但是你没有什么项目，都是课上的小项目。然后我们还是认可你的。就这种，，，套路吧。然后就是说薪资可以给到9.5k，转正1.5k，其实搜过公司的薪资大概是11k,就这样被压了0.5.哈哈不至于吧。通过之后一个小时左右吧收到了小米的调剂信息，说北京急招，问我有没有意向。期待ing.

期间还面了一些小公司北京凝思、北京新方、拒绝了闻泰科技的面试，有一些公司面试就不会问很多技术问题，更多的是问一些学历和成绩上的问题。做过很多笔试吧，滴滴、海威康视、字节、东信北邮、好未来、WPS、网易、58、完美世界、美团。。。

总结：其实找工作也看缘分吧。就比如我吧，一直准备C++的内容，然而C++问的很少，毕竟有时候面试官可能是学别的语言的，然后只能扣其他的了。

持续更新ing













