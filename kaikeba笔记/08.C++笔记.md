

# 20210227

# 0.C++预习

## 1.helloworld



![截屏2020-11-01 下午6.57.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-01%20%E4%B8%8B%E5%8D%887.01.38.png)

![截屏2020-11-01 下午7.01.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-01%20%E4%B8%8B%E5%8D%887.01.38.png)

![截屏2020-11-01 下午7.02.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-01%20%E4%B8%8B%E5%8D%887.01.38.png)













![截屏2020-11-05 下午5.23.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.23.26.png)

![截屏2020-11-05 下午5.30.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.30.37.png)

![截屏2020-11-05 下午5.31.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%885.31.19.png)

![截屏2020-11-05 下午6.09.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-11-05%20%E4%B8%8B%E5%8D%886.09.34.png)





## 2.if



















## 3.循环





## 4. 函数与递归



 ![截屏2020-12-13 下午1.49.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.49.54.png)

![截屏2020-12-13 下午1.51.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.51.07.png)

![截屏2020-12-13 下午1.51.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.51.51.png)

![截屏2020-12-13 下午1.52.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.52.03.png)

![截屏2020-12-13 下午1.52.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.52.16.png)







## 5.类与对象



![截屏2020-12-10 上午11.32.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.32.30.png)

![截屏2020-12-10 上午11.32.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.32.47.png)

![截屏2020-12-10 上午11.33.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.33.00.png)

![截屏2020-12-10 上午11.34.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.34.11.png)

![截屏2020-12-10 上午11.34.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.34.31.png)

![截屏2020-12-10 上午11.35.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.35.44.png)

![截屏2020-12-10 上午11.36.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.36.17.png)

![截屏2020-12-10 上午11.36.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%8811.36.47.png)

![截屏2020-12-10 下午1.51.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%881.51.06.png)

![截屏2020-12-10 下午2.11.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%882.11.51.png)

![截屏2020-12-10 下午2.19.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%882.19.53.png)

![截屏2020-12-10 下午2.21.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%882.21.48.png)

![截屏2020-12-10 下午2.22.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%882.22.03.png)

![截屏2020-12-10 下午2.23.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%882.23.35.png)

![截屏2020-12-10 下午4.27.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.27.37.png)

![截屏2020-12-10 下午4.28.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.28.44.png)

![截屏2020-12-10 下午4.30.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.30.31.png)

![截屏2020-12-10 下午4.32.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.32.13.png)

![截屏2020-12-10 下午4.36.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.36.29.png)

![截屏2020-12-10 下午4.40.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.40.48.png)

![截屏2020-12-10 下午4.47.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.47.07.png)

![截屏2020-12-10 下午4.48.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.48.16.png)

![截屏2020-12-10 下午4.48.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.48.42.png)

![截屏2020-12-10 下午4.49.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.49.19.png)

![截屏2020-12-10 下午4.49.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%884.49.53.png)

![截屏2020-12-10 下午5.05.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8B%E5%8D%885.05.14.png)







```cpp
#include <iostream>
#include <cmath>
using std::cin;
using std::cout;
using std::endl;
class Point{
public:
    Point(int newX = 0,int newY = 0){
      x = newX;
      y = newY;
    }
    Point(Point &p){
      x = p.x;
      y = p.y;
    }
    int getX() {
          return x;
    }
    int getY() {
          return y;    
    }
private:
    int x,y;
};
class Line{
public:
    Line(Point new_p1, Point new_p2):p1(new_p1),p2(new_p2) {//构造函数
		double x = static_cast<double>(p1.getX() - p2.getX());
        double y = static_cast<double>(p1.getY() - p2.getY());
        len = sqrt(x * x + y * y);
}
    Line(Line &l):p1(l.p1),p2(l.p2){//复构函数
        len = l.len;
    }
    double getLen(){
        return len;
    }
private:
    Point p1, p2;
    double len;
};
int main(){
    Point pa(1, 2);
    Point pb(3, 5);
    Line L1(pa, pb);
    Line L2(L1);
    cout << "The length of L1 is " << L1.getLen() << endl;
    cout << "The length of L2 is " << L2.getLen() << endl;
    
    
    return 0;
}
```







![截屏2020-12-13 下午1.29.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.29.51.png)

![截屏2020-12-13 下午1.29.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.29.59.png)

![截屏2020-12-13 下午1.31.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.31.07.png)

![截屏2020-12-13 下午1.31.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.31.29.png)

![截屏2020-12-11 上午8.53.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-11%20%E4%B8%8A%E5%8D%888.53.28.png)















## 6.数组、字符串、二维数组

![截屏2020-12-13 下午12.29.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8812.29.08.png)





![截屏2020-12-13 下午1.01.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.01.34.png)

![截屏2020-12-13 下午1.13.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.13.12.png)

![截屏2020-12-13 下午1.14.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.14.15.png)

![截屏2020-12-13 下午1.14.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.14.54.png)

![截屏2020-12-13 下午1.18.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.18.27.png)







![截屏2020-12-13 下午1.01.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.01.34.png)

![截屏2020-12-13 下午1.13.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.13.12.png)

![截屏2020-12-13 下午1.14.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.14.15.png)

![截屏2020-12-13 下午1.14.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.14.54.png)

![截屏2020-12-13 下午1.18.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.18.27.png)

![截屏2020-12-13 下午1.19.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.19.59.png)













![截屏2020-12-13 下午12.32.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8812.55.34.png)

![截屏2020-12-13 下午12.55.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8812.55.34.png)



![截屏2020-12-13 下午1.35.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.35.09.png)

![截屏2020-12-13 下午1.36.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.36.06.png)







## 7.C语言风格的字符串与字符串操作





![截屏2020-12-13 下午1.46.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%881.46.16.png)

![截屏2020-12-13 下午2.08.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%882.08.01.png)

![截屏2020-12-13 下午2.09.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%882.09.32.png)

![截屏2020-12-13 下午4.07.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%884.07.53.png)









![截屏2020-12-13 下午11.33.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.33.02.png)

![截屏2020-12-13 下午11.36.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.36.34.png)

![截屏2020-12-13 下午11.37.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.37.03.png)

![截屏2020-12-13 下午11.40.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.40.39.png)

![截屏2020-12-13 下午11.42.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.42.24.png)

![截屏2020-12-14 上午12.28.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8812.28.41.png)

![截屏2020-12-14 上午12.28.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8812.28.49.png)















## 8.Vector与STL简单入门







![截屏2020-12-13 下午6.25.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%886.32.28.png)

![截屏2020-12-13 下午6.28.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%886.32.28.png)

![截屏2020-12-13 下午6.32.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%886.32.28.png)





```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int m;
    int n;
    cin>>m>>n;
    vector<vector<int>> matrix_a(m);
    vector<vector<int>> matrix_b(n);

    int input;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> input;
            matrix_a[i].push_back(input);
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> input;
            matrix_b[i].push_back(input);
        }
    }
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < m; ++j) {
            int s = 0;
            for (int k = 0; k < n; k++) {
                s = s + matrix_a[i][k] * matrix_b[k][j];
            }
            if(j != 0) {
                cout << " ";
            }
            cout << s;
        }
        cout << endl;
    }
    
    
    
    return 0;
}
```









![截屏2020-12-13 下午9.36.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%889.36.04.png)





```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string input;
    cin >> input;
    
    cout << input << endl;
    cout << input.length() << endl;//输出字符串涨肚
    cout << input[0] << endl;//重载的括号运算符

    string str = "yangzhou301";
    auto result = input + str;//自动类型 推导
    cout << result << endl;
    cout << (result < str) << endl;

    return 0;
}
```





![截屏2020-12-13 下午11.22.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.22.01.png)





![截屏2020-12-13 下午11.24.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.24.40.png)

![截屏2020-12-13 下午11.29.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.29.28.png)

![截屏2020-12-13 下午11.30.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-13%20%E4%B8%8B%E5%8D%8811.30.08.png)







## 9.指针与内存与对象的指针成员

![截屏2020-12-14 上午1.55.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.55.05.png)

![截屏2020-12-14 上午1.43.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.43.38.png)

![截屏2020-12-14 上午1.53.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.53.09.png)

![截屏2020-12-14 上午1.54.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.54.34.png)

![截屏2020-12-14 上午1.55.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.55.13.png)

![截屏2020-12-14 上午1.55.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.55.52.png)

![截屏2020-12-14 上午1.56.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.56.53.png)

![截屏2020-12-14 上午1.57.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.57.32.png)

![截屏2020-12-14 上午1.58.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%881.58.41.png)

![截屏2020-12-14 上午2.00.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.00.20.png)

![截屏2020-12-14 上午2.02.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.02.09.png)

![截屏2020-12-14 上午2.02.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.02.30.png)

![截屏2020-12-14 上午2.12.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.12.53.png)

![截屏2020-12-14 上午2.13.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.13.36.png)

![截屏2020-12-14 上午2.17.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.17.41.png)

![截屏2020-12-14 上午2.18.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.18.27.png)

![截屏2020-12-14 上午2.19.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.19.10.png)

![截屏2020-12-14 上午2.20.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.20.20.png)

![截屏2020-12-14 上午2.21.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.21.03.png)

![截屏2020-12-14 上午2.21.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.21.38.png)

![截屏2020-12-14 上午2.22.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.22.33.png)

![截屏2020-12-14 上午2.24.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.24.37.png)

![截屏2020-12-14 上午2.25.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.25.31.png)

![截屏2020-12-14 上午2.26.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.26.46.png)

![截屏2020-12-14 上午2.27.21](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.27.21.png)

![截屏2020-12-14 上午2.28.12](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.28.12.png)

![截屏2020-12-14 上午2.30.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.30.35.png)

![截屏2020-12-14 上午2.31.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.31.50.png)

![截屏2020-12-14 上午2.32.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.32.46.png)

![截屏2020-12-14 上午2.34.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.34.06.png)

![截屏2020-12-14 上午2.34.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%882.34.35.png)



![截屏2020-12-14 上午9.09.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.09.48.png)

![截屏2020-12-14 上午9.14.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.14.15.png)

![截屏2020-12-14 上午9.16.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.16.46.png)

![截屏2020-12-14 上午9.17.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.17.50.png)

![截屏2020-12-14 上午9.22.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.22.52.png)

![截屏2020-12-14 上午9.24.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.24.59.png)

![截屏2020-12-14 上午9.26.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.26.51.png)

![截屏2020-12-14 上午9.28.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.28.44.png)

![截屏2020-12-14 上午9.28.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.28.47.png)

![截屏2020-12-14 上午9.28.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.28.53.png)

![截屏2020-12-14 上午9.36.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%889.36.08.png)

![截屏2020-12-14 上午12.55.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8812.55.04.png)

![截屏2020-12-14 上午12.58.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8812.58.52.png)

![截屏2020-12-14 上午12.59.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8812.59.30.png)







## 10、C/C++风格





![截屏2020-12-14 下午3.45.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.45.42.png)

![截屏2020-12-14 下午3.46.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.46.48.png)

![截屏2020-12-14 下午3.50.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.50.40.png)

![截屏2020-12-14 下午3.51.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.51.59.png)

![截屏2020-12-14 下午3.52.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.52.59.png)

![截屏2020-12-14 下午3.53.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.53.49.png)

![截屏2020-12-14 下午3.54.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.54.39.png)

![截屏2020-12-14 下午3.57.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%883.57.15.png)

![截屏2020-12-14 下午4.16.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.16.44.png)

![截屏2020-12-14 下午4.22.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.22.17.png)

![截屏2020-12-14 下午4.22.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.22.55.png)

![截屏2020-12-14 下午4.24.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.24.25.png)

![截屏2020-12-14 下午4.24.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.24.37.png)

![截屏2020-12-14 下午4.26.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.26.56.png)

![截屏2020-12-14 下午4.27.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.27.33.png)

![截屏2020-12-14 下午4.28.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.28.40.png)

![截屏2020-12-14 下午4.30.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.30.10.png)









## 11、























## C++标准模板库

1.迭代器



![截屏2020-12-14 下午4.55.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.55.45.png)





![截屏2020-12-14 下午4.58.44](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%884.58.44.png)























# 1. 从C到C++



> **注：PPT来至于开课吧胡船长PPT,请注意版权**



## 1.1 C++

C++03—>C++11(差距大)—>c++14—>c++17(差距小)—>c++20(最新版)





C++继承了C语言的一部分(标准头文件)

标准头文件

![截屏2021-02-28 上午10.06.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8A%E5%8D%8810.06.28.png)

类和对象：为了支持类和对象编程范式

模板：支持泛型编程

Lamba:支持函数式编程

STL：惠普工程师开发的c++，后来纳入C++标准



> C++支持面向过程、面向对象编程、泛型编程、函数式编程，四种编程范式



编程范式：提高开发效率

异常处理机制：解决奔溃退出的场景



面向对象比面向过程更好维护







## 1.2 C++学习重点



|              | C语言 |      | C++语言 |
| ------------ | ----- | ---- | ------- |
| 面向过程编程 | **√** |      | **√**   |
| 面向对象编程 | **×** |      | **√**   |
| 泛型编程     | **×** |      | **√**   |
| 函数式编程   | ×     |      | **√**   |



> 如何学习？
>
> 按照编程范式分类学习



书籍：C++Primer、C++Primer Plus、Effective C++(改善程序设计的55个具体做法)





## 1.3 程序对比



![截屏2021-02-28 上午10.51.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8A%E5%8D%8810.51.55.png)



## 1.4 queue 类说明

![截屏2021-02-28 上午10.56.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8A%E5%8D%8810.56.37.png)



## 1.5 deque

![截屏2021-02-28 下午1.26.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%881.26.30.png)





## 1.6 string 

![截屏2021-02-28 下午3.33.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.33.24.png)



## 1.7 undered_map

![截屏2021-02-28 下午3.35.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.35.10.png)

unordered_map:无序，底层用哈希表实现

map:底层用红黑树实现

## 1.8 编码规范

![截屏2021-02-28 下午3.35.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.35.32.png)





## 1.9 Effective C++

![截屏2021-02-28 下午3.53.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.53.19.png)

![截屏2021-02-28 下午3.53.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.53.28.png)

![截屏2021-02-28 下午3.58.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%883.58.29.png)



```cpp
#include <iostream>
using namespace std;

class A{
public:
    A() {
        x = 123;
        y = 0;
        z = 0;
    }
    void say1() const {
        cout << x << endl;
        //x = 2344;//不能修改
        //assignment of member 'A::x' in read-only object
        //y += 1;//不能修改
        //assignment of member 'A::y' in read-only object
        z += 1;//逻辑意义上的const
    }
    void say2() {
        x = 456;//非const方法可以修改数据
    }
    int x;
    //int y;//say1()方法被调用了多少次
  	mutable int z;//say1()方法被调用了多少次
};


int main() {
    const int a = 1;//数据上的const
    //a = 3;//assignment of read-only variable 'a'

    const A b;
    b.say1();
    //b.say2();
    //const类型变量只能调用const方法，其他方法可能会修改数据，所以不能被调用
    //passing 'const A' as 'this' argument discards qualifiers [-fpermissive]
  	b.say1();
    b.say1();
    b.say1();
    b.say1();
    b.say1();

    return 0;
}
```



```cpp
0
1
2
3
4
```



核心的数据没有变就是逻辑上的常量(const)



![截屏2021-02-28 下午4.50.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-28%20%E4%B8%8B%E5%8D%884.50.00.png)



```cpp
#include <iostream>
using namespace std;

class A{
public:
    A() : x(123), y(x - 1) {}//实际顺序=代码书写顺序
    #if 0
  	A() : y(x - 1), x(123) {//构造，  按顺序赋值，避免出现代码逻辑上的bug,
        //x = 123;//赋值
        //y = 0;
    }//可能会出错
  	#endif
    void say1() const {
        cout << "x = " << x << ", y = " << y << endl;
    }
    int x;
    int y;
};


int main() {
    A a;
    a.say1();


    return 0;
}
```





## 练习1:haizeioj166 string类的使用

![截屏2021-03-01 下午1.29.07](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%881.29.07.png)

![截屏2021-03-01 下午1.29.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%881.29.15.png)



```cpp
#include <iostream>
#include <string>
 

using namespace std;

int main() {
    string s1, s2;
    int n;
    cin >> s1 >> n >> s2;
    if (s1.size() < 100) cout << s1.size() << endl;
    else cout << 100 << endl;
    s1.insert(n - 1, s2);
    cout << s1 << endl;
    cout << s1.size() - s1.rfind("x") << endl;
    return 0;
}

```



## 练习2:haizeioj245 c++排序功能

![截屏2021-03-01 下午1.48.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%881.48.09.png)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr;
    int n;
    cin >> n;
    for (int i = 0, a; i < n; i++) {
        cin >> a;
        arr.push_back(a);
    }
    sort(arr.begin(), arr.end());
    //nth_element();
    int pos = arr[n / 2];
    int sum = 0;
    for (int i = 0; i < arr.size(); i++) {
        sum += abs(arr[i] - pos);
    }
    cout << sum << endl;


    return 0;
}
```



## 练习3：haizeioj216 c++排序 map

![截屏2021-03-01 下午2.13.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%882.13.37.png)

![截屏2021-03-01 下午2.13.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%882.13.46.png)

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    string s;
    map<string, int> h;
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s;
        h[s.substr(3, s.size())] += 1;
    }

    for (auto iter = h.begin(); iter != h.end(); iter++) {
        for (int i = 0; i < iter->second; i++)  cout << iter->first << endl;
    }
    return 0;
}
```





## 作业3：haizeioj287 合并果子

![截屏2021-03-01 下午2.38.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%882.38.08.png)

![截屏2021-03-01 下午2.38.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-01%20%E4%B8%8B%E5%8D%882.38.20.png)



```cpp
#include <iostream>
#include <queue>
using namespace std;

struct CMP {
public:
    bool operator()(int a, int b) {
        return a > b;
    }//重载优先队列排序规则
};

int main() {
    priority_queue<int, vector<int>, CMP> q;//优先队列
    int n;
    cin >> n;
    for (int i = 0, a; i < n; i++) {
        cin >> a;
        q.push(a);
    }
#if 0
    while (!q.empty()) {
        cout << q.top() << endl;
        q.pop();
    }
#endif
    int sum = 0;
    for (int i = 1; i < n; i++) {
        int a = q.top(); q.pop();
        int b = q.top(); q.pop();
        sum += a + b;
        q.push(a + b);
    }
    cout << sum << endl;

    return 0;
}
```



## 练习4：haizei256. 国王游戏

![截屏2021-03-02 下午6.05.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-02%20%E4%B8%8B%E5%8D%886.05.20.png)

![截屏2021-03-02 下午6.05.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-02%20%E4%B8%8B%E5%8D%886.05.37.png)



![截屏2021-03-02 下午5.45.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-02%20%E4%B8%8B%E5%8D%885.45.46.png)



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <algorithm>
using namespace std;



typedef pair<int, int> PII;

class BigInt : public vector<int> {
public:
    BigInt(int x) {
        push_back(x);
        proccess_digit();
    }
    void operator*=(int x);
    void operator/=(int x);
    BigInt operator/(int x);
    bool operator<(const BigInt &) const;
    bool operator>(const BigInt &) const;
private:
    void proccess_digit();
};
#if 0
BigInt::BigInt(x) {
    push_back(x);
    proccess_digit();
}
#endif

ostream &operator<<(ostream &out, const BigInt &a) {//重载左移运算符
    for (int i = a.size() - 1; i >= 0; i--) {
        out << a[i];
    }
    return out;
}

void BigInt::proccess_digit() {//处理进位
    for (int i = 0; i < size(); i++) {
        if (at(i) < 10) continue;
        if (i + 1 == size()) push_back(0);
        at(i + 1) += at(i) / 10;
        at(i) %= 10;
    }
    while (size() > 1 && at(size() - 1) == 0) pop_back();
    return ;
}

void BigInt::operator*=(int x) {// *=
    for (int i = 0; i < size(); i++) at(i) *= x;
    proccess_digit();
    return ;
}

void BigInt::operator/=(int x) {
    int y = 0;
    for (int i = size() - 1; i >= 0; i--) {// /=
        y = y * 10 + at(i);
        at(i) = y / x;
        y %= x;
    }
     proccess_digit();   
     return ;
}

BigInt BigInt::operator/(int x) {//除法
    BigInt ret(*this);
    ret /= x;
    return  ret;
}

bool BigInt::operator<(const BigInt &a) const{
    if (size() - a.size()) return size() < a.size();//位数不相同，直接返回
    for (int i = size() - 1; i >= 0; i--) {
        if (at(i) - a[i]) return at(i) < a[i];
    }
    return false;
}

bool BigInt::operator>(const BigInt &a) const {
    return a < (*this);
}

int main() {
    vector<PII> arr;
    int n;
    cin >> n;

    for (int i = 0, a, b; i <= n; i++) {
        cin >> a >> b;
        arr.push_back(PII(a, b));
    }
    sort(arr.begin() + 1, arr.end(), 
         [](const PII &x, const PII &y){ 
            return x.first * x.second < y.first * y.second; 
         }
    );

    BigInt p = arr[0].first;//当前累乘结果
    BigInt ans = 0;//获得最多金币者获得多少金币

    for (int i = 1; i <= n; i++) {
        BigInt temp = p / arr[i].second;
        ans = max(ans, temp);
        p *= arr[i].first;
    }

    cout << ans << endl;

    
    return 0;
}


```





## 作业1:nth_element()

```cpp
nth_element()
```



> 通过调用nth_element(start, start+n, end)
> 方法可以使第n大元素处于第n位置（从0开始,其位置是下标为n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的，默认用 `<` 运算符来生成这个结果

eg:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
 
int main()
{
    std::vector<int> v{5, 6, 4, 3, 2, 6, 7, 9, 3};
 
    std::nth_element(v.begin(), v.begin() + v.size()/2, v.end());
    std::cout << "The median is " << v[v.size()/2] << '\n';
    for (int i = 0; i < v.size(); i++) std::cout << v[i] << " ";
    std::cout << std::endl;
 
    std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater<int>());
    std::cout << "The second largest element is " << v[1] << '\n';
    for (int i = 0; i < v.size(); i++) std::cout << v[i] << " ";
    std::cout << std::endl;
}

```

结果分析

```
The median is 5
3 2 3 4 5 6 7 9 6 
The second largest element is 7
9 7 6 6 5 3 4 3 2 
```

第一中用法处于第`v.begin()+v,size()/2=5`位置的元素是5，输出排序结果，前面的都比5小，后面的都比5大，但是我们没有顺序

第二种用法修改了排序方法，默认的从小到大，

nth_element(begin, begin+n,end,std::greater<int>());修改成从大到小的规律













## 作业2:string三种方法相关解释和代码演示



string::find_first_of函数搜寻参数字符串中 的出现。





```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str = "I am  guziqiu. I don't like c++.";
    string name = "我是古子秋!";
    
    
    cout << "1.find(am):" << str.find("am") << endl;
    str.insert(0,name);
    cout << "2.insert(name):" << str << endl;
    cout << "3.substr(9, 10):" << str.substr(9, 10) << endl;
    cout << endl;

    str.append(name);
    cout << str << endl;

    int i = 7;
    
    str.replace(str.find(" "), 1, "%20");
    cout << "4.删除从str.find()开始的1个字符，然后在str.find()处插入串%20" <<  endl;
    cout << str << endl;
    cout << "5.swap(name)，互换name和str的内容：";
    str.swap(name);
    cout << "str = " << str << "name = " << name << endl;
    cout << "6.assign(asd)修改str内容为asd:";
    str.assign("asd");
    cout << str << endl;
    return 0;
}
```



```cpp
1.find(am):2
2.insert(name):我是古子秋!I am  guziqiu. I don't like c++.
3.substr(9, 10):子秋!I a

我是古子秋!I am  guziqiu. I don't like c++.我是古子秋!
4.删除从str.find()开始的1个字符，然后在str.find()处插入串%20
我是古子秋!I%20am  guziqiu. I don't like c++.我是古子秋!
5.swap(name)，互换name和str的内容：str = 我是古子秋!name = 我是古子秋!I%20am  guziqiu. I don't like c++.我是古子秋!
6.assign(asd)修改str内容为asd:asd
```







## 作业3：讨论合并果子和哈夫曼编码的关系



哈弗曼编码是选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树, 且置新的二叉树的根结点的权值为左右子树根结点的权值之和。而合并果子每次选择两个水果堆数量最少的堆进行合并，可以看出哈夫曼编码和合并水果的方法是完全相同的，都是从一堆数字中选择两个最小的数字相加，然后将它们放回堆中。

![截屏2021-03-11 下午12.03.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-11%20%E4%B8%8B%E5%8D%8812.03.16.png)





# 2.封装



## 2.1 类和对象

![截屏2021-03-03 上午10.05.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-03%20%E4%B8%8A%E5%8D%8810.05.16.png)



> 类型 = 数据==类型== + 数据==操作==
>
> 数据结构 = 数据定义 + 结构操作



![截屏2021-03-03 上午10.30.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-03%20%E4%B8%8A%E5%8D%8810.30.56.png)

![截屏2021-03-03 上午10.31.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-03%20%E4%B8%8A%E5%8D%8810.31.39.png)

![截屏2021-03-03 上午10.33.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-03%20%E4%B8%8A%E5%8D%8810.33.55.png)





使用using namespace std



## 2.2 代码演示

```cpp
#include <iostream>
#include <string>
using std::cout;
using std::cin;
using std::endl;
using std::string;

class Cat {};

class Dog {};

class People {//默认访问权限是private，类内部
public:
    string name;
    int age;
    double height;
    double weight;
    
    void say(string name);//声明
#if 0
    void say() {//实现在内部
        cout << "my name is " << name << endl;
    }
#endif
    void run();
};

void People::say(string name) {//实现在外部
    cout << "     this = " << this << endl;//this指针，只能在成员方法内部访问,发现this指针指向对象的地址
    cout << "my name is " << this->name << " " << name << endl;
    //this指针强调使用的成员属性,this->name成员属性，name指参数
}

int main() {
    People guziqiu;
    People apricity;

    guziqiu.name = "古子秋";//类外部,默认访问权限是private， 类外部不会访问，需要加上public
    apricity.name = "Apricity";

    cout << " &guziqiu = " << &guziqiu << endl;
    guziqiu.say("aha");
    cout << "&apricity = " << &apricity << endl;
    apricity.say("aha");

    Cat cat;
    
    return 0;
}
```



```cpp
//运行结果
 &guziqiu = 0x7ffee72c47c0
     this = 0x7ffee72c47c0
my name is 古子秋 aha
&apricity = 0x7ffee72c4780
     this = 0x7ffee72c4780
my name is Apricity aha
```





## 命名空间

> ### 什么是命名空间？

命名空间就像是很多不同的家庭，不同的人放在不同的家庭，命名空间区分不同家庭的张三。可以认为class是一个特殊的命名空间，eg:

```cpp
#include <iostream>
#include <string>
using std::cout;
using std::cin;
using std::endl;
using std::string;

namespace haizei{
    class Cat {};

    class Dog {};

    class People {//默认访问权限是private，类内部
    public:
        string name;
        int age;
        double height;
        double weight;
        
        void say(string name);//声明
        #if 0
        void say() {//实现在内部
            cout << "my name is " << name << endl;
        }
        #endif
        void run();
    };

    void People::say(string name) {//实现在外部
        cout << "     this = " << this << endl;//this指针，只能在成员方法内部访问,发现this指针指向对象的地址
        cout << "my name is " << this->name << " " << name << endl;
        //this指针强调使用的成员属性,this->name成员属性，name指参数
    }
}// end of haizei

using namespace haizei;
int main() {
    haizei::People guziqiu;//写法1  ==> People::say People  是特殊的命名空间
    People apricity;//写法2，使用using namespace haizei; 不提倡

    guziqiu.name = "古子秋";//类外部,默认访问权限是private， 类外部不会访问，需要加上public
    apricity.name = "Apricity";

    cout << " &guziqiu = " << &guziqiu << endl;
    guziqiu.say("aha");
    cout << "&apricity = " << &apricity << endl;
    apricity.say("aha");

    haizei::Cat cat;
    
    return 0;
}


```



## 2.3 实现简单的cout



```cpp
#include <iostream>
#include <cstdio>

#define BEGINS(x) namespace x {
#define ENDS(x) } // namespace x
BEGINS(haizei)

class ostream {
public : 
    ostream &operator<<(int x);
    ostream &operator<<(const char *x);
};

ostream &ostream::operator<<(int x) {
    printf("%d", x);
    return *this;
}
ostream &ostream::operator<<(const char *x) {
    printf("%s", x);
    return *this;
}

ostream cout; 

ENDS(haizei)

int main() {
    int n = 123, m = 456;
    std::cout << n << " " << m; std::cout << std::endl;
    haizei::cout << n << " " << m; std::cout << std::endl;
    
    return 0;
}


```





> cout本质是什么？
>
> 接在左移运算符左侧，是一个对象
>
> 有返回值
>
> 



## 2.4 构造函数与析构函数



![截屏2021-03-06 上午8.41.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-06%20%E4%B8%8A%E5%8D%888.41.55.png)

构造函数：负责函数初始化

析构函数：负责函数销毁



任何对象的生命周期一个会调用构造函数，最后一定调用析构函数。



## 2.5 代码演示



### C++学习重点:程序的处理流程



### 1.析构和构造

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};

int main() {
    A a;
    A b;
    
    cout << "a : " << &a << endl;
    cout << "b : " << &b << endl;
    cout << "end of main" << endl;
    return 0;
}


```



```cpp
0x7ffeedbc85df constructor()
0x7ffeedbc85de constructor()
a : 0x7ffeedbc85df
b : 0x7ffeedbc85de
end of main
0x7ffeedbc85de ~destructor()
0x7ffeedbc85df ~destructor()
```



> 先定义先构造，构造的时候B对象可能依赖A对象的信息， 
>
> 先定义后析构，B析构的时候可能依赖于A对象的信息



### 2.转换构造:在初始化时

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    A(int x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    A &operator=(const A &a) {
        cout << this << " : operator=" << endl;
        return *this;
    }

    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};

int main() {
    A c(3);
    A d = 4;// 转换构造， 一般相同类型的才能赋值，赋值给一个对象，说明把这个值转换成了一个A类型，也就是转换构造
    cout << "c : " << &c << endl;
    cout << "d : " << &d << endl;
    cout << "end of main" << endl;
    return 0;
}


```

```cpp
0x7ffeea7625df : transform constructor
0x7ffeea7625de : transform constructor
c : 0x7ffeea7625df
d : 0x7ffeea7625de
end of main
0x7ffeea7625de ~destructor()
0x7ffeea7625df ~destructor()
```



> 转换构造， 一般相同类型的才能赋值，赋值给一个对象，说明把这个值转换成了一个A类型，也就是转换构造



### 3.对象赋值：初始化后的赋值操作

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    A(int x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    A &operator=(const A &a) {
        cout << this << " : operator=" << endl;
        return *this;
    }
    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }
private:

};

int main() {
    A a;
    a = 3;// 转换成临时匿名对象 x(调用转换构造),然后绑定到a,最后this指向main函数中的a
    cout << "a : " << &a << endl;
    cout << "end of main" << endl;
    return 0;
}


```



```cpp
0x7ffee5a575de constructor()
0x7ffee5a575df : transform constructor//临时匿名对象
0x7ffee5a575de : operator=
0x7ffee5a575df ~destructor()//临时匿名对象
a : 0x7ffee5a575de
end of main
0x7ffee5a575de ~destructor()
```



> 转换成零时匿名对象 x(调用转换构造),然后绑定到a,最后this指向main函数中的a





### 4.拷贝构造

```cpp
#include <iostream>
using namespace std;
void add_one(int x) {
    x += 1;
    return ;
} 
void add_one1(int &x) {// C++C++&：相当于给变量起别名 ，传引用不产生拷贝行为
    x += 1;
    return ;
} 

int main() {
  
    int n = 3;
    add_one(n);
    cout << n << endl;
    add_one1(n);
    cout << n << endl;
    return 0;
}
```

```
3
4
```





```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    A(int x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    A &operator=(const A &a) {
        cout << this << " : operator=" << endl;
        return *this;
    }

    A(A a1) {}// 此处会报错
   
    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};

int main() {
    A a;
    A b = a;// 定义行：此处不论是写A b = a;或者A b(a); 都会调用拷贝构造
    return 0;
}


```



> 为什么会报错？
>
> 调用b对象的拷贝构造， b对象的拷贝构造需要传一个参数a1, 也就是 a1 = a,这个过程会调用a1的拷贝构造A(A a1) {}
>
>  a1的拷贝构造调用a1的拷贝构造，造成死循环，



正确写法

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    A(int x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    A &operator=(const A &a) { // 对象赋值
        cout << this << " : operator=" << endl;
        return *this;
    }

    // A(A a1) {}
    A(const A &a) { // 避免传过来的变量是一个临时变量
        cout << this << " : copy constructor" << endl;;
    }



    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};


int main() {

  
    A a;
    A b = a;// 定义行：此处不论是写A b = a;或者A b(a); 都会调用拷贝构造
    b = a;// 调用赋值运算符
    // 调用b对象的拷贝构造， b对象的拷贝构造需要传一个参数a1, 也就是 a1 = a,这个过程会调用a1的拷贝构造A(A a1) {}
    // a1的拷贝构造调用a1的拷贝构造，造成死循环，
    // 拷贝构造不能用值传递
    // 传引用不产生拷贝行为

    cout << "a : " << &a << endl;
    cout << "b : " << &b << endl;
    cout << "end of main" << endl;
    return 0;
}


```



```cpp
0x7ffee903b5df constructor()
0x7ffee903b5de : copy constructor
0x7ffee903b5de : operator=
a : 0x7ffee903b5df
b : 0x7ffee903b5de
end of main
0x7ffee903b5de ~destructor()
0x7ffee903b5df ~destructor()
```





> `A b = a;`   定义行：此处不论是写A b = a;或者A b(a); 都会调用拷贝构造
>
>  `b = a;`          调用赋值运算符
>
>  调用b对象的拷贝构造， b对象的拷贝构造需要传一个参数a1, 也就是 a1 = a,这个过程会调用a1的拷贝构造A(A a1) {}
>
> ​     a1的拷贝构造调用a1的拷贝构造，造成死循环，
>
> ​     拷贝构造不能用值传递
>
> ​     传引用不产生拷贝行为

   

> 为什么是拷贝构造的参数要加const？
>
> 处理传过来的参数是const类型

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " constructor()" << endl;
    }
    A(int x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    const A &operator=(const A &a) const {
        cout << this << " : operator=" << endl;
        return *this;// 返回const类型指针
    }

    // A(A a1) {}
    A(const A &a) { // 避免传过来的变量是一个临时变量,同时也可以处理传过来的参数是const类型
        cout << this << " : copy constructor" << endl;;
    }



    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};

void add_one(int x) {
    x += 1;
    return ;
} 
void add_one1(int &x) {// 传引用不产生拷贝行为
    x += 1;
    return ;
} 

int main() {

    const A a;
    A b = a;
    A c = 3;
    return 0;
}


```





### 5.深拷贝和浅拷贝



#### 浅拷贝

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

class Array {
public:
    Array(int n = 10) {
        this->n = n;
        data = new int[n]; 
      // new会调用构造函数，new是运算符,可以重载（malloc不会调用构造函数，malloc是函数）
    }
    size_t size() const {
        return this->n;
    }

    int &operator[](int ind) {
        if (ind < 0 || ind >= n) return end;
        return data[ind];
    }

    const int &operator[](int ind) const {
        if (ind < 0 || ind >= n) return this->end;
        return this->data[ind];
    }
    
private:
    int *data;
    size_t n;
    int end;
};

ostream &operator<<(ostream &out, const Array &a) {// const 类型的引用只能调用const类型的方法
    out << "Array(" << &a << ") : ";
    for (int i = 0; i < a.size(); i ++) {  
        i && out << " ";
        cout << a[i];
    }
    return out;
}


int main() {

    Array a;
    for (int i = 0; i < a.size(); i++) {
        a[i] = rand() % 100;
    }

    cout << a << endl;

    Array b = a;
    cout << b << endl;
    b[1] = 16384;
    cout << a << endl;
    cout << b << endl;


    return 0;
}

```



```cpp
Array(0x7ffee51d65c0) : 7 49 73 58 30 72 44 78 23 9
Array(0x7ffee51d65a0) : 7 49 73 58 30 72 44 78 23 9
Array(0x7ffee51d65c0) : 7 16384 73 58 30 72 44 78 23 9
Array(0x7ffee51d65a0) : 7 16384 73 58 30 72 44 78 23 9
```



> 现象：修改b对象的值后a对象的值也改变了
>
> 为什么？
>
> 经行了简单的赋值(默认的拷贝构造，实现的是浅拷贝)，data类型是指针，他们指向同一个地址，所以他们的值同时改变了



#### 深拷贝

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

class Array {
public:
    Array(int n = 10) {
        this->n = n;
        data = new int[n]; // new会调用构造函数，new是运算符,可以重载（malloc不会调用构造函数，malloc是函数）
    }
    Array(const Array &a) { // 深拷贝
        this->n = a.n;
        this->data = new int[this->n];
        for (int i = 0; i < this->n; i++) {
            this->data[i] = a.data[i];
        }
    }
    size_t size() const {
        return this->n;
    }

    int &operator[](int ind) {
        if (ind < 0 || ind >= n) return end;// 访问数组越界
        return data[ind];
    }

    const int &operator[](int ind) const {
        if (ind < 0 || ind >= n) return this->end;// 访问数组越界
        return this->data[ind];
    }
    
private:
    int *data; // 存储数据
    size_t n;		// 数组大小
    int end;		// 数组访问越界返回end
};

ostream &operator<<(ostream &out, const Array &a) {// const 类型的引用只能调用const类型的方法
    out << "Array(" << &a << ") : ";
    for (int i = 0; i < a.size(); i ++) {  
        i && out << " ";
        cout << a[i];
    }
    return out;
}


int main() {

    Array a;
    for (int i = 0; i < a.size(); i++) {
        a[i] = rand() % 100;
    }

    cout << a << endl;

    Array b = a;
    cout << b << endl;
    b[1] = 16384;
    cout << a << endl;
    cout << b << endl;


    return 0;
}

```

```cpp
Array(0x7ffee881e5c0) : 7 49 73 58 30 72 44 78 23 9
Array(0x7ffee881e5a0) : 7 49 73 58 30 72 44 78 23 9
Array(0x7ffee881e5c0) : 7 49 73 58 30 72 44 78 23 9
Array(0x7ffee881e5a0) : 7 16384 73 58 30 72 44 78 23 9
```



> 拷贝的时候为新的对象申请了新的空间



### 6. 功能上的构造和编译器所谓的构造



```cpp
Array(int n = 10) {
        this->n = n;
        data = new int[n]; 
}
```



> 功能上的构造：需要执行完第4行
>
> 编译器所谓的构造： 需要执行完第一行代码，执行完第一行后变量就可以使用了



```cpp
#include <iostream>
using namespace std;

class Data { // 数据类
public:  

    // Data(int x, int y) {// 没有默认构造，当添加了有参构造的时候，编译器默认添加的无参构造就会被删除，
    //     this->x = x;
    //     this->y = y;
    // }
    Data(int x, int y) : x(x), y(y) {}// 在构造列表初始化，保证在大括号之内已经构造完对象


private:
    int x, y;
};



class A {
public:
    Data d;
    A() : d(3, 4){// :d(3, 4) 初始化列表，初始化对象的每一个属性，初始化列表执行完后，对象已经构造完了
        this->d;
        cout << this << " constructor()" << endl;
    }
    A(int x) : d(x, x) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    A(const A &a) : d(a.d) { 
        cout << this << " : copy constructor" << endl;;
    }

    const A &operator=(const A &a) const {
        cout << this << " : operator=" << endl;
        return *this;
    }

    ~A() { 
        cout << this <<" ~destructor()" << endl;
    }

private:

};
 

int main() {
    return 0;
}


```





> 没有默认构造，当添加了有参构造的时候，编译器默认添加的无参构造就会被删除
>
> 在构造列表初始化，保证在大括号之内已经构造完对象
>
> `A() : d(3, 4){ // :d(3, 4)` 初始化列表，初始化对象的每一个属性，初始化列表执行完后，对象已经构造完了,确保可以在大括号内调用



### 7.初始化列表



```cpp
#include <iostream>
using namespace std;

class Data { // 数据类
public:  

    // Data(int x, int y) {// 没有默认构造，当添加了有参构造的时候，编译器默认添加的无参构造就会被删除，
    //     this->x = x;
    //     this->y = y;
    // }
    Data(int x, int y) : x(x), y(y) {
        cout << this << endl;
    }// 在构造列表初始化，保证在大括号之内已经构造完对象
private:
    int x, y;
};



class A {
public:
    Data c, d;
    A() : d(3, 4), c(3, 4) {
      // :d(3, 4) 初始化列表，初始化对象的每一个属性，初始化列表执行完后，对象已经构造完了
        cout << this << " constructor()" << endl;
        cout << " c : " << &c << endl;
        cout << " d : " << &d << endl;
    }
    A(int x) : d(x, x), c(3, 4) {// 转换构造
        cout << this << " : transform constructor" << endl;
    }
    // A(A a1) {}
    A(const A &a) : d(a.d), c(3, 4) { // 避免传过来的变量是一个临时变量,同时也可以处理传过来的参数是const类型
        cout << this << " : copy constructor" << endl;;
    }

    const A &operator=(const A &a) const {
        cout << this << " : operator=" << endl;
        return *this;
    }

    ~A() {//析构函数在main函数执行完后调用
        cout << this <<" ~destructor()" << endl;
    }

private:

};

int main() {
    const A a;
    A b = a;
    A c = 3;
  	return 0;
}


```



```cpp
0x7ffee061b5d0
0x7ffee061b5d8
0x7ffee061b5d0 constructor()
 c : 0x7ffee061b5d0
 d : 0x7ffee061b5d8
0x7ffee061b5c0
0x7ffee061b5c0 : copy constructor
0x7ffee061b5b0
0x7ffee061b5b8
0x7ffee061b5b0 : transform constructor
0x7ffee061b5b0 ~destructor()
0x7ffee061b5c0 ~destructor()
0x7ffee061b5d0 ~destructor()
```



> 结论:
>
> cd对象构造的顺序是由申明的顺序决定的与初始化列表顺序无关
>
> 所以说`A() : d(3, 4), c(3, 4)`和`A() : c(3, 4), d(3, 4)`是没有区别的，
>
> `Data c, d;`一定会先构造对象c,
>
> `Data d(c), c(3, 4);`  也就说可以把c拷贝给d
>
> `Data c(d), d(3, 4);`    但是不能把d拷贝给c
>
> 因为先构造了c,此时d还没有构造



### 8.new 和malloc的区别

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << "default constructor" << endl;
    }
    ~A() {
        cout << "destructor" << endl;
    }

};

int main() {
    int n = 10;

    cout << "malloc int : " << endl;
    int *data = (int *)malloc(sizeof(int) * n);
    free(data);
    cout << "new int : " << endl;
    int *data2 = new int[n]; // 用法简单
    delete[] data2; // delete连续的数组空间

    cout << "malloc A : " << endl;
    A *Adata1 = (A *)malloc(sizeof(A) * n);
    for (int i = 0; i < n; i++) { // 为每一个变量赋值 
        new(Adata1 + i) A();// 原地构造 new(首地址) A():要调用那个类型的构造
        // cin >> Adata1 + 1;
    }
    free(Adata1);
    cout << "new A : " << endl;
    A *Adata2 = new A[10];
    A *Adata3 = new A;
    delete[] Adata2;
    // delete[] Adata2;
    delete Adata3; // 单一变量不需要加[]
    



    return 0;
}

```



```cpp
malloc int : 
new int : 
malloc A : 
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
new A : 
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
default constructor
destructor
destructor
destructor
destructor
destructor
destructor
destructor
destructor
destructor
destructor
destructor
```



> **new 和malloc的区别**：
>
> 1.new用法简单比较简单
>
> 2.使用new的时候可以调用默认构造函数，malloc不会调用，不会初始化
>
> 3.new是一个运算符，可以重载，malloc是一个函数
>
> 4.delete[] 连续的数组空间,单一变量不需要加[]
>
> 



## 2.6 类属性和类方法

![截屏2021-03-07 下午7.08.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%887.08.27.png)



所有对象共有的属性和方法

## 2.7 const 方法



![截屏2021-03-07 下午7.12.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%887.12.55.png)





## 2.8对象与引用

引用在定义的时候需要初始化，

避免出现b=a;是赋值还是引用的歧义

![截屏2021-03-07 下午7.12.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%887.12.50.png)

## 2.9 c++中的结构体和类



![截屏2021-03-07 下午7.20.43 1](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%887.20.43%201.png)

> struct在c++中的底层实现是类 和C++ class 是一样，与C不同，C是结构体



> struct 默认访问权限public 黑名单策略：
>
> class 默认访问权限为private 白名单策略：可以让外界想访问的东西定义在public内





> C++已经有class为什么还要保留struct关键字？

兼容C,





> 为什么struct默认访问权限不是private？

如果设计成私有的，原来大量的C语言就无法使用了。struct的设计目的是让外部的程序访问其数据成员，class设计的目的之一是不让外部程序直接访问其数据成员。



struct更适合看成一个数据结构的实现，而class更适合看成一个对象的实现。





## 附1:返回值优化

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << "default constructor" << endl;
    }
    A(int x) : x(x) {
        cout << "transform &x: " << &x << endl;
        cout << "&this = " << &(*this) << endl;
        cout << "transform constructot" << endl;
    }
    A(const A &a) {
        cout << "copy constructor" << endl;
    }
    int x;
private:
};

A func() {
    A temp(69);
    cout << "func &temp: " << &temp << endl;
    return temp;
}

int main() {
    A a = func(); //
    cout << "main &a: " << &a << endl;
    cout << a.x << endl;


    return 0;
}
```

```cpp
transform &x: 0x7ffedfcaa824
&this = 0x7ffedfcaa86c
transform constructot
func &temp: 0x7ffedfcaa86c
main &a: 0x7ffedfcaa86c
69
```



> temp地址与a的地址是一样的，既然temp要赋值给a，编译期就会优化，直接将temp的地址 赋值给a



![截屏2021-03-07 下午9.23.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.23.40.png)

![截屏2021-03-07 下午9.25.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.25.10.png)

![截屏2021-03-07 下午9.25.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.25.16.png)

![截屏2021-03-07 下午9.26.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.26.10.png)

![截屏2021-03-07 下午9.31.56](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.31.56.png)

![截屏2021-03-07 下午9.32.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.32.59.png)

> 返回值的第一次优化：优化掉了临时匿名变量，去掉了中间商，只做了一次拷贝优化



![截屏2021-03-07 下午9.52.15](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-07%20%E4%B8%8B%E5%8D%889.52.15.png)





> 最终优化样式

关闭编译期优化



```cpp
g++ -fno-elide-constructors 17.RVO.cpp
```



```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << this << " default constructor" << endl;
    }
    A(int x) : x(x) {
        cout << this << " transform constructot" << endl;
    }
    A(const A &a) {
        cout << this << " copy constructor" << endl;
    }
    int x;
private:
};
A func() {
    A temp(69);
    cout << "func &temp: " << &temp << endl;
    return temp;
}

int main() {
    A a = func(); //
    cout << "main &a: " << &a << endl;
    cout << a.x << endl;


    return 0;
}
```



```cpp
0x7ffee232984c transform constructot  // temp初始化
func &temp: 0x7ffee232984c // temp地址
0x7ffee232986c copy constructor // 第一次拷贝给临时匿名对象的变量
0x7ffee2329868 copy constructor  // 第二次拷贝给对象a
main &a: 0x7ffee2329868
424476709
```





> 实现代码后，不正确的代码调用了几次拷贝构造
>
> 实现工程时不能随便改变拷贝构造的语义，因为只有你自己知道，编译器不知道,编译器会对拷贝构造优化



```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

class A {
public:
    A() {
        cout << this << " default constructor" << endl;
    }
    A(int x) : x(x) {
        cout << this << " transform constructot" << endl;
    }
    A(const A &a) {
        cout << this << " copy constructor" << endl;
    }
    A &operator=(const A &a) {
        cout << this << " : operator=" << endl;
        return *this;
    }
    int x;
private:
};

A func() {
    A temp(69);
    cout << "func &temp: " << &temp << endl;
    return temp;
}

int main() {
    A a = func(); //
    cout << "main &a: " << &a << endl;
    cout << a.x << endl;

    cout << "+++++++========+++++++" << endl;
    a = func();
    cout << a.x << endl;


    return 0;
}
```

```cpp
0x7ffeef34e868 transform constructot
func &temp: 0x7ffeef34e868
main &a: 0x7ffeef34e868
69
+++++++========+++++++
0x7ffeef34e86c transform constructot
func &temp: 0x7ffeef34e86c
0x7ffeef34e868 : operator=
69
```





> 第二种情况不构成优化的条件，所有会有两个地址



> 返回值优化，通过替换this指针进行优化



> 如果没有写拷贝构造函数，在编译期没有优化的情况下，他会默认调用构造函数





## const代码演示



```cpp
#include <iostream>
using namespace std;

class People {
public:
    People() : say_cnt(0) {
        People::total_num += 1;
    }
    static void say_count() {
        cout << People::total_num << endl;
    }
    void say() const { // const类型必须调用const类型方法
        cout << "hahahah~, funny!" <<endl;
        output();  // const output
        say_cnt += 1; // 逻辑意义上的const
        return ;
    }
    void output() {
        cout << "non-const output function" << endl;
    }
    void output() const { // 函数重载
        cout << "const output function" << endl;
    }

    ~People() {
        People::total_num -= 1;
    }
private:
    mutable int say_cnt; // mutable 实现逻辑意义上的const
    static int total_num; // 声明，在类内加static，为了和其他变量区分

};

int People::total_num = 0; // 类的变量的定义， 不需要加static关键字


int main() {
    People a, b;
    a.say_count();
    People::say_count();

    {
        People a, b;
        People::say_count();
    }
    People::say_count();

    const People c;
    c.say(); // const 类型对象不能调用非const类型的方法，因为可能会改变const类型的变量

    return 0;
}
```



```cpp
2
2
4
2
hahahah~, funny!
const output function
```





> const类型的方法就是给const类型的对象准备的
>
> const类型必须调用const类型方法
>
> mutable 实现逻辑意义上的const
>
> 声明，在类内加static，为了和其他变量区分
>
> 类的变量的定义， 不需要加static关键字
>
> const 类型对象不能调用非const类型的方法，因为可能会改变const类型的变量











> 如何不让一个类被拷贝

```cpp
#include <iostream>
using namespace std;

class A {
public:
    //A() = delete; // 删除默认构造函数
    //A(const A &) = default; // 使用默认拷贝构造   没有任何功能上的意义， 可以尽量避免发生错误
    A() = default;
private:
    A(const A &) = delete;
    A &operator=(A &a);
    const A &operator=(const A &a) const;
};



int main() {
    A a;
    A b;
    //a = b; // 此处报错
    (a = 123) = 456;
    cout << a.x << endl;

    return 0;
}
```



```
456
```



> `A() = delete;` // 删除默认构造函数
>   `A(const A &) = default;` // 使用默认拷贝构造   没有任何功能上的意义， 可以尽量避免发生错误



> 为什么返回引用？
>
> 可以连续使用运算符







## 2.10 重载

![截屏2021-03-08 下午5.42.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-08%20%E4%B8%8B%E5%8D%885.42.40.png)

![截屏2021-03-08 下午5.43.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-08%20%E4%B8%8B%E5%8D%885.43.26.png)



```cpp
#include <iostream>
using namespace std;


// func(int)
// func(int, int)
int func(int x, int y = 2) {
    return x * y;
}

//double func(int x) {//无法通过返回值区分函数类型
//    return x * x + 5;
//}


//
double func(double x) {
    return x * x;
}

int main() {

    cout << func(2) << endl;; // func() 1
    cout << func(5.3) << endl; // func()2
    cout << func(2, 4) << endl; // func() 3

    return 0;
}

```





> 函数重载==名字相同==，==参数列表不同==
>
> ==与返回值无关==





## 友元函数



> 友元函数是类外部的函数，但是通过申明友元函数可以实现访问类内部的private成员属性



```cpp
#include <iostream>
using namespace std;

class Data { // 数据类
public:
    Data() {}
    Data(int x, int y) : x(x), y(y) {
        cout << this << endl;
    } 

    friend ostream &operator<<(ostream &out, const Data &d);
private:
    int x, y;
};

ostream &operator<<(ostream &out, const Data &d) {
    out << "(" << d.x << " " << d.y << ")" << endl;
}

int main() {

    Data d(10, 9);
    cout << d << endl;

    return 0;
  }
```





## 重载

![截屏2021-03-08 下午6.32.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-08%20%E4%B8%8B%E5%8D%886.32.11.png)



> sizeof是运算符



```cpp
#include <iostream>
using namespace std;

class Point {
public:
    Point();
    Point(int x, int y);
    Point operator+(const Point &);  // 类内重载
    Point &operator+=(int);  // 类内重载
private:
    friend Point operator+(const Point &a, const Point &b);// 类外重载
    friend ostream &operator<<(ostream &out, const Point &a);// 类外重载
    int x;
    int y;
};

Point::Point() : x(0), y(0) {}
Point::Point(int x, int y) : x(x), y(y) {}

Point Point::operator+(const Point &a) { // 类内重载
    cout << "inner operator+" << endl;
    Point c(this->x + a.x, this->y + a.y);
    return c;
}

Point &Point::operator+=(int n) {  // 类内重载
    x += n, y += n;
    return *this;
}


Point operator+(const Point &a, const Point &b) { // 类外重载
    cout << "outer operator" << endl;
    Point c(a.x + b.x, a.y + b.y);
    return c;
}

ostream &operator<<(ostream &out, const Point &a) {// 类外重载
    out << "(" << a.x << "," << a.y << ")" << endl;
    return out;
}

int main() {
    Point a(3, 4);
    Point b(7, 9);
    Point c = a + b;
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;

    a += 2;
    cout << a << endl;


    return 0;
}

```



```cpp
inner operator+
(3,4)

(7,9)

(10,13)

(5,6)
```





> +=为什么返回引用？

可以实现连续+=的现象





## 重载成员函数原则

赋值（=），下标（[]）， 调用（()），成员访问（<>）运算符必须重载为成员函数

复合赋值运算符一般重载为成员函数

改变对象运算状态额运算符和类型密切相关的运算符，一般重组在为成员函数，如自增等

具有对称性的运算符可能转换任意一端的对象，通常重载为非成员函数，如相等，关系和位运算



[]数组对象()函数对象->指针对象：只支持类内重载

()函数对象：表现的像函数，其实是一个对象，本质上是一个像函数一样被调用的对象

->指针对象:表现的像个指针，实际上是一个对象



```cpp
#include <iostream>
using namespace std;

class Point {
public :
    Point();
    Point(int x, int y);
    Point operator+(const Point &);  // 类内重载
    Point &operator+=(int);  // 类内重载
    int operator[](string s);
    int getX() { return x; }
    int getY() { return y; }
private :
    friend Point operator+(const Point &a, const Point &b);
    friend ostream &operator<<(ostream &out, const Point &a);
    int x;
    int y;
};
class PPoint { // 指向Point的指针
public :
    PPoint(Point *p) : p(p) {}
    Point *operator->() {
        return p;
    }
private :
   Point *p;
};

class ADD {
public :
    ADD(int c) : c(c){}
    int operator()(int a, int b) {
        return a + b + c;
    }
private :
    int c;
};





Point::Point() : x(0), y(0) {}
Point::Point(int x, int y) : x(x), y(y) {}

int Point::operator[](string s) {
    if (s == "x") return x;
    if (s == "y") return y;
    return 0;
}

//string operator()(string s) {
//    return s;
//}



Point Point::operator+(const Point &a) { // 类内重载
    cout << "inner operator+" << endl;
    Point c(this->x + a.x, this->y + a.y);
    return c;
}

Point &Point::operator+=(int n) {  // 类内重载
    x += n, y += n;
    return *this;
}


Point operator+(const Point &a, const Point &b) { // 类内重载
    cout << "outer operator" << endl;
    Point c(a.x + b.x, a.y + b.y);
    return c;
}

ostream &operator<<(ostream &out, const Point &a) {
    out << "(" << a.x << "," << a.y << ")" << endl;
    return out;
}

int main() {


    ADD add(5);
    cout << add(6, 7) << endl;



    Point a(3, 4);
    Point b(7, 9);
    Point c = a + b;



    cout << a["x"] << endl;
    cout << a["y"] << endl;
    //return 0;


    cout << a << endl;
    cout << b << endl;
    cout << c << endl;

    a += 2;
    cout << a << endl;

    PPoint p = &a;
    cout << p->getX() << " " << p->getY() << endl;

    return 0;
}
```











## 通过重载实现简单的智能指针

```cpp
#include <iostream>
#include <memory>
using namespace std;

namespace haizei {

class A {
public :
    A() {
        cout << "dfault constructor" << endl;
    }
    int x, y;
    ~A() {
        cout << "destructor" << endl;
    }
};

class my_shared_ptr {
public :
    my_shared_ptr();
    my_shared_ptr(A *);
    my_shared_ptr(const my_shared_ptr &);
    int use_count();
    A *operator->();
    A &operator*();
    my_shared_ptr &operator=(const my_shared_ptr &);
    ~my_shared_ptr();
private :
    void decrease_by_one();
    void increase_by_one();
    int *cnt;
    A *obj;
};
my_shared_ptr::my_shared_ptr() : obj(nullptr), cnt(nullptr) {}
my_shared_ptr::my_shared_ptr(A *obj) : obj(obj), cnt(new int(1)) {}

my_shared_ptr::my_shared_ptr(const my_shared_ptr &p) : obj(p.obj), cnt(p.cnt) {
    increase_by_one(); //*p.cnt += 1;
}

int my_shared_ptr::use_count(){
    return cnt ? *cnt : 0;
}

A *my_shared_ptr::operator->() {
    return obj;
}

A &my_shared_ptr::operator*() {
    return *obj;
}
my_shared_ptr::~my_shared_ptr() {
    this->decrease_by_one();
    this->obj = nullptr;
    this->cnt = nullptr;
}

void my_shared_ptr::decrease_by_one() { //引用计数-1
    if (this->cnt != nullptr) {
        *(this->cnt) -= 1;
        if (*(this->cnt) == 0) {
            delete this->obj;
            delete this->cnt;
        }
    }
    return ;
}
void my_shared_ptr::increase_by_one() { //引用计数+1
    if (this->cnt != nullptr) {
        *(this->cnt) += 1;
    }
    return ;
}



my_shared_ptr &my_shared_ptr::operator=(const my_shared_ptr &p) {
    if (this->obj != p.obj) {
        decrease_by_one();
        this->obj = p.obj;
        this->cnt = p.cnt;
        increase_by_one();
    }
    return *this;
}

} // end of haizei

using namespace haizei;
int main() {

    cout << "p1" << endl;
    A *p1 = new A();
    p1 = nullptr;

    cout << endl << "p2" << endl;
    my_shared_ptr p2(new A());
    cout << p2.use_count() << endl; // 1
    my_shared_ptr p3 = p2;
    p2->x = 123;
    p2->y = 456;
    (*p2).x = 456;
    cout << p3.use_count() << endl; // 2
    p2 = nullptr; // 自动析构
    cout << p3.use_count() << endl; // 1, p2指向了其他对象

    p2 = p3;
    cout << p2.use_count() << endl;




    return 0;
}
```





## 2.11 sort简单实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

ostream &operator<<(ostream &out, const vector<int> &a) {
    for (auto x : a) {
        out << x << " ";
    }
    return out;
}

bool cmp(int a, int b) {
    //return a < b;// a排在b前面：a < b,从小到大
    return a > b;// a排在b后面：a > b,从大到小
}

class CMP {
public :
    CMP(int z = 0) : z(z) { // z == 0 less z = 1 greater

    }
    bool operator()(int a, int b) {
        // return a > b;
        return (a < b) ^ !!(z);
    }
    int z;
};

int main() {
    vector<int> arr;
    int n = 9;
    //cin >> n;
    srand(time(0));
    for (int i = 0; i < n; i++) {
        int temp = rand() % 100;
        arr.push_back(temp);
    }

    //sort(arr.begin(), arr.end(), cmp; // cmp函数
    //sort(arr.begin(), arr.end(), CMP()); //  cmp匿名对象， 仿函数
    CMP cmp2;
    //sort(arr.begin(), arr.end(), cmp2); //  cmp2对象 相对于函数仿函数功能更加强大
    //sort(arr.begin(), arr.end(), CMP()); //  cmp匿名对象， 默认从小到大排序
    sort(arr.begin(), arr.end(), CMP(1)); //  cmp匿名对象， 传参1 从 大到小排序  外在表现的像一个函数 实际上比函数更加强大
    cout << arr << endl;



    return 0;
}
```





```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

ostream &operator<<(ostream &out, const vector<int> &a) {
    for (auto x : a) {
        out << x << " ";
    }
    return out;
}

bool cmp(int a, int b) {
    //return a < b;// a排在b前面：a < b,从小到大
    return a > b;// a排在b后面：a > b,从大到小
}


 class CMP {
 public :
     CMP(int z = 0) : z(z) { // z == 0 less z = 1 greater

     }
     bool operator()(int a, int b) {
         // return a > b;
         return (a < b) ^ !!(z);
     }
     int z;
 };

namespace haizei {
class CMP1 {
public :
    CMP1(int z = 0) : z(z) { // z == 0 less z = 1 greater

    }
    bool operator()(int a, int b) {
        // return a > b;
        return (a < b) ^ !!(z);
    }
    int z;
};
void sort(int *arr, int l, int r, function<bool(int, int)> cmp = CMP1()) { // /快速排序
    if (l >= r) return ;
    int x = l, y = r, z = arr[(l + r) >> 1];
    do {
        while (cmp(arr[x], z)) ++x;
        while (cmp(z, arr[y])) --y;
        if (x <= y) {
            swap(arr[x], arr[y]);
            ++x, --y;
        }
    } while (x <= y);
    sort(arr, l, y, cmp);
    sort(arr, x, r, cmp);
    return ;
}
} // end of haizei

int main() {
    vector<int> arr;
    int n = 9;
    //cin >> n;
    srand(time(0));
    for (int i = 0; i < n; i++) {
        int temp = rand() % 100;
        arr.push_back(temp);
    }

    //sort(arr.begin(), arr.end(), cmp; // cmp函数
    //sort(arr.begin(), arr.end(), CMP()); //  cmp匿名对象， 仿函数
    CMP cmp2;
    //sort(arr.begin(), arr.end(), cmp2); //  cmp2对象 相对于函数仿函数功能更加强大
    //sort(arr.begin(), arr.end(), CMP()); //  cmp匿名对象， 默认从小到大排序
    //sort(arr.begin(), arr.end(), CMP(1)); //  cmp匿名对象， 传参1 从 大到小排序  外在表现的像一个函数 实际上比函数更加强大

    //cout << arr << endl;
    int arr2[5] = {6, 8, 4, 5, 1};
    haizei::sort(arr2, 0, 4); // 默认从小到大排序
    cout << "默认从小到大：" << endl;
    for (int i = 0; i < 5; i++) {
       cout << arr2[i] << " ";
    }
    cout << endl;

    cout << "cmp 从大到小： " << endl;
    haizei::sort(arr2, 0, 4, cmp); // cpm从大到小排序
    for (int i = 0; i < 5; i++) {
       cout << arr2[i] << " ";
    }
    cout << endl;

    cout << "默认 从小到大： " << endl;
    haizei::sort(arr2, 0, 4); //  默认从小到大排序
    for (int i = 0; i < 5; i++) {
       cout << arr2[i] << " ";
    }
    cout << endl;

    cout << "仿函数 从大到小： " << endl;
    haizei::sort(arr2, 0, 4, haizei::CMP1(1)); // 仿函数CMP从大到小排序
    for (int i = 0; i < 5; i++) {
       cout << arr2[i] << " ";
    }
    cout << endl;




   return 0;
}
```







## 其他重载知识点

不能重载的5个运算符



```cpp
. 成员引用运算符
.*   成员指针引用运算符
sizeof 运算符
?:唯一三目运算符
::作用域操作符
```



只能在类内重载的4个操作符

```cpp
()函数括号运算符   函数对象
[]数组方括号运算符	数组对象
->间接引用运算符   指针对象
=赋值运算符
```



 





# 3.继承



## 3.1什么是继承



```cpp
class Animal {
public :
    string name() {
        return this->__name;
    }
private :
    string __name;
};

class Cat : public Animal {

};
```



> 1.子类继承父类所有的属性和方法



> 2.拥有不代表能访问





## 3.2 继承-子类的访问权限

![截屏2021-03-25 下午10.03.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8810.03.40.png)



子类是父类的类外部



> 子类只能访问父类中的public和protected



> 1.继承权限不影响子类对父类内容的访问
>
> 2.继承影响类外部访问子类内部继承至父类这部分内容的访问权限



![截屏2021-03-25 下午10.10.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8810.10.24.png)







```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {}
    void say() {
        cout << "my name is " << name << endl;
    }
private :
    string name;
};

class Cat : public Animal {};

int main() {
    cout << sizeof(Animal) << " " << sizeof(Cat) << endl; 
  // 32 32 ==> Cat 继承了 Animal 的内容， 大小一样
    Cat c;
    c.say();

    return 0;
}

```

```cpp
32 32
my name is 加菲猫
```



## 3.3继承代码演示

```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {}
    void say() {
        cout << "my name is " << name << endl;
        name2 = "加菲猫";
    }
    void rename(string name) {
        this->name = name;
        return ;
    }
private :
    string name;
protected :
    string name2;
};

class Cat : public Animal {
public :
    void say1() {
        //cout << "加菲猫, my name is " << name << endl; // std::string Animal::name' is private within this context
        cout << "加菲猫, my name is " << name2 << endl; // 子类可以访问父类的pritected
    }
};

class Tigger : public Cat {
public :
    void say2() {
        // cout << "houhouhou, my name is " << name2 << endl; // 无法访问private继承 private Animal
        // 可以访问protected继承，和public继承
        //
    }
};

int main() {
    cout << sizeof(Animal) << " " << sizeof(Cat) << endl; // 32 32 ==> Cat 继承了 Animal 的内容， 大小一样
    Cat c;
    //c.say(); // Cat继承了Animal的内容 public Animal
    c.say1();

    Animal *p = &c; 
  // 通过父类的指针访问子类继承父类的内容，前提条件是继承方法必须是public继承, 
  //如果Cat是private和protected继承，则无法访问
    p->say();


    return 0;
}
```





## 3.4继承-构造函数

> 子类中有父类的数据区， 先构造父类的数据区，再构造子类的数据区

> 构造完成顺序： 父类、子类

> 析构顺序： 子类、父类



```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {
        cout << "Animal default constructor" << endl;
    }
    void say() {
        cout << "my name is " << name << endl;
        name2 = "加菲猫";
    }
    void rename(string name) {
        this->name = name;
        return ;
    }
    ~Animal() {
        cout << "Animel destructor" << endl;
    }
private :
    string name;
protected :
    string name2;
};

class Cat : public Animal {
public :
    Cat() : Animal("Cat MIMI") {
        cout << "Cat default structor" << endl;
    }
    void say1() {
        //cout << "加菲猫, my name is " << name << endl; // std::string Animal::name' is private within this context
        cout << "加菲猫, my name is " << name2 << endl; // 子类可以访问父类的pritected
    }
    ~Cat() {
        cout << "Cat deconstructor" << endl;
    }
};
 

int main() {
    cout << sizeof(Animal) << " " << sizeof(Cat) << endl; // 32 32 ==> Cat 继承了 Animal 的内容， 大小一样
    Cat c;
    //c.say(); // Cat继承了Animal的内容 public Animal
    c.say1();

    Animal *p = &c; // 通过父类的指针访问子类继承父类的内容，前提条件是继承方法必须是public继承, 如果Cat是private和protected继承，则无法访问
    p->say();


    return 0;
}
```



```cpp
64 64
Animal default constructor
Cat default structor
加菲猫, my name is
my name is Cat MIMI
Cat deconstructor
Animel destructor
```



## 3.5菱形继承



![截屏2021-03-25 下午11.04.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8811.04.00.png)





```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() : x(123) {}
    int x;
};

class B : public A {
public :
    void setX(int x) {
         cout << "setX : &x = " << &(this->x) << endl;
        this->x = x;
        return ;
    }
};

class C : public A {
public :
    int getX() {
        cout << "getX : &x = " << &(this->x) << endl;
        return x;
    }
};

class D : public B, public C {
};

int main() {
    D d;
    cout << "&d" << &d << endl;
    cout << "get X :" << d.getX() << endl;
    d.setX(12345);
    cout << "get X :" << d.getX() << endl;
   
    return 0;
}

```

```cpp
get X :getX : &x = 0x7ffee8c60854
123
setX : &x = 0x7ffee8c60850
get X :getX : &x = 0x7ffee8c60854
 123
```

![截屏2021-03-25 下午11.25.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8811.25.36.png)

>setX调用的是继承至B内的x
>
>getY调用的是继承至C内的x



C# java：单继承但是可以继承多个接口



![截屏2021-03-25 下午11.42.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8811.42.28.png)





## 3.6继承-拷贝构造&赋值运算符

![截屏2021-03-25 下午11.43.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-25%20%E4%B8%8B%E5%8D%8811.43.19.png)



```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {
        cout << "Animal default constructor" << endl;
    }
    void say() {
        cout << "my name is " << name << endl;
        name2 = "加菲猫";
    }
    void rename(string name) {
        this->name = name;
        return ;
    }
    ~Animal() {
        cout << "Animel destructor" << endl;
    }
protected :
    string name;
protected :
    string name2;
};

class Cat : public Animal {
public :
    Cat() : Animal("Cat MIMI") {
        cout << "Cat default structor" << endl;
    }
    Cat(const Cat &c) { //拷贝构造
        cout << "Cat copy constructor" << endl;
    }
    void say1() {
        cout << "加菲猫, my name is " << name << endl; // std::string Animal::name' is private within this context
        //cout << "加菲猫, my name is " << name2 << endl; // 子类可以访问父类的pritected
    }
    ~Cat() {
        cout << "Cat deconstructor" << endl;
    }
};
 

int main() {
    Cat c;
    Cat a = c; // c拷贝给a
    a.say1();
    //c.say(); // Cat继承了Animal的内容 public Animal
    c.say1();

    return 0;
}
```



```cpp
 Animal default constructor
Cat default structor
Animal default constructor
Cat copy constructor
加菲猫, my name is 加菲猫 // 此处调用的是父类的默认构造，说明父类没正确的拷贝
加菲猫, my name is Cat MIMI
Cat deconstructor
Animel destructor
Cat deconstructor
Animel destructor
```





> 正确的拷贝

```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {
        cout << "Animal default constructor" << endl;
    }
    Animal(const Animal &a) : name(a.name) { //增加父类的拷贝构造
        cout << "Animal copy constructor" << endl;
    }
    void say() {
        cout << "my name is " << name << endl;
        name2 = "加菲猫";
    }
    void rename(string name) {
        this->name = name;
        return ;
    }
    ~Animal() {
        cout << "Animel destructor" << endl;
    }
protected :
    string name;
protected :
    string name2;
};

class Cat : public Animal {
public :
    Cat() : Animal("Cat MIMI") {
        cout << "Cat default structor" << endl;
    }
    Cat(const Cat &c) : Animal(c) { // 在子类中显示的调用父类的拷贝函数
        cout << "Cat copy constructor" << endl;
    }
    void say1() {
        cout << "加菲猫, my name is " << name << endl; // std::string Animal::name' is private within this context
        //cout << "加菲猫, my name is " << name2 << endl; // 子类可以访问父类的pritected
    }
    ~Cat() {
        cout << "Cat deconstructor" << endl;
    }
};
 

int main() {
    Cat c;
    Cat a = c; // c拷贝给a
    a.say1();
    c.say1();

    return 0;
}
```



```cpp
Animal default constructor
Cat default structor
Animal copy constructor
Cat copy constructor
加菲猫, my name is Cat MIMI 
加菲猫, my name is Cat MIMI
Cat deconstructor
Animel destructor
Cat deconstructor
Animel destructor
```



## 3.7继承-拷贝应用



> 实际开发中推荐继承一个真实基类，多个功能性基类



```cpp
#include <iostream>
using namespace std;

class Uncopyable { // 只要基类不可以被拷贝，子类一定不能被拷贝
public :
    Uncopyable() = default;
    Uncopyable(const Uncopyable &) = delete;
    Uncopyable &operator=(const Uncopyable &) = delete;
};


class A : public Uncopyable {
public :
    //A(const A &) = delete; // 不允许被拷贝
};

class B : public Uncopyable {
public :
    //B(const B &) = delete;
};

class C : public Uncopyable {
public :
    //C(const B &) = delete;
};


int main() {
    A a;
    C c = a; //  conversion from 'A' to non-scalar type 'C' requested

    return 0;
}
```





## 赋值运算符继承代码演示

```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name = "加菲猫") : name(name) {
        cout << "Animal default constructor" << endl;
    }
    Animal(const Animal &a) : name(a.name) {
        cout << "Animal copy constructor" << endl;
    }
    Animal &operator=(const Animal &a) {
        this->name = a.name;
        return *this;
    }
    void say() {
        cout << "my name is " << name << endl;
        name2 = "加菲猫";
    }
    void rename(string name) {
        this->name = name;
        return ;
    }
    ~Animal() {
        cout << "Animel destructor" << endl;
    }
protected :
    string name;
protected :
    string name2;
};

class Cat : public Animal {
public :
    Cat() : Animal("Cat MIMI") {
        cout << "Cat default structor" << endl;
    }
    Cat(const Cat &c) : Animal(c) { // 在子类中显示的调用父类的构造函数
        cout << "Cat copy constructor" << endl;
    }
    Cat &operator=(const Cat &c) {
        this->Animal::operator=(c);
        return *this;
    }
    void say1() {
        cout << "加菲猫, my name is " << name << endl; // std::string Animal::name' is private within this context
        //cout << "加菲猫, my name is " << name2 << endl; // 子类可以访问父类的pritected
    }
    ~Cat() {
        cout << "Cat deconstructor" << endl;
    }
};

class Tigger : public Cat {
public :
    void say2() {
        // cout << "houhouhou, my name is " << name2 << endl; // 无法访问private继承 private Animal
        // 可以访问protected继承，和public继承
        //
    }
};

int main() {
    //cout << sizeof(Animal) << " " << sizeof(Cat) << endl; // 32 32 ==> Cat 继承了 Animal 的内容， 大小一样
    Cat c;
    Cat a = c; // c拷贝给a
    cout << "a.say1()" << endl;
    a.say1();
    //c.say(); // Cat继承了Animal的内容 public Animal
    cout << "c.say1()" << endl;
    c.say1();

    //Animal *p = &c; // 通过父类的指针访问子类继承父类的内容，前提条件是继承方法必须是public继承, 如果Cat是private和protected继承，则无法访问
    //p->say();


    return 0;
}
```





## 3.8 菱形继承解决方案-virtual

```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() : x(123) {}
    int x;
};

class B : virtual public A { // 虚继承,子类会将虚继承的部分（来自同一个类）合并
public :
    void setX(int x) {
        //cout << "setX : &x = " << &(this->x) << endl;
        this->x = x;
        return ;
    }
};

class C : virtual public A {
public :
    int getX() {
        //cout << "getX : &x = " << &(this->x) << endl;
        return x;
    }
};

class D : public B, public C {
};

int main() {
    D d;
    cout << "&d" << &d << endl;
    cout << "get X :" << d.getX() << endl;
    d.setX(12345);
    cout << "get X :" << d.getX() << endl;


    return 0;
}
```



```cpp
&d0x7ffee3bac820
get X :123
get X :12345
```



> `virtual`： 虚继承,子类会将父类中虚继承的部分合并成一个部分



# 4.多态

## 4.1多态

从继承—到多态

```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name) : name(name) {}
    void run() {
        cout << "I don't know how to run" << endl;
    }
private :
    string name;
};

class Cat : public Animal {
public :
    Cat(string name) : Animal(name) {}
    void run() {
        cout << "I can run with four legs" << endl;
    }
};


int main() {
    Cat a("Tom");
    Animal &b = a;
    Animal *c = &a;

    a.run(); // 猫跑
    b.run(); // animal run
    c->run(); // animal run


    return 0;
}
```

```cpp
I can run with four legs
I don't know how to run
I don't know how to run
```



> 普通成员方法：
>
> 跟着类走(看调用的时候被谁调用)对象是什么类型的，就调用该类的方法）
>
> 在编译期就已确定



> 虚函数virtual
>
> 虚函数跟着对象走
>
> b是Cat类型对象的引用，所以调用的是cat类型的方法
>
> c是指向Cat类型对象的指针，所以调用的是cat类型的方法



override说明性关键字，覆盖父类中同名的关键字

```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name) : name(name) {}
    virtual void run() {
        cout << "I don't know how to run" << endl;
    }
private :
    string name;
};

class Cat : public Animal {
public :
    Cat(string name) : Animal(name) {}
    void run() override {
        cout << "I can run with four legs" << endl;
    }
};


int main() {
    Cat a("Tom");
    Animal &b = a;
    Animal *c = &a;

    a.run(); // 猫跑
    b.run(); // 猫跑
    c->run(); // 猫跑


    return 0;
}
```



```cpp
I can run with four legs
I can run with four legs
I can run with four legs
```





## 4.2virtual作用1:多外显示接口统一



```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name) : name(name) {}
    virtual void run() {
        cout << "I don't know how to run" << endl;
    }
private :
    string name;
};

class Cat : public Animal {
public :
    Cat(string name) : Animal(name) {}
    void run() override {
        cout << "I can run with four legs" << endl;
    }
};

class People : public Animal {
public :
    People(string name) : Animal(name) {}
    void run() {
        cout << "I can run with two legs!" << endl;
    }
};

class Bat : public Animal {
public :
    Bat(string name) : Animal(name) {}
    void run() {
        cout << "I can fly!" << endl;
    }
};



int main() {

    srand(time(0));

    #define MAX_N 10
    Animal **zoo = new Animal*[MAX_N];
    for (int i = 0; i < MAX_N; i++) {
        switch (rand() % 3) {
        case 0: zoo[i] = new Cat("cat"); break;
        case 1: zoo[i] = new People("people"); break;
        case 2: zoo[i] = new Bat("bat"); break;
        }
    }

    for (int i = 0; i < MAX_N; i++) {
        zoo[i]->run();
    }

    return 0;
}
```



```cpp
I can fly!
I can run with two legs!
I can run with four legs
I can fly!
I can fly!
I can run with two legs!
I can fly!
I can fly!
I can fly!
I can run with four legs
```



> 每次出现的结果都不一样，虚函数不确定性指向哪个函数(cat->run, peopel->run,bat->run)只有程序运行的时候才能确定指向哪个对象的函数
>
> 普通函数 跟着类走 在编译期就可以确定
>
> 虚函数 跟着对象走 在程序运行期才可以确定



## 4.3 override作用和final关键字应用场景



```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name) : name(name) {}
    virtual void run() {
        cout << "I don't know how to run" << endl;
    }
    virtual void getName() final {} // 应用场景1：不想被子类修改的内容
    virtual void fl1() {}
private :
    string name;
};

class Cat : public Animal {
public :
    Cat(string name) : Animal(name) {}
    void run() override final {
        cout << "I can run with four legs" << endl;
    }
    //void fll() {} // 想重写fl1(),实际上函数名字打错了，但是编译器不会报错
    //void fll() override {} // 但是如果加上override就会报错, 提示函数不存在，主要起提示作用，完成语义的严谨性,减少bug
};

class Tigger : public Cat {
public :
    //void run() {} // 子类无法重载父类的final, final终结虚函数
    // final禁止重写
};



class People : public Animal {
public :
    People(string name) : Animal(name) {}
    void run() {
        cout << "I can run with two legs!" << endl;
    }
};

class Bat : public Animal {
public :
    Bat(string name) : Animal(name) {}
    void run() {
        cout << "I can fly!" << endl;
    }
};



int main() {

    srand(time(0));

    #define MAX_N 10
    Animal **zoo = new Animal*[MAX_N];
    for (int i = 0; i < MAX_N; i++) {
        switch (rand() % 3) {
        case 0: zoo[i] = new Cat("cat"); break;
        case 1: zoo[i] = new People("people"); break;
        case 2: zoo[i] = new Bat("bat"); break;
        }
    }

    for (int i = 0; i < MAX_N; i++) {
        zoo[i]->run();
    }

    return 0;
}
```



> override的作用？

>子类 想重写fl1(),实际上函数名字打错了，但是编译器不会报错
>  但是如果加上override就会报错, 提示函数不存在，主要起提示作用，完成语义的严谨性,减少bug



> final关键字的作用和应用场景

> final功能：子类无法重载父类的final, final终结虚函数，final禁止重写

> 应用场景1：不想被子类修改的内容



## 虚函数为什么能跟着对象走?



> 当有了虚函数后，编译期会改造虚函数的存储区
>
> 头8个字节指向虚函数表vtable首地址
>
> 虚函数表中存储虚函数

编译器根据类管理虚函数表





```cpp
#include <iostream>
using namespace std;

class A {
public :
    virtual void say() {
        cout << "class A say" << endl;
    }
    virtual void run() {
        cout << "class A run" << endl;
    }
};

class B : public A {
public :
    void say() override {
        cout << "class B say" << endl;
    }
};

class C : public A {
public :
    void run() override {
        cout << "class C run" << endl;
    }
};


#define TEST(a) test(a, #a)
void test(A &a, string class_name) {
    cout << "Object " << class_name << endl;
    a.say();
    a.run();
    cout << "=========" << endl << endl;
    return ;
}



int main() {

    A a;
    B b;
    C c;
    TEST(a);
    TEST(b);
    TEST(c);



    return 0;
}
```





```cpp
Object a
class A say
class A run
=========

Object b
class B say
class A run
=========

Object c
class A say
class C run
======
```









![截屏2021-03-26 下午7.27.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-26%20%E4%B8%8B%E5%8D%887.27.35.png)







> 如果将b的虚函数指针指向c的虚函数表，会发生什么？





```cpp
#include <iostream>
using namespace std;

class A {
public :
    virtual void say() {
        cout << "class A say" << endl;
    }
    virtual void run() {
        cout << "class A run" << endl;
    }
};

class B : public A {
public :
    void say() override {
        cout << "class B say" << endl;
    }
};

class C : public A {
public :
    void run() override {
        cout << "class C run" << endl;
    }
};


#define TEST(a) test(a, #a)
void test(A &a, string class_name) {
    cout << "Object " << class_name << endl;
    a.say();
    a.run();
    cout << "=========" << endl << endl;
    return ;
}



int main() {

    A a;
    B b;
    C c;
    TEST(a);
    TEST(b);
    TEST(c);
    ((void **)(&b))[0] = ((void **)(&c))[0];
    TEST(b);




    return 0;
}

```

```cpp
Object a
class A say
class A run
=========

Object b
class B say
class A run
=========

Object c
class A say
class C run
=========

Object b
class A say
class C run
=========
```



> 虚函数表真的存在



this指针是成员方法隐藏的参数



> 普通指针为什么不能存储成员方法地址？

普通的函数指针没有this指针，所以有了成员方法指针







```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() { x= 200; y = 400; }
    virtual void say(int x) {
        cout << "this->x : " << this->x << endl;
        cout << "class A say : " << x << endl;
    }
    virtual void run() {
        cout << "class A run" << endl;
    }
    void reg1() {
        cout << "reg1 function" << endl;
    }
    void reg2() {
        cout << "reg2 function" << endl;
    }
    void reg3() {
        cout << "reg3 function" << endl;
    }
    void reg4() {
        cout << "reg4 function" << endl;
    }
    void reg5() {
        cout << "reg5 function" << endl;
    }
    int x, y;
};

class B : public A {
public :
    B() { x = 300; }
    void say(int x) override {
        cout << "class B say : " << x << endl;
    }
};

class C : public A {
public :
    C() { x = 400; }
    void run() override {
        cout << "class C run" << endl;
    }
};


#define TEST(a) test(a, #a)
void test(A &a, string class_name) {
    cout << "Object " << class_name << endl;
    a.say(123);
    a.run();
    cout << "=========" << endl << endl;
    return ;
}

typedef void (*func)(void *,int);



int main() {

    A a;
    B b;
    C c;
    TEST(a); // A say A run
    TEST(b); // B say A run
    TEST(c); // A say C run
    ((void **)(&b))[0] = ((void **)(&c))[0]; // 将b的虚函数指针指向c的虚函数表 // A say C run
    TEST(b);

    ((func **)(&b))[0][0](&b, 100); // b函数指向c的say(A say)方法 // A say (this->x : 300)
    // &b this指针， this指针是成员方法隐藏的参数
    // 为什么是300
    // 传入的&b即传入的是b对象的this指针的地址，所以值的b的this指针的值
    cout << "=========" << endl << endl;
    ((func **)(&b))[0][0](&c, 100);  // this->x = 400
    // ==>
    //

    // 成员方法指针
    void (A::*p)(int);
    p = &A::say;
    (a.*p)(12345);


    void (A::*q[3])(); // 成员方法指针



    q[0] = &A::reg1;
    q[1] = &A::reg2;
    q[2] = &A::reg3;
    for (int i = 0; i < 10; i++) {
        (a.*q[rand() % 3])();
    }


    cout << "=++++ a.x" << endl;
    int A::*d; // 成员属性指针
    d = &A::x;
    cout << (a.*d) << endl; // a.x
    cout << a.x << endl;

    cout << " a.y" << endl;
    d = &A::y;
    cout << (a.*d) << endl; // a.x
    cout << a.y << endl;
    cout << " +++++" << endl;






    return 0;
}
```





## dynamic_cast

```cpp
#include <iostream>
using namespace std;

class A {
public :
    virtual void say() {
        cout << "Class A" << endl;
    }
};

class B : public A{
public :
    void say() override {
        cout << "Class A" << endl;
    }
};

class C : public A{
public :
    void say() override {
        cout << "Class A" << endl;
    }
};

int main() {
    srand(time(0));
    A *p;

    switch (rand() % 2) {
        case 0:
            p = new B(); break;
        case 1:
            p = new C(); break;
    }

    // p -> B ? C ?
    cout << dynamic_cast<B *>(p) << endl; // dynamic_cast 将p地址尝试转换成目标地址B
    cout << dynamic_cast<C *>(p) << endl; // 如果不成功返回0




    return 0;
}
```

```
0
0x7f910dc05ac0
```



dynamic_cast会根据虚函数表转换成相应的地址



> 想要使用dynamic_cast,但是自己设计的类没有virtual， 怎么办？

将析构函数设计成virtual

```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() {
        cout << "A constructor" << endl;
    }
    //virtual void say() {
    //    cout << "Class A" << endl;
    //}
    virtual ~A() {
        cout << "A deconstructor" << endl;
    }
};

class B : public A{
public :
    B() {
        cout << "B constructor" << endl;
    }

    //void say() override {
    //    cout << "Class B" << endl;
    //}
    virtual ~B() {
        cout << "B deconstructor" << endl;
    }

};

class C : public A{
public :
    C() {
        cout << "C constructor" << endl;
    }

    //void say() override {
    //    cout << "Class C" << endl;
    //}
    virtual ~C() {
        cout << "C deconstructor" << endl;
    }

};

int main() {
    srand(time(0));
    A *p;

    switch (rand() % 2) {
        case 0:
            p = new B(); break;
        case 1:
            p = new C(); break;
    }
    delete p; // p是A类，是普通的成员方法，只会析构A的成员方法，
    // 这时一定要将析构函数设计成虚构
    // p -> B ? C ?
    
    return 0;
}
```



```cpp
A constructor
C constructor
C deconstructor
A deconstructor
```





> 证明dynamic_cast和虚函数表的关系

```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() {
        cout << "A constructor" << endl;
    }
    //virtual void say() {
    //    cout << "Class A" << endl;
    //}
    virtual ~A() {
        cout << "A deconstructor" << endl;
    }
};

class B : public A{
public :
    B() {
        cout << "B constructor" << endl;
    }

    //void say() override {
    //    cout << "Class B" << endl;
    //}
    virtual ~B() {
        cout << "B deconstructor" << endl;
    }

};

class C : public A{
public :
    C() {
        cout << "C constructor" << endl;
    }

    //void say() override {
    //    cout << "Class C" << endl;
    //}
    virtual ~C() {
        cout << "C deconstructor" << endl;
    }

};

void judge(A *p) {
    if (dynamic_cast<B *>(p)) {// dynamic_cast 将p地址尝试转换成目标地址B
        cout << p << " is class B" << endl;
    }
    if (dynamic_cast<C *>(p)){
        cout << p << " is class C" << endl;
    }
    return ;
}






int main() {
    srand(time(0));
    A *p;

    switch (rand() % 2) {
        case 0:
            p = new B(); break;
        case 1:
            p = new C(); break;
    }

    A *p1 = new B(), *p2 = new C();
    judge(p1);
    judge(p2);
    swap(((void **)p1)[0], ((void **)p2)[0]);
    judge(p1);
    judge(p2);




    return 0;
}
```



```
A constructor
B constructor
A constructor
B constructor
A constructor
C constructor
0x7ff780c05ad0 is class B
0x7ff780c05ae0 is class C
0x7ff780c05ad0 is class C
0x7ff780c05ae0 is class B
```



先判断p1p2是哪个类型，然后交换两个指针的虚函数表

结果dynamic_cast也发生了变换，说明dynamic_cast是根绝虚函数表判断指针类型的





![截屏2021-03-26 下午10.46.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-26%20%E4%B8%8B%E5%8D%8810.46.31.png)







## 4.4纯虚函数



> 1.包含run是必须的
>
> 2.实现run是不合理的

> 性质1：不实现纯虚函数的子类无法实例化
>
> 实例化 = 创建对象
>
> 用来规定子类中必须实现的方法
>
> ==>接口:之规定对外的表现形式，没有具体功能,没有规定具体细节
>
> 所以纯虚函数一般用来实现对外接口





```cpp
#include <iostream>
using namespace std;

class Animal {
public :
    Animal(string name) : name(name) {}
    virtual void run() = 0; // 纯虚函数 作用: 规定子类中必须实现的方法
     
private :
    string name;
};

class House : public Animal {
public :
    House() : Animal("House") {}
    void run() override {
        cout << "house, I can run wirh four legs!" << endl;
    }
};


int main() {
    cout << "Hello world!" << endl;
    House h;

    return 0;
}

```



优先队列

```cpp
#include <iostream>
#include <vector>
using namespace std;

class IQueue {
public :
    virtual void push(int) = 0;
    virtual void pop() = 0;
    virtual bool empty() = 0;
    virtual int top() = 0;
    virtual int size() = 0;
};

class vector_queue : public IQueue, public vector<int> {
public :
    void push(int x) override {
        this->vector<int>::push_back(x);
        return ;
    }
    void pop() override {
        if (empty()) return ;
        vector<int>::iterator p = this->begin();
        for (auto iter = begin(); iter != end(); iter++) {
            if (*iter > *p) p = iter;
        }
        erase(p);
        return ;
    }
    bool empty() override {
        return size() == 0;
    }
    int top() override {
        if (empty()) return 0;
        int ans = at(0);
        for (int i = 1; i < size(); i++) {
            ans = max(at(i), ans);
        }
        return ans;
    }
    int size() override {
        return this->vector<int>::size();
    }
};

class heap_queue : public IQueue, public vector<int> {
public :
    void push(int x) override {
        push_back(x);
        up_maintain(size());
        return ;
    }
    void pop() override {
        std::swap(at(0), at(size() - 1));
        pop_back();
        down_maintain(1);
        return ;
    }
    bool empty() override {
        return size() == 0;
    }
    int top() override {
        if (empty()) return 0;
        return at(0);
    }
    int size() override {
        return this->vector<int>::size();
    }

private:
    void up_maintain(int ind) {
        while (ind > 1 && at(ind - 1) > at((ind / 2) - 1)) {
            std::swap(at(ind - 1), at((ind / 2) - 1));
            ind /= 2;
        }
        return ;
    }
    void down_maintain(int ind) {
        while (ind * 2 <= size()) {
            int temp = ind;
            if (at(ind * 2 - 1) > at(temp - 1)) temp = ind * 2;
            if (ind * 2 + 1 <= size() && at(ind * 2) > at(temp - 1)) temp = ind * 2 + 1;
            if (temp == ind) break;
            std::swap(at(temp - 1), at(ind - 1));
            ind = temp;
        }
        return ;
    }
};

int main() {
    srand(time(0));
    vector_queue q1;
    heap_queue q2;
    for (int i = 0; i < 10; i++) {
        int val = rand() % 100;
        q1.push(val);
        cout << "push q1 : " << val << endl;
    }
    while (!q1.empty()) {
        cout << q1.top() << " ";
        q1.pop();
    }
    cout << endl;
    for (int i = 0; i < 10; i++) {
        int val = rand() % 100;
        q2.push(val);
        cout << "push q2 : " << val << endl;
    }
    while (!q2.empty()) {
        cout << q2.top() << " ";
        q2.pop();
    }
    cout << endl;
    return 0;
}

```



## 4.5纯虚函数-接口

Animal就是抽象类，抽象类不生成对象

```cpp
class Animal {
public :
    Animal(const string &name) : __name(name) {}
  	virtual void run() = 0;
protected :
  string __name;
};
```





## virtual总结





![截屏2021-03-26 下午11.55.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-26%20%E4%B8%8B%E5%8D%8811.55.14.png)



![截屏2021-03-26 下午11.59.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-26%20%E4%B8%8B%E5%8D%8811.59.49.png)



## 哈希表的实现

```cpp
#include <iostream>
#include <vector>
#include <functional>
using namespace std;

class Node {
public :
    Node() = default;
    Node (string, Node *);
    string data();
    Node *next();
    void insert(Node *);
    void erase_next();
private :
    string __data;
    Node *__next;
};

class HashTable {
public :
    typedef function<int(string)> HASH_FUNC_T;
    HashTable(HASH_FUNC_T hash_func, int size);
    bool insert(string);
    bool erase(string);
    bool find(string);
private :
    int size;
    HASH_FUNC_T hash_func;
    vector<Node> data;
};

Node::Node(string data, Node *next = nullptr) : __data(data), __next(next) {}
string Node::data() {
    return this->__data;
}
Node *Node::next() {
    return this->__next;
}
void Node::insert(Node *p) {
    p->__next = this->__next;
    this->__next = p;
}
void Node::erase_next() {
    if (this->__next == nullptr) return ;
    Node *q = this->__next;
    this->__next = this->__next->__next;
    delete q;
    return ;
}

HashTable::HashTable(HASH_FUNC_T hash_func, int size = 10000) : size(size), data(size), hash_func(hash_func) {}
bool HashTable::insert(string s) {
    if (find(s)) return false;
    int h = hash_func(s) % size;
    data[h].insert(new Node(s));
    return true;
}
bool HashTable::erase(string s) {
    int h = hash_func(s) % size;
    for (Node *p = &data[h]; p->next(); p = p->next()) {
        if (p->next()->data() != s) continue;
        p->erase_next();
        return true;
    }
    return false;
}
bool HashTable::find(string s) {
   int h = hash_func(s) % size;
   for (Node *p = data[h].next(); p; p = p->next()) {
        if (p->data() == s) return true;
   }
   return false;
}

int BKDRHash(string s) {
    int seed = 31;
    int h = 0;
    for (int i = 0; s[i]; i++) {
        h = h * seed + s[i];
    }
    return h & 0x7fffffff;
}

class APHash_Class {
public :
    int operator()(string s) {
        int h = 0;
        for (int i = 0; s[i]; i++) {
            if (i % 2) {
                h = (h << 3) ^ s[i] ^ (h >> 5);
            } else {
                h = ~((h << 7) ^ s[i] ^ (h >> 11));
            }
        }
        return h & 0x7fffffff;
    }
};

int main() {
    APHash_Class APHash;
    HashTable h1(BKDRHash);
    HashTable h2(APHash);


    int op;
    string s;
    while (cin >> op >> s) {
        switch (op) {
        case 0:
            cout << "insert " << s << " to hash table 1 = ";
            cout << h1.insert(s) << endl;
            cout << "insert " << s << " to hash table 2 = ";
            cout << h2.insert(s) << endl;
            break;
        case 1:
            cout << "erase " << s << " from hash table 1 = ";
            cout << h1.erase(s) << endl;
            cout << "erase " << s << " form hash table 2 = ";
            cout << h2.erase(s) << endl;
            break;
        case 2:
            cout << "find " << s << " at hash table 1 = ";
            cout << h1.find(s) << endl;
            cout << "find " << s << " at hash table 2 = ";
            cout << h2.find(s) << endl;

            break;
        }
    }


    return 0;
}
```





优化后方案



```cpp
#include <iostream>
#include <vector>
#include <functional>
using namespace std;

class Node {
public :
    Node() = default;
    Node (string, int, Node *);
    string key();
    Node *next();
    void set_next(Node *);
    void insert(Node *);
    void erase_next();
    int value;
private :
    string __key;
    Node *__next;
};

class HashTable {
public :
    typedef function<int(string)> HASH_FUNC_T;
    HashTable(HASH_FUNC_T hash_func, int size);
    bool insert(string, int);
    bool erase(string);
    bool find(string);
    int capacity();
    int &operator[](string);
private :
    Node *__insert(string, int);// 返回新插入节点的地址
    Node *__find(string);
    void __expand();
    int __size, data_cnt;
    HASH_FUNC_T hash_func;
    vector<Node> data;
};

Node::Node(string key, int value = 0, Node *next = nullptr) : __key(key), value(value), __next(next) {}
string Node::key() {
    return this->__key;
}
Node *Node::next() {
    return this->__next;
}
void Node::set_next(Node *next) {
    this->__next = next;
}
void Node::insert(Node *p) {
    p->__next = this->__next;
    this->__next = p;
}
void Node::erase_next() {
    if (this->__next == nullptr) return ;
    Node *q = this->__next;
    this->__next = this->__next->__next;
    delete q;
    return ;
}

HashTable::HashTable(HASH_FUNC_T hash_func, int size = 2) : __size(size), data(__size), hash_func(hash_func), data_cnt(0) {}
bool HashTable::insert(string key, int value = 0) {
    if (find(key)) return false;
    return __insert(key, value);
}
int HashTable::capacity() {
    return this->__size;
}
Node *HashTable::__insert(string key, int value = 0) {// 返回新插入节点的地址
    if (data_cnt >= __size) __expand();
    int h = hash_func(key) % __size;
    data[h].insert(new Node(key, value));
    data_cnt += 1;
    return data[h].next();
}
void HashTable::__expand() {
    cout << "expand hash table" << endl;
    int new_size = __size * 2;
    HashTable temp_h(hash_func, new_size);
    for (int i = 0; i < __size; i++) {
        for (Node *p = data[i].next(); p; p = p->next()) {
            temp_h[p->key()] = p->value;
        }
    }
    swap(*this, temp_h);
    return ;
}
bool HashTable::erase(string s) {
    int h = hash_func(s) % __size;
    for (Node *p = &data[h]; p->next(); p = p->next()) {
        if (p->next()->key() != s) continue;
        p->erase_next();
        data_cnt -= 1;
        return true;
    }
    return false;
}
bool HashTable::find(string s) {
      return __find(s);
}

Node *HashTable::__find(string key) {
   int h = hash_func(key) % __size;
   for (Node *p = data[h].next(); p; p = p->next()) {
        if (p->key() == key) return p;
   }
    return nullptr;
}
int &HashTable::operator[](string key) {
    Node *p;
    if (!(p = __find(key))) return (__insert(key)->value);
   return p->value;

}

int BKDRHash(string s) {
    int seed = 31;
    int h = 0;
    for (int i = 0; s[i]; i++) {
        h = h * seed + s[i];
    }
    return h & 0x7fffffff;
}

class APHash_Class {
public :
    int operator()(string s) {
        int h = 0;
        for (int i = 0; s[i]; i++) {
            if (i % 2) {
                h = (h << 3) ^ s[i] ^ (h >> 5);
            } else {
                h = ~((h << 7) ^ s[i] ^ (h >> 11));
            }
        }
        return h & 0x7fffffff;
    }
};

int main() {
    APHash_Class APHash;
    HashTable h1(BKDRHash);
    HashTable h2(APHash);


    int op;
    string s;
    cout << h1.capacity() << endl;
    cout << h2.capacity() << endl;

    h1["hello"] = 123;
    h1["word"] = 456;
    h1["haizei"] = 789;

    cout << h1.capacity() << endl;
    cout << h2.capacity() << endl;

    cout << h1["hello"] << " "<< h1["word"] << " " << h1["haha"] << endl;
    while (cin >> op >> s) {
        switch (op) {
        case 0:
            cout << "insert " << s << " to hash table 1 = ";
            cout << h1.insert(s) << endl;
            cout << "insert " << s << " to hash table 2 = ";
            cout << h2.insert(s) << endl;
            break;
        case 1:
            cout << "erase " << s << " from hash table 1 = ";
            cout << h1.erase(s) << endl;
            cout << "erase " << s << " form hash table 2 = ";
            cout << h2.erase(s) << endl;
            break;
        case 2:
            cout << "find " << s << " at hash table 1 = ";
            cout << h1.find(s) << endl;
            cout << "find " << s << " at hash table 2 = ";
            cout << h2.find(s) << endl;

            break;
        }
    }


    return 0;
}
```





## 4.6auto关键字及作用1



```cpp
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

int main() {

    int x;
    auto y = 12.3; // c++ auto ：
    // 根据变量自动定义类型，
    // 在c语言就有auto:
    // auto int z = 123; // C : 局部自动变量, 生存周期编译期自动决定，没有实际意义
    cout << sizeof(x) << endl;
    cout << sizeof(y) << endl;

    map<int, int> arr;
    for (int i = 0; i < 10; i++) {
        arr[rand() % 100] = rand();
    }

    // C++ auto 应用场景
    // vector 容器 封装好的数据结构
    // 需求：遍历容器中的相关元素
    // 遍历工具：迭代器，每一种容器的迭代器类型不一样
    map<int, int>::iterator it = arr.begin();// map<int, int>的迭代器
    while (it != arr.end()) {
        cout << it->first << " " << it->second << endl;
        it++;
    }
    cout << "++++++" << endl << endl;
    auto iter = arr.begin();// map<int, int>的迭代器
    while (iter != arr.end()) {
        cout << iter->first << " " << iter->second << endl;
        iter++;
    }


    return 0;
}
```



```cpp
4
8
7 282475249
23 2007237709
27 16531729
30 470211272
40 143542612
44 1457850878
73 984943658
87 1137522503
92 74243042
++++++

7 282475249
23 2007237709
27 16531729
30 470211272
40 143542612
44 1457850878
73 984943658
87 1137522503
92 74243042
```





> auto只根据赋值来决定类型



> 根据变量自动定义类型，
>     在c语言就有auto:
>     auto int z = 123; // C : 局部自动变量, 生存周期编译期自动决定，没有实际意义



>  C++ auto 应用场景
>     vector 容器 封装好的数据结构
>      需求：遍历容器中的相关元素
>     遍历工具：迭代器，每一种容器的迭代器类型不一样
>     map<int, int>::iterator it = arr.begin();// map<int, int>的迭代器
>
> ​	另一种写法
>
> auto iter = arr.begin();// map<int, int>的迭代器





c++11for循环的新的支持

```cpp
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

int main() {

     
    map<int, int> arr;
    for (int i = 0; i < 10; i++) {
        arr[rand() % 100] = rand();
    }
 
    map<int, int>::iterator it = arr.begin();// map<int, int>的迭代器

    for (pair<int, int> i : arr) {
        cout << i.first << " " << i.second << endl;
    }

    cout << "++++++" << endl << endl;
    for (auto i : arr) {
        cout << i.first << " " << i.second << endl;
    }


    return 0;
}
```

```cpp
7 282475249
23 2007237709
27 16531729
30 470211272
40 143542612
44 1457850878
73 984943658
87 1137522503
92 74243042
++++++

7 282475249
23 2007237709
27 16531729
30 470211272
40 143542612
44 1457850878
73 984943658
87 1137522503
92 74243042
```



## typeid关键字



```cpp
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

class Base {
public :
};

int main() {

    int x;
    auto y = 12.3; // c++ auto ：
    int z = 123;
    // 根据变量自动定义类型，
    // 在c语言就有auto:
    // auto int z = 123; // C : 局部自动变量, 生存周期编译期自动决定，没有实际意义

    cout << typeid(x).name() << endl; // 返回类型信息对象，.name输出类型信息名字
    cout << typeid(y).name() << endl; // 返回类型信息对象，.name输出类型信息名字
    cout << typeid(z).name() << endl; // 返回类型信息对象，.name输出类型信息名字

    Base b;
    cout << typeid(b).name() << endl;

    if (typeid(y).hash_code() == typeid(float).hash_code()) {
        cout << "float type" << endl;
    }
    if (typeid(y).hash_code() == typeid(double).hash_code()) {
        cout << "double type" << endl;
    }
    return 0;
}

```





## auto关键字4个限制

> 1.不能作为函数参数(c++11)

```cpp
void func(auto x, auto y) {}
void func(auto x, double y) {}
func(1.2, 1.2);
func(1, 1);
```

编译期功能

> 2.c++11不能作为模板参数

> 3.不能定义数组

> 4.不能用于非静态成员变量

```cpp
class Base {
public :
    static int x; // 静态成员属性
    auto y;// 对象属性不能使用auto关键字来定义
  //non-static data member declared with placeholder 'auto'
};

auto Base::x = 123;

```





## constexpr关键字

> const 运行期常量
> constexpr 编译期常量 叫作表达式常量

constexpr所定义的常量就是告诉编译器在编译期就可以确定的值



```cpp
#include <iostream>
using namespace std;

int main() {

    // const 运行期常量
    // constexpr 编译期常量 叫作表达式常量


    const int x = 123;
    constexpr int y = 123;

    // 都会报错
    // x = 456;
    // y = 456;


    *(const_cast<int *>(&x)) = 456; // 转换常量
    *(const_cast<int *>(&y)) = 456; // 转换常量
    cout << x << endl;
    cout << y << endl;
    cout << const_cast<int *> (&x) << endl;
    cout << const_cast<int *> (&y) << endl;
    cout << &x << endl;
    cout << &y << endl;
    cout << *(&x) << endl; // & 取地址是运行期的，躲避了编译期优化
    cout << *(&y) << endl; // & 取地址是运行期的，躲避了编译期优化

    return 0;
}
```





```cpp
#include <iostream>
using namespace std;

int main() {

    int n;
    cin >> n;
    const int x = n + 123; // 运行期常量
    constexpr int y = n + 123; // 报错
  //the value of 'n' is not usable in a constant expression
}
```



constexpr应用场景：在编译期就可以确定的函数和变量

```cpp
#include <iostream>
using namespace std;
 
constexpr int f(int x) {
    return x * x;
}
 
int main() {

    int n;
    cin >> n;
    const int a = n + 123; // 运行期常量
    constexpr int y1 = 123; //
    constexpr int y2 = f(123);
}
```



constexpr应用场景：修饰类,修饰对象

```cpp
#include <iostream>
using namespace std;
class A {
public :
    constexpr A(int x) {}
};


int main() {

    int n;
    cin >> n;
    const int a = n + 123; // 运行期常量
    constexpr int y1 = 123; //
    constexpr int y2 = f(123);
    const A a1(123);
    constexpr A a2(123);
}
```



## nullptr关键字

```cpp
#include <iostream>
#include <cstdio>
#include <cstddef>
#include <cwchar>
using namespace std;

void func(int x) {
    cout << __PRETTY_FUNCTION__ << endl; // 输出函数具体形式
    cout << x << endl;
    return ;
}

void func(int *x) {
    cout << __PRETTY_FUNCTION__ << endl;
    cout << x << endl;
    return ;
}


int main() {


    //cout << NULL << endl; // 0
    //cout << (nullptr) << endl; // nullptr

    /*if (NULL) { // false
        cout << "true" << endl;
    } else {
        cout << "false" << endl;
    }
     if (nullptr) { // true
        cout << "true" << endl;
    } else {
        cout << "false" << endl;
    }

*/
    func(nullptr); // void func(int*)   0

    //func(NULL); // call of overloaded 'func(NULL)' is ambiguous
    // NULL代表整数0，和空地址， 编译器不确定调用哪一个函数
    // nullptr ： 更加准确的空地址信息


    return 0;
}
```





>NULL代表整数0，和空地址， 
>nullptr ： 更加准确的空地址信息



## 左值和右值

左值

右值

左值引用

右值引用



```cpp
#include <iostream>
using namespace std;

#define func(x) __func(x, "func("#x")")

void __func(int &x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is left value" << endl;
    return ;
}

void __func(int &&x, const char *str) {
    cout << str << " is right value" << endl;
    return ;
}

int main() {

    int x = 1234, y = 456;
    int &rx = x; // 左值引用

    func(1234);
    func(x); // 可以通过x访问
    func(x + y);
    func(x++); // x+1存储在另一个地址，x+1之前的值无法被访问
    func(++x); // x+1之后的值存储在x,x+1之后的值可以通过x访问
    return 0;
}
```



> 如何判断是左值还是右值？
>
> 到了代码下一行的时候，是否能通过单一变量访问到相关的值
>
> 能==>左值
>
> 不能==>右值
>
> 字面量一定是右值



```cpp
class A {
public :
    A operator+(int x) {}   // 应该返回右值，返回值
    A &operator+=(int x) {} // 应该返回左值类型，所以返回了应该引用
};

```





## **move**和forward

```cpp
#include <iostream>
using namespace std;

#define func(x) __func(x, "func("#x")")
#define func2(x) __func2(x, "func2("#x")")

void __func2(int &x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is left value" << endl;
    return ;
}
void __func2(int &&x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is right value" << endl;
    return ;
}

void __func(int &x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is left value" << endl;
    func2(move(x));
    return ;
}

void __func(int &&x, const char *str) {
    cout << str << " is right value" << endl;
    func2(move(x));
    return ;
}

class A {
public :
    A operator+(int x) {}   // 应该返回右值，返回值
    A &operator+=(int x) {} // 应该返回左值类型，所以返回了应该引用
};



int main() {

    int x = 1234, y = 456;
    int &rx = x; // 左值引用

    func(1234);
    func(x);
    func(x + y);
    func(x++);
    func(++x);
    func(x + 123);
    func(x += 123);
    func(x *= 2);
    func(y += 3);
    func(y * 3);


    return 0;
}
```



```cpp
func(1234) is right value
func2(move(x)) is right value
func(x) is left value
func2(move(x)) is right value
func(x + y) is right value
func2(move(x)) is right value
func(x++) is right value
func2(move(x)) is right value
func(++x) is left value
func2(move(x)) is right value
func(x + 123) is right value
func2(move(x)) is right value
func(x += 123) is left value
func2(move(x)) is right value
func(x *= 2) is left value
func2(move(x)) is right value
func(y += 3) is left value
func2(move(x)) is right value
func(y * 3) is right value
func2(move(x)) is right value
```



传递结果是右值



```cpp
#include <iostream>
using namespace std;

#define func(x) __func(x, "func("#x")")
#define func2(x) __func2(x, "func2("#x")")

void __func2(int &x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is left value" << endl;
    return ;
}
void __func2(int &&x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is right value" << endl;
    return ;
}

void __func(int &x, const char *str) {
    // 判断是左值引用还是右值引用
    cout << str << " is left value" << endl;
    func2(x);
    return ;
}

void __func(int &&x, const char *str) {
    cout << str << " is right value" << endl;
    func2(forward<int &&>(x));
    return ;
}

class A {
public :
    A operator+(int x) {}   // 应该返回右值，返回值
    A &operator+=(int x) {} // 应该返回左值类型，所以返回了应该引用
};



int main() {

    int x = 1234, y = 456;
    int &rx = x; // 左值引用

    func(1234);
    func(x);
    func(x + y);
    func(x++);
    func(++x);
    func(x + 123);
    func(x += 123);
    func(x *= 2);
    func(y += 3);
    func(y * 3);




    return 0;
}

```





```cpp
func(1234) is right value
func2(forward<int &&>(x)) is right value
func(x) is left value
func2(x) is left value
func(x + y) is right value
func2(forward<int &&>(x)) is right value
func(x++) is right value
func2(forward<int &&>(x)) is right value
func(++x) is left value
func2(x) is left value
func(x + 123) is right value
func2(forward<int &&>(x)) is right value
func(x += 123) is left value
func2(x) is left value
func(x *= 2) is left value
func2(x) is left value
func(y += 3) is left value
func2(x) is left value
func(y * 3) is right value
func2(forward<int &&>(x)) is right value
```







move强制转换成右值

forward将当前值转换成目标类型



## 右值引用场景vector

```cpp
#include <iostream>
using namespace std;

namespace guziqiu {

class vector {
public :
    vector(int n = 10) : __size(n), data(new int[n]) {
        cout << "default constructor" << endl;
    }
    vector(const vector &v) : __size(v.size()), data(new int[__size]) { //  拷贝构造
        cout << "deep copy constructor" << endl;
        for (int i = 0; i < size(); i++) {
            data[i] = v[i];
        }
        return ;
    }
    vector operator+(const vector &v){ // 合并两个vector
        vector ret(v.size() + this->size());
        vector &now = *this;
        for (int i = 0; i < size(); i++) {
            ret[i] = now[i];
        }
        for (int i = size(); i < ret.size(); i++) {
            ret[i] = v[i - size()];
        }
        return ret;
    }
    int &operator[](int ind) const {
        return this->data[ind];
    }
    int size() const { return __size; }
private:
    int __size;
    int *data;
};


} // end of guziqiu

ostream &operator<<(ostream &out, const guziqiu::vector &v) {
    for (int i = 0; i < v.size(); i++) {
        out << v[i] << " ";
    }
    out << endl;
    return out;
}



int main() {

    guziqiu::vector v1, v2;
    for (int i = 0; i < v1.size(); i++) v1[i] = rand() % 100;
    for (int i = 0; i < v2.size(); i++) v2[i] = rand() % 100;

    guziqiu::vector v3(v1 + v2);
    cout << v1 << endl;
    cout << v2 << endl;
    cout << v3 << endl;


    return 0;
}
```



```cpp
g++ -fno-elide-constructors vector.cpp
default constructor
default constructor
default constructor
deep copy constructor
deep copy constructor
7 49 73 58 30 72 44 78 23 9

40 65 92 42 87 3 27 29 40 12

7 49 73 58 30 72 44 78 23 9 40 65 92 42 87 3 27 29 40 12
```

关掉编译器优化后显示发生了两次拷贝行为









## 右值引用移动构造



```cpp
#include <iostream>
using namespace std;

namespace guziqiu {

class vector {
public :
    vector(int n = 10) : __size(n), data(new int[n]) {
        cout << "default constructor" << endl;
    }
    vector(const vector &v) : __size(v.size()), data(new int[__size]) { //  拷贝构造
        cout << "deep copy constructor" << endl;
        for (int i = 0; i < size(); i++) {
            data[i] = v[i];
        }
        return ;
    }
    vector(vector &&v) : __size(v.size()), data(v.data) { // 移动构造， 传入右值引用构造函数,
        cout << "move copy constructor" << endl;
        v.data = nullptr;
        v.__size = 0;
    }
    vector operator+(const vector &v){ // 合并两个vector
        vector ret(v.size() + this->size());
        vector &now = *this;
        for (int i = 0; i < size(); i++) {
            ret[i] = now[i];
        }
        for (int i = size(); i < ret.size(); i++) {
            ret[i] = v[i - size()];
        }
        return ret;
    }
    int &operator[](int ind) const {
        return this->data[ind];
    }
    int size() const { return __size; }
    ~vector() {
        if (data) delete[] data;
        data = nullptr;
        __size = 0;
    }
private:
    int __size;
    int *data;
};


} // end of guziqiu

ostream &operator<<(ostream &out, const guziqiu::vector &v) {
    for (int i = 0; i < v.size(); i++) {
        out << v[i] << " ";
    }
    out << endl;
    return out;
}



int main() {

    guziqiu::vector v1, v2;
    for (int i = 0; i < v1.size(); i++) v1[i] = rand() % 100;
    for (int i = 0; i < v2.size(); i++) v2[i] = rand() % 100;

    guziqiu::vector v3(v1 + v2);
    cout << v1 << endl;
    cout << v2 << endl;
    cout << v3 << endl;


    return 0;
}
```



```cpp
g++ -fno-elide-constructors 42.vector.cpp
default constructor
default constructor
default constructor
move copy constructor
move copy constructor
7 49 73 58 30 72 44 78 23 9

40 65 92 42 87 3 27 29 40 12

7 49 73 58 30 72 44 78 23 9 40 65 92 42 87 3 27 29 40 12

```



发生了两次移动构造

 移动构造， 传如右值引用构造函数,

> 移动构造的好处：
>
> 减少匿名变量空间的开辟
>
> 速度变快，直接指向了变量地址



```cpp
#include <iostream>
using namespace std;

void func2(int &x) {
    cout << __PRETTY_FUNCTION__ << "called" << endl;
}

void func2(const int &x) { // 可以绑定任意版本
    cout << __PRETTY_FUNCTION__ << "called" << endl;
}

void func2(int &&x) {
    cout << __PRETTY_FUNCTION__ << "called" << endl;
}

void func2(const int &&x) {
    cout << __PRETTY_FUNCTION__ << "called" << endl;
}


int main() {
    int n;
    const int y = 123;
    // 优先绑定到最匹配的上面
    func2(n); // func2(int &) // 优先绑定到左值引用
    func2(y); // func2(const int &)
    func2(123 + 456); // func1(int &&)
    // func1(const int &&)

    return 0;
}
```

  

```cpp
void func2(int&)called
void func2(const int&)called
void func2(int&&)calledc
```





# 5.模板

泛型编程

## 5.1模板函数和模板类

> 泛型编程：
>
> 将==任意类型==从程序设计中抽象出来



|              | 泛型编程             |
| ------------ | -------------------- |
| 面向过程编程 | 用模板实现函数的过程 |
| 面向对象编程 | 用模板实现类         |



模板函数

```cpp
template<typename T>
T add(T a, T b) {
	return a + b;
}
```

> 模板的声明
>
> 在编译过程中，将模板生成相关代码，称为模板的实例化，
>
> 编译期看到的是实例化后的代码
>
> 模板的代码在运行的时候已经被干掉了
>
> 所以模板的代码必须写到头文件中

模板类

```cpp
template<typename T>
struct PrintAny{
  	PrintAny(std::ostream &out) : out(out) {}
    void operator() (const T &a) {
      out << a;
    } 
  	std::ostream &out;
};
```



模板实例化

模板在运行期才会实例化

## 模板函数

```cpp
#include <iostream>
using namespace std;

template<typename T, typename U>
decltype(T() + U()) add(T a, U b) { // decltype 类型锈化 调用了T的默认构造函数
    return a + b;
}

/*
int add(int a, int b) {
    return a + b;
}
int add(double a, double b) {
    return a + b;
}
*/
int main() {

    cout << add(1, 2) << endl;
    cout << add(1.2 ,2.2) << endl;
    cout << add<double>(1 ,2.2) << endl; // 强制将int转换成double
    cout << add(1 ,2.2) << endl;  // 改写模板

    decltype(1 + 2) x; // 根据(1 + 2)类型推导出 x 的类型
    if (typeid(x).hash_code() == typeid(int).hash_code()) cout << "int" << endl;

    return 0;
}
```



```
3
3.4
3.2
3.2
int
```





> decltype 返回值必须有默认构造函数才行，没有默认构造怎么办？

 ==返回值后置==



任意类型相加无bug版

```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() = delete;
    A(int x) : x(x) {}
    A operator+(const A &a) {
        return A(x + a.x);
    }
    friend ostream &operator<<(ostream &, const A &);
private :
    int x;
};

ostream &operator<<(ostream &out, const A &a) {
    out << a.x << endl;
    return out;
}


template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b){ // decltype 类型锈化 调用了T的默认构造函数
    return a + b;
}

auto func(int a, int b) -> int { // 返回值后置
    return a + b;
}

int main() {
    A a(3), b(5);
    cout << (a + b) << endl;
    cout << add(a, b) << endl;

    cout << add(1, 2) << endl;
    cout << add(1.2 ,2.2) << endl;
    cout << add<double>(1 ,2.2) << endl; // 强制将int转换成double
    cout << add(1 ,2.2) << endl;  // 改写模板

    decltype(1 + 2) x; // 根据(1 + 2)类型推导出 x 的类型
    if (typeid(x).hash_code() == typeid(int).hash_code()) cout << "int" << endl;

    return 0;
}

```

```cpp
8

8

3
3.4
3.2
3.2
int
```



```cpp
auto func(int a, int b) -> int { // 返回值后置
    return a + b;
}
```



## 模板类

```cpp
#include <iostream>
using namespace std;

template<typename T> // 模板类
class PRINT { // 可以打印任意类型的元素
public :
    PRINT &operator()(T a) {
        cout << a << endl;
        return *this;
    }
};

class PRINT2 { // 可以打印任意类型的元素
public :
    template<typename T> // 模板成员方法
    PRINT2 &operator()(T a) {
        cout << a << endl;
        return *this;
    }
};

int main() {
    PRINT<int> print_int;
    print_int(123);
    print_int(3455);
    PRINT<string> print_str;
    print_str("hello guziqiu");
    print_str("hello haizei");

    // 打印任意类型
    PRINT2 print;
    print(123)("hello guziqiu")(4456);



    return 0;
}
```



```cpp
123
3455
hello guziqiu
hello haizei
123
hello guziqiu
4456
```



## 模板类实现vector

```cpp
#include <iostream>
#include <vector>
using namespace std;

class A {
public:
    A() = delete;
    A(int x) : x(x) {}
    friend ostream &operator<<(ostream &, const A &);
private :
    int x;
};

ostream &operator<<(ostream &out, const A &a) {
    out << "Class A :" << a.x << " ";
    return out;
}

namespace guziqiu {
template<typename T>
class vector {
public :
    vector(int n = 10);
    vector(const vector<T> &);
    vector(vector<T> &);
    T &operator[](int);
    const T &operator[](int) const;
    int size() const;
    void push_back(const T &);
    void push_back(T &&);
    ~vector();
private :
    int __capacity;
    int __size;
    T *data;
};

template<typename T>
vector<T>::vector(int n) : __capacity(n), __size(0), data(nullptr) { // bug 1 data(new T[__size]) 如果T类没有默认构造函数会报错，
    data = (T *)malloc(sizeof(T) * __capacity);
    return ;
}

template<typename T>
vector<T>::vector(const vector<T> &v) : __size(v.size), __capacity(v.__capacity) { // 深拷贝
    //__size = v.__size;
    data = (T *)malloc(sizeof(T) * __capacity);
    for (int i = 0; i < __size; i++) {
        new(data + i) T(v.data[i]); // 原地构造
        //data[i] = v.data[i];  data[i]的存储区可能没有被构造
    }
    return ;
}

template<typename T>
vector<T>::vector(vector<T> &v) : __size(v.__size), data(v.data), __capacity(v.__capacity) { // 移动构造
    v.data = nullptr;
    v.__size = 0;
    v.__capacity = 0;
}

template<typename T>
T &vector<T>::operator[](int ind) {
    return data[ind];
}

template<typename T>
const T &vector<T>::operator[](int ind) const {
    return data[ind];
}

template<typename T>
int vector<T>::size() const { return __size; }

template<typename T>
void vector<T>::push_back(const T &d) {
   new(data + __size) T(d); // 调用相关类型的拷贝构造
   __size += 1;
   return ;
}
template<typename  T>
void vector<T>::push_back(T &&d) {
    new(data + __size) T(move(d)); // 调用相关类型的移动构造
    __size += 1;
    return ;
}

template<typename T>
vector<T>::~vector() {
    if (data) free(data);
    __size == 0;
    __capacity = 0;
    return ;
}

} // end of guziqiu

ostream &operator<<(ostream &out, const vector<A> &v) {
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return out;
}

ostream &operator<<(ostream &out, const guziqiu::vector<A> &v) {
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return out;
}


int main() {
    A a(1);
    cout << "vector :" << endl;
    //const vector<A> v;
    vector<A> v;
    //v.push_back(a);
    cout << v.size() << endl;
    v.push_back(123);
    v.push_back(456);
    v.push_back(789);
    cout << v << endl;
    cout << endl << "my vector :" << endl;
    //const guziqiu::vector<A> v2;
    guziqiu::vector<A> v2;
    cout << v2.size() << endl;
    v2.push_back(123);
    v2.push_back(456);
    v2.push_back(789);
    cout << v2 << endl;


    return 0;
}
```



```cpp
vector :
0
Class A :123  Class A :456  Class A :789

my vector :
0
Class A :123  Class A :456  Class A :789
```





## 引用折叠



```cpp
#include <iostream>
using namespace std;
namespace guziqiu {
template<typename T>
void swap(T &&a, T &&b) {
    T c; // declared as reference but not initialized
    c = a;
    a = b;
    b = c;
    return ;
}
} // end of guziqiu
int main() {
    int n = 123, m = 456;
    guziqiu::swap(n, m);
    cout << n << " " << m << endl;

    //guziqiu::swap(789, m);报错
    //cout << n << " " << m << endl;

    return 0;
}
```

 

模板在实例化时调用swap

因为n绑定到了引用上，编译器将 T &&转换为左值引用(因为n是左值引用)，

T 将会被推导为int &，所以T &&a== int &&&a, int &&&发生引用折叠—取奇数个&，最后还是int &a

```cpp
#include <iostream>
using namespace std;


namespace guziqiu {
template<typename T>
void swap(T &&a, T &&b) {
    typename remove_reference<T>::type c; // declared as reference but not initialized
    // remove_reference 去掉相关类型的引用, T == T &c  = a;
    c = a;
    a = b;
    b = c;
    return ;
}
} // end of guziqiu


int main() {
    int n = 123, m = 456;
    guziqiu::swap(n, m);
    cout << n << " " << m << endl;

    //guziqiu::swap(789, m);
    //cout << n << " " << m << endl;



    return 0;
}
```





> typename remove_reference<T>::type去掉相关类型的引用,



## 模板特化和模板偏特化

```cpp
#include <iostream>
using namespace std;

class A {
public :
    A() = delete;
    A(int x) : x(x) {}
    A operator+(const A &a) {
        return A(x + a.x);
    }
    friend ostream &operator<<(ostream &, const A &);
private :
    int x;
};

ostream &operator<<(ostream &out, const A &a) {
    out << a.x << endl;
    return out;
}

template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b){
    return a + b;
}


template<typename T, typename U>   // 模板偏特化，传入的是指针类型的变量
auto add(T *a, U *b) -> decltype(*a + *b){ // decltype 类型锈化 调用了T的默认构造函数
    return *a + *b;
}

template<>  // 模板的特化，特殊处理
int add(int a, int b) {
    return a + b * 2;
}


auto func(int a, int b) -> int {
    return a + b;
}

int main() {
    cout << "+++++++++++++" << endl;
    int n = 123, m = 456;
    int *p = &n, *q = &m;
    int **pp = &p, **qq = &q;

    cout << add(p, q) << endl; // 模板偏特化 传指针，
    cout << "++++" << endl;
    //cout << add(pp, qq) << endl; // 模板偏特化 传指针，

    cout << add(1, 2) << endl; // 调用的是特化版本


    return 0;
}
```

```cpp
+++++++++++++
579
++++
5
```





## 模板类特化

![截屏2021-03-28 下午8.06.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-28%20%E4%B8%8B%E5%8D%888.06.13.png)



## 变参模板



```cpp
#include <iostream>
using namespace std;

template<typename T>
void print(T a) { // 让递归终止在偏特化版本
    cout << a << endl;
    return ;
}


template<typename T, typename ...ARGS>
void print(T a, ARGS... args) { // 打印任意参数
    cout << a << endl;
    print(args...); // 每一次递归减少一个参数
    return ;
}


int main() {
    print(123, 34.6);
    print(123, "hello world", "haizei", 45.6);
    return 0;
}
```



```cpp
123
34.6
123
hello world
haizei
45.6
```







## 模板偏特化与可变参数模板

![截屏2021-03-28 下午8.06.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-28%20%E4%B8%8B%E5%8D%888.06.20.png)

![截屏2021-03-28 下午8.06.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-28%20%E4%B8%8B%E5%8D%888.06.47.png)

## 模板偏特化实现解析变参列表小工具

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

template<typename T, typename ...ARGS>
struct N_ARGS {   // 解析变参列表小工具
    typedef T type;
    typedef N_ARGS<ARGS...> rest;
};

template<typename T> // 偏特化版
struct N_ARGS<T> {
    typedef T type;
    typedef T last; // 控制变参列表的最后一个参数，不是最后一个会报错
};
 
template<typename T>
void print(T a) { // 让递归终止在偏特化版本
    cout << a << endl;
    return ;
}

template<typename T, typename ...ARGS>
void print(T a, ARGS... args) { // 打印任意参数
    cout << a << endl;
    cout << a << " next type : " << typeid(typename N_ARGS<ARGS...>::type).name() << endl;
    print(args...); // 每一次递归减少一个参数
//    N_ARGS<ARGS...>::type;// 第一个变量名称
//    N_ARGS<ARGS...>::rest; // 剩余变量名称
    return ;
}

int main() {
    print(123, 34.6);
    print(123, "hello world", "haizei", 45.6);
    
    N_ARGS<int, int, double, double>::type x;
    N_ARGS<int, int, double, double>::rest::type y;
    N_ARGS<int, int, double, double>::rest::rest::type z;
    N_ARGS<int, int, double, double>::rest::rest::rest::last w;

    cout << typeid(x).name() << endl;
    cout << typeid(y).name() << endl;
    cout << typeid(z).name() << endl;
    cout << typeid(w).name() << endl;
 
    return 0;
}
```



```cpp
123
123 next type : d
34.6
123
123 next type : PKc
hello world
hello world next type : PKc
haizei
haizei next type : d
45.6
i
i
d
d
```



//优化 -- 获取指定的第n个参数

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

template<typename T, typename ...ARGS>
struct N_ARGS {   // 解析变参列表小工具
    typedef T type;
    typedef N_ARGS<ARGS...> rest;
};

template<typename T> // 偏特化版
struct N_ARGS<T> {
    typedef T type;
    typedef T last; // 控制变参列表的最后一个参数，不是最后一个会报错
};


// 获取指定的第n个参数
template<int N, typename T, typename ...ARGS>
struct NewN_ARGS {   // 解析变参列表小工具
    typedef typename NewN_ARGS<N - 1, ARGS...>::type type;
    static int last() { // 是最后一个参数返回1
        return NewN_ARGS<N - 1, ARGS...>::last();
    }
};

template<typename T, typename ...ARGS> // 偏特化版
struct NewN_ARGS<1, T, ARGS...> {
    typedef T type;
    static int last() { return 0; }
};

template<typename T> // 偏特化版
struct NewN_ARGS<1, T> {
    typedef T type;
    static int last() { return 1; }
};


template<typename T>
void print(T a) { // 让递归终止在偏特化版本
    cout << a << endl;
    return ;
}

template<typename T, typename ...ARGS>
void print(T a, ARGS... args) { // 打印任意参数
    cout << a << endl;
    cout << a << " next type : " << typeid(typename N_ARGS<ARGS...>::type).name() << endl;
    print(args...); // 每一次递归减少一个参数
//    N_ARGS<ARGS...>::type;// 第一个变量名称
//    N_ARGS<ARGS...>::rest; // 剩余变量名称
    return ;
}

#define Test(func...) cout << #func << " = " << func << endl

int main() {
    print(123, 34.6);
    print(123, "hello world", "haizei", 45.6);


    N_ARGS<int, int, double, double>::type x;
    N_ARGS<int, int, double, double>::rest::type y;
    N_ARGS<int, int, double, double>::rest::rest::type z;
    N_ARGS<int, int, double, double>::rest::rest::rest::last w;

    cout << typeid(x).name() << endl;
    cout << typeid(y).name() << endl;
    cout << typeid(z).name() << endl;
    cout << typeid(w).name() << endl;


    NewN_ARGS<1, int, int, double, double>::type x1;
    NewN_ARGS<2, int, int, double, double>::type x2;
    NewN_ARGS<3, int, int, double, double>::type x3;
    NewN_ARGS<4, int, int, double, double>::type x4;


    Test(NewN_ARGS<1, int, int, double, double>::last());
    Test(NewN_ARGS<2, int, int, double, double>::last());
    Test(NewN_ARGS<3, int, int, double, double>::last());
    Test(NewN_ARGS<4, int, int, double, double>::last());



    return 0;
}
```

```cpp
123
123 next type : d
34.6
123
123 next type : PKc
hello world
hello world next type : PKc
haizei
haizei next type : d
45.6
i
i
d
d
NewN_ARGS<1, int, int, double, double>::last() = 0
NewN_ARGS<2, int, int, double, double>::last() = 0
NewN_ARGS<3, int, int, double, double>::last() = 0
NewN_ARGS<4, int, int, double, double>::last() = 1
```









## 模板的图灵完备性--判断素数

模板的图灵完备性：模板可以在编译期完成一套完整的流程



```cpp
#include <iostream>
using namespace std;


template<int i, int n>
struct getNextI {
    static constexpr int r = (n % i ? i + 1 : 0);
};

template<int i, int n>
struct getNextN {
    static constexpr int r = (i * i <= n ? n : 0);
};

template<int i, int n>
struct __test_prime {
    static constexpr int r = __test_prime<getNextI<i, n>::r, getNextN<i, n>::r>::r;
};
template<int n>
struct __test_prime<0, n> {
    static constexpr int r = 0;
};

template<int i>
struct __test_prime<i, 0> {
    static constexpr int r = 1;
};
template<>
struct __test_prime<0, 0> {
    static constexpr int r = 1;
};

template<int n>
struct if_condition {
    static constexpr const char *r = (n ? "YES" : "NO");
};

template<int n>
struct is_prime {
    static constexpr const char * r = if_condition<__test_prime<2, n>::r>::r;
};



int main() {

    cout << is_prime<2>::r << endl; // 1
    cout << is_prime<13>::r << endl; // 1
    cout << is_prime<25>::r << endl; // 0
    cout << is_prime<27>::r << endl; // 0
    cout << is_prime<9973>::r << endl; // 1
    cout << is_prime<1234>::r << endl; // 0


    return 0;
}
```





## 模板类实现循环判断

```cpp
#include <iostream>
using namespace std;

template<int N>
struct is_prime {
    static constexpr int r = 0;
};



// 模板类实现递归 循环求和
template<int n>
struct sum {
    static constexpr int r = n + sum<n - 1>::r;
};

template<>
struct sum<1> { // 特化版本 递归终结处
    static constexpr int r = 1;
};

// 模板类实现  if判断
template<int n>
struct getBad {
    static constexpr int r = (n <= 5);
};
template<int n>
struct getGood {
    static constexpr int r = (n > 5);
};

template<int n, int m>struct judge;
template<>
struct judge<1, 0> {
    static constexpr char *const r = (char *)"bad";
};
template<>
struct judge<0, 1> {
    static constexpr char *const r = (char *)"good";
};

template<int n>
struct score {
    static constexpr char *const r = judge<getBad<n>::r, getGood<n>::r>::r;
};


//is_even 判断奇数偶数
template<int n>
struct isEven {
    static constexpr int r = !(n % 2);
};
template<int n>struct judge1;
template<>
struct judge1<0> {
    static constexpr char *const r = (char *)"no";
};
template<>
struct judge1<1> {
    static constexpr char *const r = (char *)"yes";
};
template<int n>
struct is_even {
    static constexpr char *r = judge1<isEven<n>::r>::r;
};



int main() {
    cout << sum<5>::r << endl; // 1~5的和  模板类实现求和
    cout << score<10>::r << endl; // good 模板实现分支判断
    cout << score<4>::r << endl;  // bad
    cout << is_even<3>::r << endl; // no   判断奇数偶数
    cout << is_even<4>::r << endl; // yes

    cout << is_prime<2>::r << endl; // 1
    cout << is_prime<13>::r << endl; // 1
    cout << is_prime<25>::r << endl; // 0
    cout << is_prime<27>::r << endl; // 0
    cout << is_prime<9973>::r << endl; // 1
    cout << is_prime<1234>::r << endl; // 0




    return 0;
}
```

```cpp
15
good
bad
no
yes
0
0
0
0
0
0
```



## 模板与宏定义的区别



模板能在编译期完成一套完整的流程

宏定义只是简单的替换

程序一般是在运行期完成的





## 5.2异常throw



```cpp
#include <iostream>
using namespace std;

int main() {
    int age = 100;

    // cin >> age;
    try {
        if (age > 90) {
            cout << "before throw" << endl;
            throw(age);
            cout << "123" << endl;
        } else {
            cout << age << "---" << endl;
        }
    }

    catch(int age) {
        cout << age << " is too big" << endl;
    }


    return 0;
}
```



```cpp
before throw
100 is too big
```



> 抛出异常
>
> throw后面的语句不会被执行

## throw代码演示1

```cpp
#include <iostream>
using namespace std;

class guziqiu : public exception {
public :
    guziqiu() = default;
    guziqiu& operator=(const guziqiu &) = default;

    const char* what() { // 解释异常
        return "I'm don't know what happened !";
    }


    ~guziqiu() = default;
};


void inner() {
    try {
        throw(guziqiu());
    }
    catch(guziqiu &e) {// 捕获异常按顺序执行
        cout << "inner exception caught first" << endl;
    }


    catch(guziqiu &e) {
        cout << e.what() << "inner exception caught second " << endl;
    }
}

void outer() {
    try {
        inner();
    }
    catch(...) { // 捕获任意异常
        cout << "outer expection caught" << endl;
    }
}


int main() {
    int age = 100;

    outer();



    // cin >> age;
    try {
        if (age > 90) {
            cout << "before throw" << endl;
            throw(age);
            cout << "123" << endl;
        } else {
            cout << age << "---" << endl;
        }
    }

    catch(int age) {
        cout << age << " is too big" << endl;
    }


    return 0;
}
```



```cpp
inner exception caught first
before throw
100 is too big
```



>1.catch捕获异常按顺序执行
>
>2.`catch(...)`代表捕获所有异常
>
>3.如果函数内部有捕获异常的处理，则会优先被内层捕获



## throw代码演示2



```cpp
#include <iostream>
using namespace std;

class Hellper {
public :
    Hellper() {
        cout << "constructor called" << endl;
    }
    ~Hellper() {
        cout << "deconstructor called" << endl;
    }
};

void inner() {
    cout << "inner begin " << endl;
    try {
        Hellper h = Hellper();
        throw("123");
    }

    catch(...) {
        cout << "exception caught" << endl;
    }
    cout << "inner endl" << endl;

}

void outer() {
    try {
        cout << "outer begin" << endl;
        inner();
    }
    catch(...) {
        cout << "outer exception caught" << endl;
    }
    cout << "outer endl" << endl;
}


int main() {

    outer();

    return 0;
}
```



```cpp
outer begin
inner begin
constructor called
deconstructor called
exception caught
inner endl
outer endl
```





> 在抛出异常之前Helper已经被析构



## throw-&

```cpp
#include <iostream>
using namespace std;

class Hellper {
public :
    Hellper() {
        cout << "constructor called" << endl;
    }
    ~Hellper() {
        cout << "deconstructor called" << endl;
    }
};

class myerror : public exception {
public :
    const char * what() {
        return "expection myerror";
    }
    string s;

};


void inner() {
    cout << "inner begin " << endl;
    try {
        Hellper h = Hellper();
        throw("123");
    }

    catch(...) {
        cout << "exception caught" << endl;
    }
    cout << "inner endl" << endl;

}

void outer() {
    try {
        cout << "outer begin" << endl;
        throw myerror();
        //inner();
    }
    catch(myerror err) { // catch(myerror& err) {
        err.s = "hello";
        cout << "outer exception caught err" << endl;
        cout << "&err.s" << &err.s << " : " << err.s << endl;
        throw;// 继续向上层抛出异常
    }
    cout << "outer endl" << endl;
}


int main() {
    try {
        outer();
    }
    catch(myerror err) { // catch(myerror& err) {

        cout << "catch err in main" << endl;
        cout << &err.s << endl;
        cout << err.s << endl;
    }

    return 0;
}
```



```cpp
outer begin
outer exception caught err
&err.s0x7fae4c405b48 : hello
catch err in main
0x7fae4c405b48
hello
```



> 异常加引用后可以修改原函数的值
>
> 如果不加引用会生成新的变量或者对象



指定函数不能抛出异常，调优函数的执行性能



## noexcept



```cpp
#include <iostream>
#include <exception>
#include <stdexcept>
using namespace std;

const char* foo() noexcept { // 检测到发出异常后，直接会被CPU干掉，即使外层有catch也捕获不到
    throw("123");
    return "noexcept";
}


int main() {

    try {
       cout <<  foo() << endl;//
    }
    catch(...) {
        cout << "noexcept caught" << endl;
    }


    return 0;
}
```







```cpp
#include <iostream>
#include <vector>
#include <exception>
#include <stdexcept>
using namespace std;

const char* foo() noexcept { // 检测到发出异常后，直接会被CPU干掉，即使外层有catch也捕获不到
    //throw("123");
    return "noexcept";
}

void Process(int v) {
    if (v > 3) {
        throw runtime_error("mumber too big");
    }
}

int main() {

    vector<int> v = {1, 2, 3, 4, 5};
    for (int i = 0; i < 5; i++) {
        try {
            Process(v[i]);
            cout << v[i] << endl;
        } catch(runtime_error &e) {
            cout << e.what() << endl;
        }
    }

    return 0;
}
```



```cpp
1
2
3
mumber too big
mumber too big
noexcept
```





Fault(DE, Division Error) 执行时触发，异常处理后返回当前语句



Trap(int 3)执行后触发，异常处理后返回的是下一句

Abort() 执行后直接宕机

异常本身是一个转移控制流的机制

缺页异常







系统栈有两个指针

爆栈：栈的上溢

栈溢出：栈的下溢，写数据超出了自己的范围



# 6.C++STL

## 1.string

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s = "abc";
    cout << s << endl;
    s += "abc";
    cout << s << endl;
    string s1 = "123";
    s += s1;
    cout << s << endl;
    string s3 = "222";
    s.append(s3);
    cout << s << endl;
    string s4 = s1 + s3;
    cout << s4 << endl;
    cout << s << endl;
    cout << s.find("1") << endl;

    cout << s << endl;
    s.replace(0, 2, "111");
    cout << s << endl;

    string s11 = "abcd";
    string s12 = "abcd";
    cout << s11.compare(s12) << endl;
    //cout << s12 - s11 << endl;
    if (s11.compare(s12) == 0) {
        cout << "==" << endl;
    } else if(s11.compare(s12) < 0){
        cout << "<" << endl;
    } else {
        cout << ">" << endl;
    }
    cout << "+====" << endl;
    cout << s << endl;
    cout << s.substr(1, 3) << endl;
    cout << s << endl;

    cout << "+====" << endl;
    cout << s << endl;
    cout << s.insert(3, "kkk") << endl;
    cout << s << endl;
    s.erase(0, 2);
    cout << s << endl;


    return 0;
}

```



## 2.vector

```cpp
#include <iostream>
#include <vector>
using namespace std;

/// 初始化
//vector<T> v; /// 采用模板类实现。默认构造
// vector(v.begin(), v.end()); // vector<int> v1(arr, arr + sizeof(arr/ sizeof(int)));
// vector(n, elem)   
// vector(const vector &vec);
// int arr[] = {2, 3, 4, 1, 9};
void test01() {
    vector<int> v1;
    int arr[] = {10, 20, 30, 40};
    vector<int> v2(arr, arr + sizeof(arr) / sizeof(int));
    vector<int> v3(v2.begin(), v2.end());
    vector<int> v4(v2);
    for (vector<int>::iterator it = v4.begin(); it != v4.end(); ++it) {
        cout << (*it) << endl;
    }
    return ;
}
// 赋值
void test02() {
    int arr[] = {10, 20, 30, 40};
    vector<int> v1(arr, arr + sizeof(arr) / sizeof(int));
    
    vector<int> v2;
    v2.assign(v1.begin(), v1.end());

    for (vector<int>::iterator it = v2.begin(); it != v2.end(); ++it) {
        cout << (*it) << endl;
    }
    return ;
}

// 大小操作
void test3() {
    int arr[] = { 100, 200, 300, 400};
    vector<int> v(arr, arr + sizeof(arr) / sizeof(int)); // 默认构造
    cout << "size : " << v.size() << endl;
    if (v.empty()) {
        cout << "空！" << endl;
    } else {
        cout << "不空" << endl;
    }
    for (auto it : v) cout << it << " ";
    cout << endl;
    v.resize(2); // 扔掉后面的
    for (auto it : v) cout << it << " ";
    cout << endl;
    v.resize(6, 1); // 增加后面的， 默认1
    for (auto it : v) cout << it << " ";
    cout << endl;

    cout << "size :" << v.size() << endl;
    cout << "容量capacity :" << v.capacity() << endl;

    return ;
}

// 存取数据
void test4() {
    int arr[] = { 100, 200, 300, 400};
    vector<int> v(arr, arr + sizeof(arr) / sizeof(int)); // 默认构造
    cout << "size : " << v.size() << endl;
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    cout << endl;
    // cout << v[v.size()] << endl; // 不会抛出异常
    for (int i = 0; i < v.size(); i++) {
        cout << v.at(i) << " ";
    }
    cout << endl;
    // cout << v.at(v.size()) << endl;// 会抛出异常

    cout << "front : " << v.front() << endl;
    cout << "back : " << v.back() << endl;

    return ;
}

// 插入和删除
void test5() {
    vector<int> v;
    v.push_back(10);
    v.push_back(20);

    // 头插法
    v.insert(v.begin(), -1);
    v.insert(v.end(), 30);
    v.insert(v.begin() + 2, 222); // vector支持随机访问
    // 支持数组下表，一般都支持随机访问
    // 迭代器可以直接 + 2 + 3 -2  -5操作
    for (auto it : v) cout << it << " ";
    cout << endl;

    // 删除
    v.erase(v.begin());
    for (auto it : v) cout << it << " ";
    cout << endl;
    v.erase(v.begin() + 1, v.end());
    for (auto it : v) cout << it << " ";
    cout << endl;
    v.clear();
    cout << "size : " << v.size() << endl;

}

// 巧用swap缩减空间
void test6() {
    // vector添加元素 他会自动增长， 你删除的元素的时候，他不会自动减少
    vector<int> v;
    for (long long i = 0; i < 10000000; i++) {
        v.push_back(i);
    }
    cout << "size : " << v.size() << endl;
    cout << "capacity :" << v.capacity() << endl;


    v.resize(10);
    cout << "=======" << endl;
    cout << "size : " << v.size() << endl;
    cout << "capacity :" << v.capacity() << endl;

    vector<int>(v).swap(v);
    cout << "=======" << endl;
    cout << "size : " << v.size() << endl;
    cout << "capacity :" << v.capacity() << endl;
}

//  
void test7() {
    // resverse 预留空间 resize 区别
    vector<int> v;
    int num = 0;
    int *address = NULL;
    v.reserve(100000);
    for (int i = 0; i < 10000000; i++) {
        v.push_back(i);
        if (address != &(v[0])) {
            address = &(v[0]);
            num++;
        }
    }
    cout << "num : " << num << endl;
    // 如果知道需要的空间，可以用reverse预留空间，减少拷贝新空间的时间

}


int main() {

    test7();

    return 0;
}

```



## 3.dequeue

```cpp
#include <iostream>
#include <deque>
using namespace std;

//dequeue 双端队列， 
// 可以从尾部插入，删除push_bck,pop_back
// 可以从头部插入，删除 pop_front, push_front
// 和vector一样，支持随机存储，双向开口的连续性空间，在头部插入常数
// 动态 连续空间 随时可以增加一端新的空间，没有容器的概念
// 插入删除元素效率高
// 指定位置插入会导致元素移动，降低效率
// 支持随机存取，效率高

// 初始化
void test1() {
    deque<int> d;
    deque<int> d2(10, 5);
    deque<int> d3(d2.begin(), d2.end());
    deque<int> d4(d3);

    for (auto it : d4) {
        cout << it << " ";
    }
    cout << endl;

}


// 赋值 初始化
void test2() {
    deque<int> d;
    deque<int> d2;
    deque<int> d3;
    d.assign(10, 2);

    for (int it : d) {
        cout << it << " ";
    }
    cout << endl;

    d2.assign(d.begin(), d.end());
    for (int it : d2) {
        cout << it << " ";
    }
    cout << endl;

    // assign(beg, end)将[beg, end) 区间中的数据拷贝赋值给本身
    // assign(n, elem); 将n个elem拷贝赋值给本身

    d3 = d2;// 等号赋值
    for (int it : d3) {
        cout << it << " ";
    }
    cout << endl;

    // 自动清 0,在缓冲区排序
     
    d.swap(d2); // 交换两个空间的元素
    

    if (d.empty()) { // 判断容器是否为空
        cout << "空 ！"  << endl; 
    } else {
        cout << "非空！"  << endl;
    }
    cout << endl;
    d.resize(5); // 10个元素，后5个元素扔掉
    for (auto it : d) {
        cout << it << " ";
    }
    cout << endl;
}

void test3() {
    // deque插入和删除
    deque<int> d1;
    d1.push_back(100);
    d1.push_front(200);
    d1.push_back(200);
    d1.push_back(300);
    d1.push_front(300);
    for (deque<int>::iterator it = d1.begin(); it != d1.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    int val = d1.front();
    d1.pop_front();
    cout << val << endl;
    cout << d1.back() << endl;
    d1.pop_back(); // 删除最后一个元素
    for (deque<int>::iterator it = d1.begin(); it != d1.end(); ++it) {
        cout << *it << " ";
    }
    return ;
}

int main() {
    test3();

    return 0;
}

```



## 4.stack

```cpp
#include <iostream>
#include <stack>
using namespace std;

void test1() {
    stack<int> s, s2(s);
    // stack操作
    s.push(10);
    s.push(20);
    s.push(30);
    s.push(100);
    //cout << "top : " << s.top() << endl;
    while (!s.empty()) {
        cout << "top : " << s.top() << endl;
        s.pop();
    }
    cout << "size :" << s.size() << endl;
    
}
// 栈不能遍历,不支持随机存储

int main() {
    test1();

    return 0;
}

```

## 5.queue

```cpp
#include <iostream>
#include <queue>
using namespace std;

// queue 容器 队列容器 先进先出

void test() {
    queue<int> q, q2(q);
    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);
    cout << "back : " << q.back() << endl;

    while (!q.empty()) {
        cout << q.front() << endl;
        q.pop();
    }
    cout << "size : " <<  q.size() << endl;


}

int main() {
    test();

    return 0;
}

```

## 6.list

```cpp
#include <iostream>
#include <list>
using namespace std;

// 链表 是由一系列的结点组成，结点包含两个域，一个数据域，一个指针域
// 链表内存是非连续的，
// 添加删除效率高， 时间复杂度是常数，不需要移动元素，比数组添加删除效率高
// 链表只有在需要的时候，才分配内存
// 需要额外的空间保存结点关系， 有前驱和后继

// 初始化 

void test() {
    list<int> l;
    list<int> l2(10, 10); // 有参构造
    list<int> l3(l2); // 拷贝构造
    list<int> l4(l3.begin(), l3.end());

    for (auto i : l4) {
        cout << i << " ";
    }
    cout << endl;
    
}
void test1() {
    list<int> l1;
    l1.push_back(100);
    l1.push_front(200);
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;


    l1.insert(l1.begin(), 300);
    l1.insert(l1.end(), 300);
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;

    list<int>::iterator it = l1.begin();
    l1.insert(++(++it), 500);
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;
    l1.remove(300); // 删除匹配的所有值
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;
    

    l1.pop_back();
    l1.pop_front();

    l1.erase(l1.begin(), l1.end());
    return ;
    
}

// 大小操作 赋值操作
void test2() {
    list<int> l1;
    l1.assign(10, 10);
    list<int> l2;
    l2 = l1;
    for (auto i : l2) {
        cout << i << endl;
    }
    cout << endl;
    l1.swap(l2);
}
// 反转
void test4() {
    list<int> l1;
    for (int i = 0; i < 10; i++) {
        l1.push_back(i);
    }
    l1.reverse();
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;
}
bool cmp(int x, int y) {
    return x > y;
}
// 排序
void test5() {
    list<int> l1;
    l1.push_back(2);
    l1.push_back(1);
    l1.push_back(5);
    l1.push_back(9);

    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;
    l1.sort();  // 默认从小到大
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;

    l1.sort(cmp); // 从大到小
    for (auto i : l1) {
        cout << i << " ";
    }
    cout << endl;
    

}

//  sort仅支持可随机访问的容器
// list不支持随机访问


int main() {
    test5();

    return 0;
}

```



## 7.set

```cpp
#include <iostream>
#include <set>
using namespace std;
// set/multiset 插入的时候会自动排序
// set 所有的值都是不相等的
// multiset 可以有重复的值
// 可以通过set迭代器可以改变元素的值吗？ 
// 不可以，删除结点再加上结点

//    初始化 自动排序 默认从小到大  拷贝构造  

// 仿函数
class mycompare {
public :  
    bool operator()(int v1, int v2) {
        return v1 > v2;
    }
};
void test1() {
    
    set<int> s1;
    s1.insert(7);
    s1.insert(3);
    s1.insert(2);
    s1.insert(6);
    s1.insert(4);
    s1.insert(10);
    s1.insert(2);

    for (set<int>::iterator it = s1.begin(); it != s1.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    // 赋值操作
    set<int> s2 = s1;

    // 删除操作
    s1.erase(s1.begin());
    s1.erase(7);
    for (set<int>::iterator it = s1.begin(); it != s1.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    // cout << "====" << endl;
    // // 改变默认排序 从大到小
    // set<int, mycompare> s3;
    // s3.insert(7);
    // s3.insert(3);
    // s3.insert(2);
    // s3.insert(6);
    // s3.insert(4);
    // s3.insert(10);
    // s3.insert(2);
    // for (set<int>::iterator it = s1.begin(); it != s1.end(); ++it) {
    //     cout << *it << " ";
    // }
    // cout << endl;

}

// 查找
void test2() {
    // 实值
    set<int> s1;
    s1.insert(7);
    s1.insert(3);
    s1.insert(2);
    s1.insert(6);
    s1.insert(4);
    s1.insert(10);
    s1.insert(2);

    for (set<int>::iterator it = s1.begin(); it != s1.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    set<int>::iterator ret = s1.find(4);
    if (ret == s1.end()) {
        cout << "没有找到！" << endl;
    } else {
        cout << "ret  : " << *ret << endl;
    }
    // 找到第一个>=key的元素
    ret = s1.lower_bound(11);
    if (ret == s1.end()) {
        cout << "没有找到" << endl;
    } else {
        cout << "ret : " << *ret << endl;
    }
    //  找到第一个大于key的值
    ret = s1.upper_bound(2);
    if (ret == s1.end()) {
        cout << "没有找到" << endl;
    } else {
        cout << "ret : " << *ret << endl;
    }

    // equal_range返回 lower_bound 和 upper_bound 返回两个迭代器 
    pair<set<int>::iterator, set<int>::iterator> myret = s1.equal_range(2);
    if (myret.first == s1.end()) {
        cout << "没有找到" << endl;
    } else {
        cout << "找到 lower_bound : " << (*myret.first) << endl;
    }
    if (myret.second == s1.end()) {
        cout << "没有找到" << endl;
    } else {
        cout << "找到 upper_bound : " << (*myret.second) << endl;
    }

}
class Person {
public :
    Person(int id, int age) : id(id), age(age) {}
    
public :
    int id;
    int age;
};
class cmp{
public :
    bool operator()(Person p1, Person p2) const {
        return p1.age < p2.age;
    }
};
void test3() {
    set<Person, cmp> s1;
    Person p1(10, 50), p2(30, 40), p3(50, 60);
    
    s1.insert(p1);
    s1.insert(p2);
    s1.insert(p3);

    for (auto i : s1) {
        cout << i.id << " " << i.age << endl;;
    }
    cout << endl;

    // 查找
    Person p4(10, 60);
    set<Person, cmp>::iterator ret = s1.find(p4);
    if (ret == s1.end()) {
        cout << "没有找到" << endl;
    } else {
        cout << "找到 只会根据age查找，因为是根据age排序的:" << (*ret).id << " " << (*ret).age << endl;
    }

}

int main() {
    test3();

    return 0;
}

```

## 8.pair

```cpp
#include <iostream>
#include <string>
using namespace std;

// 对组 pair
void test() {
    

    // 构造方法
    pair<int, int> p(10, 20);
    cout << p.first << " " << p.second << endl;

    pair<int, string> p2 = make_pair(10, "guziqiu");
    cout << p2.first << " " << p2.second << endl;

    pair<int, string> p3 = p2;
}


int main() {
    test();

    return 0;
}

```



## 9.map

```cpp
#include <iostream>
#include <map>
using namespace std;

// map初始化
void test1() {
    map<int,int> mymap; // map容器模板参数，第一个参数key的类型，第二个参数value的类型
     
    // 插入数据  pair.first   key值， pair.second value值
    // 1
    pair<map<int, int>::iterator, bool> ret = mymap.insert(pair<int, int>(10, 10));
    if (ret.second) {
        cout << "第一次插入成功 " << endl;
    } else {
        cout << "插入失败" << endl;
    }



    // 第二种
    ret = mymap.insert(make_pair(10, 20));
    if (ret.second) {
        cout << "第二次插入成功 " << endl;
    } else {
        cout << "第二次插入失败" << endl;
    }

    // 3
    ret = mymap.insert(map<int, int>::value_type(30, 30));
    if (ret.second) {
        cout << "第三次插入成功 " << endl;
    } else {
        cout << "插入失败" << endl;
    }
    // 4
    mymap[40] = 40;
    mymap[50] = 5;
    mymap[10] = 100;
    // 如果发现key不存在，会创建pair插入到map的容器中
    // 如果发现key存在，那么会修改key对应的value
    cout << mymap[90] << endl;
    // 如果通过方括号的方式访问map中一个不存在的key,
    // 那么map会将这个访问的key插入到map中，并进行默认初始化

    // 打印
    for (map<int, int>::iterator it = mymap.begin(); it != mymap.end(); ++it) {
        cout << (*it).first << " " << (*it).second << " ++  ";
        cout << it->first << " " << it->second << endl;
    }
    cout << endl;
    for (auto i : mymap) {
        cout << i.first << " " << i.second << endl;
    }
    
}

class mykey {
public :
    mykey(int ind, int id) {
        this->mind = ind;
        this->nid = id;
    }
    int mind;
    int nid;
};
struct cmp {
    bool operator()(mykey k1, mykey k2) const {
        return k1.mind < k2.mind;
    }
};
void test2() {
    map<mykey, int, cmp> mymap;
    mymap.insert(make_pair(mykey(1,2), 10));
    mymap.insert(make_pair(mykey(4,5), 20));
    for (auto i : mymap) {
        cout << i.first.mind << " " << i.first.nid << " = " << i.second << endl;
    }
}


int main() {
    test2();

    return 0;
}

```

## 10.multmap

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {


    return 0;
}

```



# 6.C++线程的简单使用

## 1.thread

```cpp
#include <iostream>
#include <thread>
using namespace std;

void func(int x) {
    for (int i = 0; i < x; i++)   cout << i << endl;
    return ;
}

void add_one(int &x) {
    x += 1;
    return ;
}

int main() {

    int n = 8;
     //thread t1(func, 30);
    //thread t2(func, 30); // 同时输出两个数子说明是多线程
    thread t1(add_one, ref(n)); // 传引用需要加&
    t1.join();
    //t2.join();
    cout << "hello world" << endl;
    cout << n << endl; // 9

    return 0;
}

```



```cpp
hello world
9
```





## 2.bind

```cpp
#include <iostream>
#include <functional>
#include <thread>
using namespace std;

void add_one(int &x) {
    cout << "add_one function " << endl;
    x += 1;
    return ;
}

class Task {
public :
    template<typename FUNCTION, typename ...ARGS>
    Task(FUNCTION &&f, ARGS ...args) {
        cout << "Task constructor" << endl;
        this->f = bind(f, forward<ARGS>(args)...); // 参数和变量的绑定
    }
    void run() {
        f();
    }
private :
    function<void()> f;

};


int main() {
     int n = 8;
     thread t1(add_one, ref(n));
     Task t2(add_one, ref(n));
     t1.join();
     t2.run();
     t2.run();
     t2.run();
     cout << n << endl;

    return 0;
}
```



```cpp
Task constructor
add_ont function
add_ont function
add_ont function
add_ont function
12
```





bind将变量与参数绑定



> bind基本使用



```cpp
#include <iostream>
using namespace std;

void func(int x) {
    cout << x << endl;
    return ;
}


int main() {


    func(123);
    func(123);
    func(123);
    func(123);
    func(123);

    auto f = bind(func, 123);
    cout << "=========" << endl;

    f();
    f();
    f();
    f();
    f();



    return 0;
}
```

```cpp
123
123
123
123
123
=========
123
123
123
123
123
```





> 将相关参数和相关函数绑定，封装出一个新的函数



## bind--placeholders参数占位符

```cpp
#include <iostream>
using namespace std;

void add(int a, int b) {
    cout << a << " + " << b << endl;
    return ;
}

int main() {

    cout << "========" << endl;
    auto add3 = bind(add, 3, std::placeholders::_1); // bind完成部分参数绑定, 预留槽位
    // placeholders 参数占位符
    //
    add3(45);
    add3(89);
    add3(100);


    return 0;
}
```



```cpp
3 + 45
3 + 89
3 + 100
```



```cpp
#include <iostream>
using namespace std;

void add(int a, int b) {
    cout << a << " + " << b << endl;
    return ;
}

int main() {

    cout << "========" << endl;
    auto add3 = bind(add, 3, std::placeholders::_1); // bind完成部分参数绑定, 预留槽位
    // placeholders 参数占位符
    //
    add3(45);
    add3(89);
    add3(100);

    cout << "===" << endl;
    auto add2  = bind(add, std::placeholders::_1, std::placeholders::_2);
    add2(3, 4);

    auto add4  = bind(add, std::placeholders::_2, std::placeholders::_1);
    add4(3, 4);
    // 参数占位符
    // bind(function, 1, 2)
    // 1 ： 新函数中第一个参数
    // 2 ： 新函数第二个参数


    return 0;
}

```



```cpp
========
3 + 45
3 + 89
3 + 100
===
3 + 4
4 + 3
```















```cpp
#include <iostream>
using namespace std;
void func(int x) {
    for (int i = 0; i < x; i++)   cout << i << endl;
    return ;
}


void add(int a, int b) {
    cout << a << " + " << b << endl;
    return ;
}

void test_ref(int &x) {
    x = 1;
    cout <<  "test_ref function" << endl;
}

int main() {

    cout << "========" << endl;
    auto add3 = bind(add, 3, std::placeholders::_1); // bind完成部分参数绑定, 预留槽位
    // placeholders 参数占位符
    //
    add3(45);
    add3(89);
    add3(100);

    cout << "===" << endl;
    auto add2  = bind(add, std::placeholders::_1, std::placeholders::_2);
    add2(3, 4);

    auto add4  = bind(add, std::placeholders::_2, std::placeholders::_1);
    add4(3, 4);
    // 参数占位符
    // bind(function, 1, 2)
    // 1 ： 新函数中第一个参数
    // 2 ： 新函数第二个参数

    cout << "===" << endl;

    int n = 0;
    // auto ref_func = bind(test_ref, n);   //                     0  0
    auto ref_func = bind(test_ref, ref(n)); // 显示性的调用引用    0  1
    cout << n << endl;
    ref_func();
    cout << n << endl;
  }
```



```cpp
========
3 + 45
3 + 89
3 + 100
===
3 + 4
4 + 3
===
0
test_ref function
1
```





## function和bind

```cpp
#include <iostream>
using namespace std;
void func(int x) {
    for (int i = 0; i < x; i++)   cout << i << endl;
    return ;
}


void add(int a, int b) {
    cout << a << " + " << b << endl;
    return ;
}

void test_ref(int &x) {
    x = 1;
    cout <<  "test_ref function" << endl;
}

int main() {

    // function高级函数指针对象 可以指向任意可调用对象   bind一般配合function使用
    // <void()> 返回void类型，()没有参数
    // y一个负责绑定函数，一个负责返回值类型
    function<void()> f = bind(func, 3);
    f();

    cout << "===" << endl;
    function<void(int)> add5 = bind(add, 3, std::placeholders::_1);
    add5(3);
    add5(45);

    function<void(int, int)> add6 = bind(add, std::placeholders::_2, std::placeholders::_1);
    add6(3, 4);

    cout << "===" << endl;

    int n = 0;
    function<void()> ref_func1 = bind(test_ref, ref(n)); // 显示性的调用引用    0  1
    cout << n << endl;
    ref_func1();
    cout << n << endl;

    cout << "=========" << endl;
    auto add8 = bind(add, std::placeholders::_4, std::placeholders::_1);
    add8(1, 2, 3, 4);




    return 0;
}
```



```cpp
0
1
2
===
3 + 3
3 + 45
4 + 3
===
0
test_ref function
1
=========
4 + 1
```



## function模板类的封装



```cpp
#include <iostream>
#include <functional>
using namespace std;

namespace guziqiu {

template<typename T, typename ...ARGS>
class base {
public :
    virtual T run(ARGS...) = 0;
    virtual base<T, ARGS...> *getCopy() = 0;
    virtual ~base() {}
};

template<typename T, typename ...ARGS>
class normal_func : public base<T, ARGS...> {// base 派生类
public :
    typedef T (*FUNC_T)(ARGS...);
    normal_func(FUNC_T func) : func(func) {}
    T run(ARGS ...args) override {
        return func(forward<ARGS>(args)...);
    }
    base<T, ARGS...> *getCopy() override {
        return new normal_func(func);
    }

private:
    FUNC_T func;
};

template<typename C, typename T, typename ...ARGS>
class functor : public base<T, ARGS...>{// base 派生类
public :
    functor(C obj) : obj(obj) {}
    T run(ARGS ...args) override {
        return obj(forward<ARGS>(args)...);
    }
    base<T, ARGS...> *getCopy() override {
        return new functor(obj);
    }

private :
    C obj;
};


template<typename T, typename ...ARGS> class function;
template <typename T, typename ...ARGS> // 模板类的偏特化版本
class function<T(ARGS...)> {
public :
    function(T (*ptr)(ARGS...)) : fptr(new normal_func<T, ARGS...>(ptr)) {} // 兼容普通指针类型
    template<typename C>
    function(C object) : fptr(new functor<C, T, ARGS...>(object)) {}

    function(const function &obj) {
        cout << "copy constructor" << endl;
        this->fptr = obj.fptr->getCopy();// 深拷贝
    } // 拷贝构造

    function(function<T(ARGS...)> &&obj) : fptr(obj.fptr){
        this->fptr = obj.fptr;
    } // 移动构造

    function &operator=(function &obj) { // 左值赋值运算符
        if (this == &obj) return *this;
        if (this->fptr) delete this->fptr;
        this->fptr = obj.fptr->getCopy();
        return *this;
    }
    function &operator=(function &&obj) { // 右值赋值运算符
        if (this == &obj) return *this;
        this->fptr = obj.fptr;
        obj.fptr = nullptr;
        return *this;
    }

    T operator()(ARGS ...args) {
        return fptr->run(forward<ARGS>(args)...);
    }
    ~function() {
        if (fptr != nullptr) delete fptr;
        fptr = nullptr;
    }
private :
    base<T, ARGS...> *fptr;
};

} // end of guziqiu

void func(int a, int b) {
    cout << "normal function" << endl;
    return ;
}

class ADD_FUNC {
public :
    ADD_FUNC() : x(0) {}
    void operator()(int a, int b) {
        x += a + b;
        cout << "class object : " << x << endl;
        return ;
    }
    int x;
};

int main() {
    ADD_FUNC add;
    function<void(int, int)> F1 = func;
    function<void(int, int)> F2 = add;
    F1(3, 4);
    F2(3, 4);
    F2(5, 6);

    guziqiu::function<void(int, int)> f1 = func;
    guziqiu::function<void(int, int)> f2 = add;
    f1(3, 4);
    f2(3, 4);
    f2(5, 6);

    guziqiu::function<void(int, int)> f3(f2);
    f3(7, 8);
    f3 = f1;
    f3(7, 8);

    return 0;
}

```

```cpp
normal function
class object : 7
class object : 18
normal function
class object : 7
class object : 18
copy constructor
class object : 33
normal function
```



## random随机函数的实现

```cpp
#include <iostream>
using namespace std;

namespace guziqiu {
    static int __seed = 3;
    void srand(int seed) {
        __seed = seed;
        return ;
    }
    int rand() {
        return __seed = __seed * 3 % 101; // 只能保证等改率输出101
    }
} // end of guziqiu


int main() {
    guziqiu::srand(time(0));
    for (int i = 0; i < 10; i++) {
        cout << guziqiu::rand() << endl;
    }

    return 0;
}

```







进程：操作系统分配资源的最小单位

多个线程



线程：消费者，

添加任务的线程：生产者



## thread线程池的简单实现



```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <queue>
#include <unordered_map>
#include <mutex>
#include <condition_variable> // 条件型号量

namespace guziqiu {

class Task { // 任务队列
public :
    template<typename FUNCTION, typename ...ARGS>
    Task(FUNCTION &&func, ARGS ...args);
    void run();

private :
    std::function<void()> func;
};


class ThreadPool {
public :
    ThreadPool(int n = 5);
    template<typename FUNCTION, typename ...ARGS>
    void addOneTask(FUNCTION &&, ARGS...);
    void stop(); // 等待线程池执行结束
private :
    std::vector<std::thread *> threads;
    std::queue<Task *> tasks;
    std::unordered_map<std::thread::id, bool> running;
    std::mutex m_mutex; // 互斥锁
    std::condition_variable m_condition; // 条件信号量

    void workerThread(); // 入口函数
    Task *getOneTask();
    void stopThread(); // 毒药任务
};


template<typename FUNCTION, typename ...ARGS>
Task::Task(FUNCTION &&func, ARGS ...args) {
    this->func = std::bind(func, std::forward<ARGS>(args)...);
}
void Task::run() {
    std::cout << "Task run : " << std::endl;
    func();
    return ;
}

ThreadPool::ThreadPool(int n) {
    for (int i = 0; i < n; i++) {
        threads.push_back(new std::thread(&ThreadPool::workerThread, this));
    }
}
template<typename FUNCTION, typename ...ARGS>
void ThreadPool::addOneTask(FUNCTION &&func, ARGS... args) {
    std::unique_lock<std::mutex> lock(m_mutex); // 抢占互斥锁
    tasks.push(new Task(func, std::forward<ARGS>(args)...)); // 添加任务
    m_condition.notify_one(); // 通知其他线程已经有任务了
}
void ThreadPool::workerThread() { // 入口函数
    std::thread::id id = std::this_thread::get_id();
    // std::cout << id << std::endl;
    running[id] = true;
    while (running[id]) {
       Task *t = this->getOneTask(); // 取任务
        t->run();// 执行任务
       delete t; // 销毁任务
    }
    return ;
}
Task *ThreadPool::getOneTask() {
    // 取任务
    std::unique_lock<std::mutex> lock(m_mutex);// 抢占互斥锁
    while (tasks.empty()) { // 当任务队列为空
        m_condition.wait(lock); // 等待任务
    }
    Task *t = tasks.front();
    tasks.pop();

    return t;
}

void ThreadPool::stop() {
    for (int i = 0; i  < threads.size(); i++) {
        this->addOneTask(&ThreadPool::stopThread, this); // 添加毒药任务
    }

    for (auto t : threads) {
        t->join(); // 等待线程结束
    }
    return ;
}

void ThreadPool::stopThread() {
    std::thread::id id = std::this_thread::get_id();
    running[id] = false;
    return ;
}

} // ed of guziqiu


void  func(int a, int b, int c) {

    std::cout << "func id : " << a << ", "<< a + b + c << std::endl;
    return ;
}

int main() {

    guziqiu::Task t1(func, 1, 2, 3);
    guziqiu::ThreadPool tp;
    //std::cout << "hello, world" << std::endl;
    //t1.run();

    // 在线程池中添加100个任务
    for (int i = 0; i < 100; i++) {
        tp.addOneTask(func, i, 2 * i, 3 * i);
    }
    tp.stop(); // 等待线程池中的任务执行结束


    return 0;
}
```





0321，2：21



























# C++与游戏开发COCOS

底层是由C/C++写出来的，开发的是图形库

引擎架构是树形结构

树形结构由一个导演进行维护

树形结构是中序遍历的，遍历场景

场景里面有动作：

通过引用计数实现内存自动回收



![截屏2021-03-30 下午5.27.04](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-03-30%20%E4%B8%8B%E5%8D%885.27.04.png)



# C++2048



















































































































































































































































































































































# 0.end

















































































































































































































































































































































# ERROE

## 1.undefined reference to `std::cout'

使用 g++编译期

增加using std::out;



## 2.Undefined symbols for architecture x86_64



有方法为定义



































































































































