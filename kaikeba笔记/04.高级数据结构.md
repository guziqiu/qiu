[TOC]





\---

title: 高级数据结构

date: 2020-12-22 08:08:15

tags: 高级数据结构

categories: 高级数据结构

\---





# 0、2020.12.22

------











# 1.BS二叉排序树O(logN)

二叉排序树、二叉搜索树、二叉查找树 、Binary Search Tree

数据结构定义一种性质,并且维护这种性质

## 1.性质

> 1.左子树 < 根节点
>
> 2.根节点 < 右子树
>
> 3.中序遍历的结果，是一个有序序列



> 用途：解决与排名相关的检索需求



> 树型结构：边代表关系，点代表集合







## 2.BS插入操作

> 1.插入新节点，一定会作为叶子节点
>
> 

![截屏2020-12-19 下午6.39.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%886.39.38.png)

```c
Node *insert(Node *root, int val) {
    if (root == NULL) return getNewNode(val);
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    //update_size(root);
    return root;
}
```



## 3.BS删除操作

> 1.删除叶子节点:直接删除，
>
> 2.删除度为1的节点：把孤儿树挂到父节点上面
>
> （更新孩子节点的和父亲节点）
>
> 3.删除度为2的结点：找到前驱或者后继替换后转换为度为 0或1的结点问题



对于度为2 的节点：

> 1.前驱：左子树中的最大值
>
> 2.后继：右子树中的最小值

前驱没有右子树，后驱没有左子树，前驱和者后继度为0或1



节点查找次数的期望值：

> 平均查找效率：总查找次数(1 + 2 * 节点数 + 3 * 节点数... )/总节点数(n) 
>
> $\frac{总查找次数}{节点数}$
>
> 假设每个结点等概率被查找



<!--more-->



![截屏2020-12-19 下午11.15.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.15.08.png)

![截屏2020-12-19 下午11.19.16](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%8811.19.16.png)



![截屏2020-12-21 下午4.46.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%884.46.47.png)



```c
Node *erase(Node *root, int value) {
    if (root == NULL) return NULL;
    if (value < root->data) {
        root->lchild = erase(root->lchild, value);
    } else if (value > root->data) {
        root->lchild = erase(root->rchild, value);
    } else {//找到结点
       /* if (root->lchild == NULL && root->rchild == NULL) {
            free(root);
            return NULL;
        } else */
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上
        } else {//将两个结点的情况转换为一个结点
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = erase(root->lchild, temp->data);
        }
    }
    return root;
}
```

 

## 4.BS代码演示



```c++
#include <stdio.h>
#include <stdlib.h>

#define KEY(n) (n ? n->data : 0)

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int _data) {//初始化
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = _data;
    p->lchild = p->rchild = NULL;
    return p;
}

int search(Node *root, int value) {
    if (root == NULL) return 0;
    if (root->data == value) return 1;
    if (value < root->data) return search(root->lchild, value);
    return search(root->rchild, value);
}
 
Node *insert(Node *root, int val) {
    if (root == NULL) return getNewNode(val);
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    return root;
}

Node *predecessor(Node *root) {//前驱
    Node *temp = root->lchild;
    while(temp && temp->rchild) temp = temp->rchild;
    return temp;
}
 

Node *erase(Node *root, int value) {
    if (root == NULL) return NULL;
    if (value < root->data) {
        root->lchild = erase(root->lchild, value);
    } else if (value > root->data) {
        root->lchild = erase(root->rchild, value);
    } else {//找到结点
       /* if (root->lchild == NULL && root->rchild == NULL) {
            free(root);
            return NULL;
        } else */
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上
        } else {//将两个结点的情况转换为一个结点
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = erase(root->lchild, temp->data);
        }
    }
    return root;
}



void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    printf("%d  ", root->data);
    output(root->rchild);
    return ;
}

void output1(Node *root) {
    if (root == NULL) return ;
    output1(root->lchild);
    printf("(%d,%d,%d)\n", KEY(root), KEY(root->lchild), KEY(root->rchild));
    output1(root->rchild);
    return ;
}

int main() {

    int op, val;
    Node *root = NULL;//!!!!!!!!!!!!!!!
    while (~scanf("%d%d", &op, &val)) {
        //0：查找 1：插入 2： 删除
        switch (op) {
        case 0:printf("search %d, result : %d \n", val, search(root, val)); break;
        case 1:{
                   printf("insert: %d \n", val);
                   root = insert(root, val);
                   printf("\n");
               }break;
        case 2:{
                   printf("erase: %d \n", val);
                   root = erase(root, val);
                   printf("\n");
               } break;
        }

        if (op) {
            printf("\ntree ==> [");
            output(root);
            printf("]\n");
        }
        if (op) output1(root);
        printf("\n------------------\n");
    }
    clear(root);


    return 0;
}
```





## 5.BS解决排名相关的需求

输出第k大的元素

1. 修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量
2. $k - 1= LS$，根节点就是排名第 k 位的元素
3. $k \le LS$，排名第 k 位的元素在左子树中
4. $k \gt LS，search_k(root->rchild, k - LS - 1)$



```c
#include <stdio.h>
#include <stdlib.h>

#define KEY(n) (n ? n->data : 0)
#define SIZE(n) (n ? n->size : 0)

typedef struct Node {
    int data, size;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int _data) {//初始化
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = _data;
    p->size = 1;
    p->lchild = p->rchild = NULL;
    return p;
}

int search(Node *root, int value) {
    if (root == NULL) return 0;
    if (root->data == value) return 1;
    if (value < root->data) return search(root->lchild, value);
    return search(root->rchild, value);
}

int search_k(Node *root, int k) {
    if (root == NULL) return -1;
    if (SIZE(root->lchild) == k - 1) return root->data;
    if (k <= SIZE(root->lchild)) {
        return search_k(root->lchild, k);
    }
    return search_k(root->rchild, k - SIZE(root->lchild) - 1);
}

void update_size(Node *root) {
    root->size = SIZE(root->lchild)  + SIZE(root->rchild) + 1;
    return ;
}

Node *insert(Node *root, int val) {
    if (root == NULL) return getNewNode(val);
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    update_size(root);
    return root;
}

Node *predecessor(Node *root) {//前驱
    Node *temp = root->lchild;
    while(temp && temp->rchild) temp = temp->rchild;
    return temp;
}
 

Node *erase(Node *root, int value) {
    if (root == NULL) return NULL;
    if (value < root->data) {
        root->lchild = erase(root->lchild, value);
    } else if (value > root->data) {
        root->lchild = erase(root->rchild, value);
    } else {//找到结点
       /* if (root->lchild == NULL && root->rchild == NULL) {
            free(root);
            return NULL;
        } else */
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上
        } else {//将两个结点的情况转换为一个结点
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = erase(root->lchild, temp->data);
        }
    }
    update_size(root);
    return root;
}



void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    printf("%d[%d] ", root->data, SIZE(root));
    output(root->rchild);
    return ;
}

void output1(Node *root) {
    if (root == NULL) return ;
    output1(root->lchild);
    printf("(%d[%d],%d,%d)\n", KEY(root), SIZE(root), KEY(root->lchild), KEY(root->rchild));
    output1(root->rchild);
    return ;
}

int main() {

    int op, val;
    Node *root = NULL;
    while (~scanf("%d%d", &op, &val)) {
        //0：查找 1：插入 2： 删除
        switch (op) {
        case 0:printf("search %d, result : %d \n", val, search(root, val)); break;
        case 1:{
                   printf("insert: %d \n", val);
                   root = insert(root, val);
                   printf("\n");
               }break;
        case 2:{
                   printf("erase: %d \n", val);
                   root = erase(root, val);
                   printf("\n");
               } break;
        case 3: {
                printf("search k = %d, result : %d\n",
                    val, search_k(root, val));
            } break;
        }

        if (op) {
            printf("\ntree ==> [");
            output(root);
            printf("]\n");
        }
        if (op) output1(root);
        printf("\n------------------\n");
    }
    clear(root);


    return 0;
}

1 1
insert: 1


tree ==> [1[1] ]
(1[1],0,0)

------------------
1 2
insert: 2


tree ==> [1[2] 2[1] ]
(1[2],0,2)
(2[1],0,0)

------------------
 1 3
insert: 3


tree ==> [1[3] 2[2] 3[1] ]
(1[3],0,2)
(2[2],0,3)
(3[1],0,0)

------------------
1 4
insert: 4


tree ==> [1[4] 2[3] 3[2] 4[1] ]
(1[4],0,2)
(2[3],0,3)
(3[2],0,4)
(4[1],0,0)

------------------
1 5
insert: 5


tree ==> [1[5] 2[4] 3[3] 4[2] 5[1] ]
(1[5],0,2)
(2[4],0,3)
(3[3],0,4)
(4[2],0,5)
(5[1],0,0)

------------------
3 1
search k = 1, result : 1

tree ==> [1[5] 2[4] 3[3] 4[2] 5[1] ]
(1[5],0,2)
(2[4],0,3)
(3[3],0,4)
(4[2],0,5)
(5[1],0,0)

------------------
3 2
search k = 2, result : 2

tree ==> [1[5] 2[4] 3[3] 4[2] 5[1] ]
(1[5],0,2)
(2[4],0,3)
(3[3],0,4)
(4[2],0,5)
(5[1],0,0)

------------------
3 4
search k = 4, result : 4

tree ==> [1[5] 2[4] 3[3] 4[2] 5[1] ]
(1[5],0,2)
(2[4],0,3)
(3[3],0,4)
(4[2],0,5)
(5[1],0,0)

------------------
```





## 6.BS解决Top-K 问题

（找到小于第 k 位的所有元素）

1. 根节点就是第 k 位元素的话，就把左子树中的值全部输出出来
2. 第 k 位在左子树中，前 k 位元素全都在左子树中
3. 第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值



所谓算法设计及分析能力：分类讨论及归纳总结的能力



```c
#include <stdio.h>
#include <stdlib.h>

#define KEY(n) (n ? n->data : 0)
#define SIZE(n) (n ? n->size : 0)
#define L(n) (n ? n->lchild : NULL)

typedef struct Node {
    int data, size;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int _data) {//初始化
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = _data;
    p->size = 1;
    p->lchild = p->rchild = NULL;
    return p;
}

int search(Node *root, int value) {
    if (root == NULL) return 0;
    if (root->data == value) return 1;
    if (value < root->data) return search(root->lchild, value);
    return search(root->rchild, value);
}

int search_k(Node *root, int k) {
    if (root == NULL) return -1;
    if (SIZE(root->lchild) == k - 1) return root->data;
    if (k <= SIZE(root->lchild)) {
        return search_k(root->lchild, k);
    }
    return search_k(root->rchild, k - SIZE(root->lchild) - 1);
}

void update_size(Node *root) {
    root->size = SIZE(root->lchild)  + SIZE(root->rchild) + 1;
    return ;
}

Node *insert(Node *root, int val) {
    if (root == NULL) return getNewNode(val);
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    update_size(root);
    return root;
}

Node *predecessor(Node *root) {//前驱
    Node *temp = root->lchild;
    while(temp->rchild) temp = temp->rchild;
    return temp;
}
 
Node *erase(Node *root, int value) {
    if (root == NULL) return NULL;
    if (value < root->data) {
        root->lchild =  erase(root->lchild, value);
    } else if (value > root->data) {
        root->rchild =  erase(root->rchild, value);
    } else {//找到结点
       /* if (root->lchild == NULL && root->rchild == NULL) {
            free(root);
            return NULL;
        } else */
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;//返回删除节点的孩子节点，将孩子结点挂载到被删除节点的父亲节点上
        } else {//将两个结点的情况转换为一个结点
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = erase(root->lchild, temp->data);
        }
    }
    update_size(root);
    return root;
}



void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    printf("%d[%d] ", root->data, SIZE(root));
    output(root->rchild);
    return ;
}
void print(Node *root) {
    printf("(%d[%d], %d, %d)\n",
           KEY(root), SIZE(root),
           KEY(root->lchild), KEY(root->rchild)
    );
    return ;
}
void output1(Node *root) {
    if (root == NULL) return ;
    output1(root->lchild);
    print(root);
    output1(root->rchild);
    return ;
}

void output_k(Node *root, int k) {
    if (k == 0 || root == NULL) return ;
    if (k <= SIZE(root->lchild)) output_k(root->lchild, k);
    else {
        output1(root->lchild);
        print(root);
        output_k(root->rchild, k - SIZE(root->lchild) - 1);
    }
    return ;
}

int main() {

    int op, val;
    Node *root = NULL;
    while (~scanf("%d%d", &op, &val)) {
        //0：查找 1：插入 2： 删除
        switch (op) {
        case 0:printf("search %d, result : %d \n", val, search(root, val)); break;
        case 1:{
                   printf("insert: %d \n", val);
                   root = insert(root, val);
                   printf("\n");
               }break;
        case 2:{
                   printf("erase: %d \n", val);
                   root = erase(root, val);
                   printf("\n");
               } break;
        case 3: {
                printf("search k = %d, result : %d\n",
                    val, search_k(root, val));
            } break;
        case 4: {
                printf("output top-%d elements\n", val);
                output_k(root, val);
                printf("------------\n");
            } break;
        }

        if (op) {
            printf("\ntree ==> [");
            output(root);
            printf("]\n");
        }
        if (op) output1(root);
        printf("\n------------------\n");
    }
    clear(root);


    return 0;
}
```





## 7.二叉排序树和快排的关系



1. 二叉排序树是快速排序在思维逻辑结构层面用的数据结构

2. 思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系

   

3. 思考2：快速选择算法和二叉排序树之间的关系

   

4. 程序=算法+数据结构











# 2.AVL平衡二叉查找树O(logN)

1962年（58）

==**AVL树**==

## 0.AVL树原理

> AVL树原理
>
> 自平衡条件、旋转操作、旋转的触发



数据机构：定义一种性质并且维护一种性质



### 性质 

1.左右子树高度差 小于等于 1

2.平衡二叉排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质

3.平衡二叉排序树的学习重点：平衡条件以及平衡调整







> 高度为H的BS树所包含的结点数量在什么范围内： $H \le SIZE \le 2^H-1$
>
> 高度为H的AVL树所包含的结点数量在什么范围内:  $1.5^H \le SIZE \le 2^H-1$
>
> $low(H) \le SIZE \le 2^H-1$
>
> $low(H-1) + low(H - 2) + 1\le SIZE \le 2^H-1$（斐波那契数列）
>
> $1.5^H \le SIZE \le 2^H-1$

二叉树性质：二叉树第i层最多有2^i-1^个结点，深度为k最多有2^k^-1个结点

==>AVL节点数n和树高h的关系:h = logn



思考：

1. AVL 树改进的是节点数量的下限
2. 树高 = 生命长度，节点数量 = 生命财富，不同的算法，达到的结果是不同的
3. 教育提升的是底限，而不是上限，上限取决于能力和运气







## 1.自平衡条件

### 1.平衡因子

每个平衡因子的是指左子树最大高度和右子树最大高度差，平衡因子为-1，0，1被认为是平衡的

### 2.失衡类型

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.08.06.png" alt="截屏2020-12-23 下午6.08.06" style="zoom:67%;" />

## 2.旋转操作：单旋和多旋

### 1.单旋

分为左旋和右旋。AVL树通过一系列的左旋和右旋操作，将不平衡的树调整为二叉查找树

#### 左旋：

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.51.png" alt="截屏2020-12-23 下午6.03.51" style="zoom:50%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.31.png" alt="截屏2020-12-21 下午6.32.31" style="zoom: 67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.32.25.png" alt="截屏2020-12-21 下午6.32.25" style="zoom:67%;" />



#### 右旋

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.03.57.png" alt="截屏2020-12-23 下午6.03.57" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.45.png" alt="截屏2020-12-21 下午6.37.45" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.37.41.png" alt="截屏2020-12-21 下午6.37.41" style="zoom:67%;" />



### 2.多旋：

由两次单旋操作组合而成

#### 1.左旋加右旋LR

#### <img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8812.38.14.png" alt="截屏2020-12-24 下午12.38.14" style="zoom:75%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.27.png" alt="截屏2020-12-23 下午6.10.27" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/26252FD93F9BE46395BB71A8E8888D4A.jpg" alt="26252FD93F9BE46395BB71A8E8888D4A" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.05.png" alt="截屏2020-12-21 下午6.45.05" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.01.png" alt="截屏2020-12-21 下午6.45.01" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.45.10.png" alt="截屏2020-12-21 下午6.45.10" style="zoom:67%;" />



#### 2.右旋加左旋RL



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.47.png" alt="截屏2020-12-21 下午6.47.47" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.42.png" alt="截屏2020-12-21 下午6.47.42" style="zoom:67%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.47.52.png" alt="截屏2020-12-21 下午6.47.52" style="zoom:67%;" />



#### 3. LL

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.10.21.png" alt="截屏2020-12-23 下午6.10.21" style="zoom:67%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/209777F2C379C9542061B8B56572755E.jpg" alt="209777F2C379C9542061B8B56572755E" style="zoom:67%;" />









#### 4.RR与LL对称



## 3.旋转的触发



插入操作：

![截屏2020-12-21 下午6.58.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.33.png)



删除操作：

![截屏2020-12-21 下午6.58.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-21%20%E4%B8%8B%E5%8D%886.58.42.png)

> 平衡调整策略/方法
>
> 1. 发生在回溯阶段的，第一个失衡节点处
> 2. 理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD 四棵子树树高的关系
> 3. LL，大右旋
> 4. LR，先小左旋，再大右旋
> 5. RL，先小右旋，再大左旋
> 6. RR，大左旋

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%886.22.17.png" alt="截屏2020-12-23 下午6.22.17" style="zoom:67%;" />







## 4.代码实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct Node {
    int data, height;
    struct Node *lchild, *rchild;
} Node;

Node __NIL;//假的空节点
__attribute__((constructor))
#define NIL (&__NIL)
void init_NIL() {
    NIL->data = 0;
    NIL->height = 0;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int _data) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->data = _data;
    node->lchild = node->rchild = NIL;
    node->height = 1;
    return node;
}

void update_height(Node *root) {
    root->height = (root->lchild->height > root->rchild->height ? root->lchild->height : root->rchild->height) + 1;
    return ;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *right_rotate(Node *root) {//对称
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *maintain(Node *root) {
    if (abs(root->lchild->height - root->rchild->height) <= 1) return root;
    if (root->lchild->height > root->rchild->height) {//L大左旋
        if (root->lchild->lchild->height < root->lchild->rchild->height)//LR小右旋
            root->lchild = left_rotate(root->lchild);
        root = right_rotate(root);
    } else {
        if (root->rchild->rchild->height < root->lchild->rchild->height)//RL小左旋
            root->rchild = right_rotate(root->lchild);//小右旋
        root = left_rotate(root);//大左旋
    }
    return root;
}

Node *insert(Node *root, int val) {
    if (root == NIL) return getNewNode(val);
    if (root->data == val) return root;//不需要插入操作
    if (val < root->data) {
        root->lchild = insert(root->lchild, val);
    } else {
        root->rchild = insert(root->rchild, val);
    }
    update_height(root);

    return maintain(root);
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp && temp->lchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int val) {
    if (root == NIL) return NIL;
    if (val < root->data) {
        root->lchild = erase(root->lchild, val);
    } else if (val > root->data) {
        root->rchild = erase(root->rchild, val);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild != NIL ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = erase(root->lchild, temp->data);
        }
    }
    update_height(root);
    return maintain(root);
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("(%d[%d],%d,%d)\n",
           root->data, root->height,
           root->lchild->data,
           root->rchild->data);
    output(root->lchild);
    output(root->rchild);
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
        case 0: root = erase(root, val);
        case 1:
        case 2:
        case 3: root = insert(root, val);
        }
        output(root);
        printf("--------------\n");
    }
    clear(root);

    return 0;
}
```



















# 3*.SBTree

Size Balanced Tree

## 1.平衡原理



![截屏2020-12-22 上午10.20.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.20.58.png)



![截屏2020-12-22 上午10.21.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.21.30.png)



![截屏2020-12-22 上午10.25.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.25.01.png)





## 2.旋转操作



![截屏2020-12-22 上午10.26.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.35.png)





![截屏2020-12-22 上午10.26.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.26.45.png)



## 3.旋转的触发



![截屏2020-12-22 上午10.28.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-22%20%E4%B8%8A%E5%8D%8810.28.20.png)





## 4.代码实现





```cpp
#include <iostream>

template<typename Type>
class SBTNode {
public:
    Type data;
    int size;
    SBTNode<Type> *lchild, *rchild, *father;
    SBTNode(Type init_data, int init_size = 0, SBTNode<Type> *init_father = NULL);
    ~SBTNode();

    void insert(Type value);
    SBTNode<Type>* search(Type value);
    SBTNode<Type>* predecessor();
    SBTNode<Type>* successor();
    void remove_node(SBTNode<Type> *delete_node);
    bool remove(Type value);
};

template<typename Type>
class BinaryTree {
private:
    SBTNode<Type>* root;
public:
    BinaryTree();
    ~BinaryTree();
    void insert(Type value);
    bool find(Type value);
    bool remove(Type value);
};

SBTNode<int> ZERO(0);
SBTNode<int>* NIL = &ZERO;

template <typename Type>
SBTNode<Type>::SBTNode(Type init_data, int init_size, SBTNode<Type>* init_father) {
    data = init_data;
    size = init_size;
    lchild = NIL;
    rchild = NIL;
    father = init_father;
}

template <typename Type>
SBTNode<Type>::~SBTNode() {
    if (lchild != NIL) {
        delete lchild;
    }
    if (rchild != NIL) {
        delete rchild;
    }
}

template <typename Type>
SBTNode<Type>* left_rotate(SBTNode<Type>* node) {
	SBTNode<Type> *temp =  node->rchild;
    node->rchild = temp->lchild;
    temp->lchild->father = node;
    temp->lchild = node;
    temp->father = node->father;
    node->father = temp;
    temp->size = node->size;
    node->size = node->lchild->size + node->rchild->size + 1;
    return temp;
}

template <typename Type>
SBTNode<Type>* right_rotate(SBTNode<Type>* node) {
  	SBTNode<Type> *temp = node->lchild;
    node->lchild = temp->rchild;
    temp->rchild->father = node;
    temp->rchild = node;
    temp->father = node->father;
    node->father = temp;
    temp->size = node->size;
    node->size = node->lchild->size + node->rchild->size + 1;
    return temp;
}

template <typename Type>
SBTNode<Type>* maintain(SBTNode<Type>* node, bool flag) {
}

template <typename Type>
SBTNode<Type>* insert(SBTNode<Type>* node, Type value) {
    node->size++;
    if (value > node->data) {
        if (node->rchild == NIL) {
            node->rchild = new SBTNode<Type>(value, 1, node);
        } else {
            node->rchild = insert(node->rchild, value);
        }
    } else {
        if (node->lchild == NIL) {
            node->lchild = new SBTNode<Type>(value, 1, node);
        } else {
            node->lchild = insert(node->lchild, value);
        }
    }
    return maintain(node, value > node->data);
}

template <typename Type>
SBTNode<Type>* SBTNode<Type>::search(Type value) {
    if (data == value) {
        return this;
    } else if (value > data) {
        if (rchild == NIL) {
            return NIL;
        } else {
            return rchild->search(value);
        }
    } else {
        if (lchild == NIL) {
            return NIL;
        } else {
            return lchild->search(value);
        }
    }
}

template <typename Type>
SBTNode<Type>* SBTNode<Type>::predecessor() {
    SBTNode<Type>* temp = lchild;
    while (temp != NIL && temp->rchild != NIL) {
        temp = temp->rchild;
    }
    return temp;
}

template <typename Type>
SBTNode<Type>* SBTNode<Type>::successor() {
    SBTNode<Type>* temp = rchild;
    while (temp != NIL && temp->lchild != NIL) {
        temp = temp->lchild;
    }
    return temp;
}

template <typename Type>
void SBTNode<Type>::remove_node(SBTNode<Type>* delete_node) {
    SBTNode<Type>* temp = NIL;
    if (delete_node->lchild != NIL) {
        temp = delete_node->lchild;
        temp->father = delete_node->father;
        delete_node->lchild = NIL;
    }

    if (delete_node->rchild != NIL) {
        temp = delete_node->rchild;
        temp->father = delete_node->father;
        delete_node->rchild = NIL;
    }
    if (delete_node->father->lchild == delete_node) {
        delete_node->father->lchild = temp;
    } else {
        delete_node->father->rchild = temp;
    }
    temp = delete_node;
    while (temp != NULL) {
        temp->size--;
        temp = temp->father;
    }
    delete delete_node;
}

template <typename Type>
bool SBTNode<Type>::remove(Type value) {
    SBTNode<Type> *delete_node, *current_node;
    current_node = search(value);
    if (current_node == NIL) {
        return false;
    }
    if (current_node->lchild != NIL) {
        delete_node = current_node->predecessor();
    } else if (current_node->rchild != NIL) {
        delete_node = current_node->successor();
    } else {
        delete_node = current_node;
    }
    current_node->data = delete_node->data;
    remove_node(delete_node);
    return true;
}

template <typename Type>
BinaryTree<Type>::BinaryTree() {
    root = NULL;
}

template <typename Type>
BinaryTree<Type>::~BinaryTree() {
    delete root;
}

template <typename Type>
void BinaryTree<Type>::insert(Type value) {
    if (root == NULL) {
        root = new SBTNode<Type>(value, 1);
    } else if (root->search(value) == NIL) {
        root = ::insert(root, value);
    }
}

template <typename Type>
bool BinaryTree<Type>::find(Type value) {
    if (root->search(value) == NIL) {
        return false;
    } else {
       return true;
    }
}

template <typename Type>
bool BinaryTree<Type>::remove(Type value) {
    return root->remove(value);
}

int main() {
    return 0;
}
```













# 4.红黑树O(logN)

## 1.平衡条件

1. 节点非黑既红
2. 根节点是黑色
3. 叶子（NIL）结点是黑色
4. 如果一个节点是红色，则它的两个子节点都是黑色
5. 从根节点到叶子结点路径上，黑色节点数量相同

==>最长边和最短边之间的关系：最长边是最短边的二倍

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-23%20%E4%B8%8B%E5%8D%889.44.56.png" alt="截屏2020-12-23 下午9.44.56" style="zoom: 33%;" />





> 第4条和第5条条件，注定了，红黑树中最长路径是最短路径的长度的 2 倍。
>
> 本质上，红黑树也是通过树高来控制平衡的。
>
> 红黑树比 AVL 树树高控制条件要更松散，红黑树在发生节点插入和删除以后，发生调整的概率，比 AVL 树要更小。





## 2.平衡调整策略

1.插入调整站在祖父节点看

2.删除调整站在父亲节点看

3.插入和删除的情况处理，一共五种



> 理解
>
> 1. 理解红黑树的插入调整，要站在==祖父节点==向下进行调整
> 2. 理解红黑树的删除调整，要站在==父节点==向下进行调整
> 3. 插入调整，主要就是为了解决双红情况
> 4. 新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突
> 5. 把每一种情况，想象成一棵大的红黑树中的局部子树
> 6. 局部调整的时候，为了不影响全局，调整前后的路径上黑色节点数量相同



## 3.插入方法

​				 						 						 						 						 		

1.叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑(4种情况)

x有4个位置，4种情况，但是处理方法一样

根节点必定为黑色，否则插入前已经冲突

eg:1,20修改成黑色，15修改成红色(红色上顶)

![截屏2020-12-24 上午11.16.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.16.48.png)

2.叔叔节点为黑色的时候，有四种情况LL,LR，RL,RR

参考 AVL 树的失衡情况，分成 $LL,LR,RL,RR$, 先参考 AVL 树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略：红色上浮，红色下沉。

eg:LL型进行大右旋，**20**调整成红色，**15**调整成⿊色，即可搞定问题(红色上浮)，

或者调整10为黑色，红色上浮

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.17.02.png" alt="截屏2020-12-24 上午11.17.02" style="zoom: 70%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8A%E5%8D%8811.29.58.png" alt="截屏2020-12-24 上午11.29.58" style="zoom:67%;" />

3.两大类情况，包含 8 种小情况



## 4.插入代码演示

1. 插入调整，发正在递归的回溯阶段
2. 插入调整代码中，使用 goto 语句，8行代码，变成了4行
3. 处理根节点一定是黑色，通过代码封装，$insert->\_\_insert$



```cpp
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    int color;//0 red, 1 black 2double black
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {
    NIL->data = 0;
    NIL->color = 1;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int _data) {
    Node *root = (Node *)malloc(sizeof(Node));
    root->data = _data;
    root->color = 0;
    root->lchild = root->rchild = NIL;
    return root;
}

int has_red_child(Node *root) {//判断根节点是否有红色的子孩子
    return root->lchild->color == 0 || root->rchild->color == 0;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}

Node *insert_maintain(Node *root) {
    if (!has_red_child(root)) return root;//没有红色的孩子，不需要调整
    //没有判断是否发生双红冲突
    //不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色
    int flag = 0;
    if (root->lchild->color == 0 && root->rchild->color == 0) goto insert_end;
    //{
       // root->color = 0;
       // root->lchild->color = root->rchild->color = 1;
        //return root;
    //}
    if (root->lchild->color == 0 && has_red_child(root->lchild)) flag = 1;
    if (root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if (flag == 0) return root;
    if (flag == 1) {
        if (root->lchild->rchild->color == 0)//LR,需要小左旋，大右旋
            root->lchild = left_rotate(root->lchild);
        root = right_rotate(root);
        //root->color = 0;//红色上浮，红色下沉也可
       // root->lchild->color = root->rchild->color = 1;
       // return root;
    } else {//
        if (root->rchild->lchild->color == 0) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
        //root->color = 0;
       // root->lchild->color = root->rchild->color = 1;
    }
insert_end:
    root->color = 0;//红色上浮，红色下沉也可
    root->lchild->color = root->rchild->color = 1;
    return root;
}

Node *__insert(Node *root, int value) {
    if (root == NIL) return getNewNode(value);
    if (root->data == value) return root;
    if (value < root->data) root->lchild = __insert(root->lchild, value);
    else root->rchild = __insert(root->rchild, value);
    return insert_maintain(root);
}

Node *insert(Node *root, int data) {
    root = __insert(root, data);
    root->color = 1;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void print(Node *root) {
    printf("(%d| %d, %d, %d)\n",
        root->color, root->data,
        root->lchild->data,
        root->rchild->data
    );
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    print(root);
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
        }
        output(root);
        printf("------------\n");
    }


    return 0;
}
```



```cpp
1 1
(1| 1, 0, 0)
------------
1 2
(1| 1, 0, 2)
(0| 2, 0, 0)
------------
1 3
(1| 2, 1, 3)
(1| 1, 0, 0)
(1| 3, 0, 0)
------------
1 4
(1| 2, 1, 3)
(1| 1, 0, 0)
(1| 3, 0, 4)
(0| 4, 0, 0)
------------
```



```
1 -60
2 -95
1 47
1 -65
1 18
3 -53
```



 

## 5.删除调整的触发

1. 删除红色节点，不会对红黑树的平衡产生影响
2. 度为1的黑色节点，唯一子孩子一定是红色，因为到叶子结点的黑色节点相同，如果为黑色则会违背平衡条件
3. 所以删除度为1的黑色节点，不会产生删除调整，
4. 删除度为0的黑色节点，会产生一个双重黑的 NIL 节点(color=2)
5. 所以删除调整的关键，就是为了干掉双重黑

==>双重黑结点触发删除调整



## 7.删除调整分类

> 1.双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，

调整方法:父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色。

情况一

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.25.58.png" alt="图一" style="zoom: 85%;" />

> 2.双黑结点的兄弟节点是黑色，并且，兄弟节点中有==红色子节点==,有四种情况

 1).R（兄弟）==R==（右子节点），==左==旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色,双重黑改成一重黑

情况三（双黑左旋之后被干掉）兄弟的右子树结点为红色，左子树结点不一定

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%884.29.06.png" alt="截屏2020-12-24 下午4.29.06" style="zoom:90%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%885.04.12.png" alt="截屏2020-12-24 下午5.04.12" style="zoom:50%;" />





2).R（兄弟）==L==（左子节点）(红色)，先小==右==旋，对调新根与原根的颜色，转成上一种情况(RL→RR)

(情况二)RL，兄弟右子树一定为黑色，左子树为红色

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8811.02.27.png" alt="截屏2020-12-24 下午11.02.27" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.06.55.png" alt="截屏2020-12-24 下午10.06.55" style="zoom:50%;" />

3).LL 同理 RR

4).LR 同理 RL

> 4.兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况

  左旋，原根节点改红，新根节点改黑，双黑-1

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.22.04.png" alt="截屏2020-12-24 下午10.22.04" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-24%20%E4%B8%8B%E5%8D%8810.25.28.png" alt="截屏2020-12-24 下午10.25.28" style="zoom:50%;" />







## 6.删除代码实现

进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。



```cpp
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    int color;//0 red, 1 black 2double black
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {
    NIL->data = 0;
    NIL->color = 1;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int _data) {
    Node *root = (Node *)malloc(sizeof(Node));
    root->data = _data;
    root->color = 0;
    root->lchild = root->rchild = NIL;
    return root;
}

int has_red_child(Node *root) {//判断根节点是否有红色的孩子结点
    return root->lchild->color == 0 || root->rchild->color == 0;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}

Node *insert_maintain(Node *root) {
    if (!has_red_child(root)) return root;//没有红色的孩子，不需要调整
    int flag = 0;
    if (root->lchild->color == 0 && root->rchild->color == 0) goto insert_end;
    if (root->lchild->color == 0 && has_red_child(root->lchild)) flag = 1;
    if (root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if (flag == 0) return root;
    if (flag == 1) {
        if (root->lchild->rchild->color == 0)//LR,需要小左旋，大右旋
            root->lchild = left_rotate(root->lchild);
        root = right_rotate(root);
    } else {//
        if (root->rchild->lchild->color == 0) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
insert_end:
    root->color = 0;//红色上浮，红色下沉也可，这里选择红色上浮
    root->lchild->color = root->rchild->color = 1;
    return root;
}

Node *__insert(Node *root, int value) {
    if (root == NIL) return getNewNode(value);
    if (root->data == value) return root;
    if (value < root->data) root->lchild = __insert(root->lchild, value);
    else root->rchild = __insert(root->rchild, value);
    return insert_maintain(root);
}

Node *insert(Node *root, int data) {
    root = __insert(root, data);
    root->color = 1;
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
    if (root->lchild->color != 2 && root->rchild->color != 2) return root;
    if (has_red_child(root)) {//兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况
        int flag = 0;//1：右旋，2：左旋
        root->color = 0;//原根节点改红
        if (root->lchild->color == 0) {//左孩子为红色，右孩子为双黑结点，减掉一重黑色，右旋
            root->rchild->color -= 1;
            root = right_rotate(root);
            flag = 1;
        }
        else {//右孩子为红色,左孩子为双黑结点，双黑结点减掉一重黑色，左旋
            root->lchild->color -= 1;
            root = left_rotate(root);
            flag = 2;
        }
        root->color = 1;//新根节点改黑
        if (flag == 1) root->rchild = erase_maintain(root->rchild);//若发生右旋，已经转变成兄弟结点为黑色的情况，递归检查右边是否平衡,
        else root->lchild = erase_maintain(root->lchild);//检查左边是否平衡
        return root;
    }
    if ((root->lchild->color == 2 && !has_red_child(root->rchild)) ||
        (root->rchild->color == 2 && !has_red_child(root->lchild)) ) {
        //双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色(即无红色)
            root->lchild->color -= 1;//父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色
            root->rchild->color -= 1;
            root->color += 1;
            return root;
    }
    //双黑结点的兄弟节点是黑色，并且，兄弟节点中有红色子节点
    //R（兄弟）R（右子节点），左旋，新根结点改成原根结点的颜色，将新根的两个子节点，改成黑色，双重黑减1
    //R（兄弟）L（左子节点）(红色)，先小右旋，对调新根与原根的颜色，转成RR(RL→RR)
    if (root->lchild->color == 2) {//左兄弟为双黑结点
        if (root->rchild->rchild->color != 0) {//---- != root->rchild->rchild->color == 1(NIL)
            //------------不是红色
            root->rchild->color = 0;
            root->rchild = right_rotate(root->rchild);
            root->rchild->color = 1;
            
        }
        root = left_rotate(root);//大左旋
        root->color = root->lchild->color;//新根结点改成原根结点的颜色
    } else {//右兄弟结点为双黑结点
        if (root->lchild->lchild->color != 0) {
            root->lchild->color = 0;
            root->lchild = left_rotate(root->lchild);
            root->lchild->color = 1;
            root->lchild->color -= 1;
          
        }
        root = right_rotate(root);//大右旋
        root->color = root->rchild->color;
    }
    root->lchild->color = root->rchild->color = 1;//
    return root;
}

Node *__erase(Node *root, int value) {
    if (root == NIL) return NIL;
    if (value < root->data) root->lchild = __erase(root->lchild, value);
    else if (value > root->data) root->rchild = __erase(root->rchild, value);
    else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild != NIL ? root->lchild : root->rchild;
            temp->color += root->color;
            //若根节点为红色，值不变，若为黑色，子孩子一定为红色，
            //temp == NIL，root度为0，则，color=2,产生双黑结点
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = __erase(root->lchild, temp->data);
        }
    }
    return erase_maintain(root);
}

Node *erase(Node *root, int value) {
    root = __erase(root, value);
    root->color = 1;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void print(Node *root) {
    printf("(%d| %d, %d, %d)\n",
        root->color, root->data,
        root->lchild->data,
        root->rchild->data
    );
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    print(root);
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
            case 3: output(root);
        }
        output(root);
        printf("------------\n");
    }


    return 0;
}
```





```cpp
1 1
(1| 1, 0, 0)
------------
1 2
(1| 1, 0, 2)
(0| 2, 0, 0)
------------
1 3
(1| 2, 1, 3)
(1| 1, 0, 0)
(1| 3, 0, 0)
------------
2 3
(1| 2, 1, 0)
(0| 1, 0, 0)
------------
```



```bash
1 1
(1| 1, 0, 0)
------------
1 2
(1| 1, 0, 2)
(0| 2, 0, 0)
------------
1 3
(1| 2, 1, 3)
(1| 1, 0, 0)
(1| 3, 0, 0)
------------
1 -5
(1| 2, 1, 3)
(1| 1, -5, 0)
(0| -5, 0, 0)
(1| 3, 0, 0)
------------
2 3
(1| 1, -5, 2)
(1| -5, 0, 0)
(1| 2, 0, 0)
------------
```



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.47.12.png" alt="截屏2020-12-25 上午1.47.12" style="zoom:50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%881.49.37.png" alt="截屏2020-12-25 上午1.49.37" style="zoom:50%;" />





## 7.红黑树代码实现

![截屏2021-01-05 下午4.53.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%884.53.06.png)

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    int color;//0 red, 1 black 2double black
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {//空节点
    NIL->data = 0;
    NIL->color = 1;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int data) {//初始化一个新节点
    Node *root = (Node *)malloc(sizeof(Node));
    root->data = data;
    root->color = 0;
    root->lchild = root->rchild = NIL;
    return root;
}

int has_red_child(Node *root) {//判断根节点的孩子结点是否有红色
    return root->lchild->color == 0 || root->rchild->color == 0;
}

Node *left_rotate(Node *root) {
    //左旋，旧根节点的右孩子变成根节点，旧根节点的右孩子变成新根节点的左孩子，新根节点左孩子变成旧根节点
    Node *temp = root->rchild;//新根节点
    root->rchild = temp->lchild;//旧根节点的右孩子变成新根节点的左孩子
    temp->lchild = root;//新根节点左孩子是旧根节点
    return temp;
}

Node *right_rotate(Node *root) {
    //右旋，旧根节点左孩子变成新根节点，旧根节点的左孩子变成新根节点的右孩子，新根节点的右孩子变成旧根节点
    Node *temp = root->lchild;//新根节点为旧根节点的左孩子
    root->lchild = temp->rchild;//旧根节点的左孩子变成新根节点的右孩子
    temp->rchild = root;//新根节点的右孩子变成旧根节点
    return temp;
}

Node *insert_maintain(Node *root) {//插入新节点
    if (!has_red_child(root)) return root;//没有红色的孩子，不需要调整
    //没有判断是否发生双红冲突
    //不冲突的话，更改颜色不影响结果，如果发生冲突，更改颜色，解决冲突，root必定为黑色，因为孩子为红色
    int flag = 0;
    //分为两种情况 1.根节点的孩子中都是红色结点，2.根节点的孩子中有一个是红色
    // 1.根节点的孩子中都是红色结点
    if (root->lchild->color == 0 && root->rchild->color == 0 && 
    (has_red_child(root->lchild) || has_red_child(root->rchild))) goto insert_end;
    // 2.根节点的孩子中有一个是红色,使用flag标记两种情况
    // 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点
    if (root->lchild->color == 0 && has_red_child(root->lchild)) flag = 1;
    // 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点
    if (root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if (flag == 0) return root;
    if (flag == 1) { 
        // 2.1 根节点的左孩子是红色，且左孩子的子树中有红色结点
        // 2.1.1 根节点的左孩子的右孩子为红色，为LR型，需要小左旋大右旋，
        // 2.1.2 根节点的左孩子的左孩子为红色，为LL型，需要大右旋，
        if (root->lchild->rchild->color == 0)//LR,需要小左旋，大右旋
            root->lchild = left_rotate(root->lchild);
        root = right_rotate(root);
    } else {
        // 2.2 根结点的右孩子是红色，且右孩子的子树中有红色结点
        // 2.2.1 根节点的右孩子的左孩子为红色，为RL型，需要小右旋大左旋，
        // 2.2.2 根节点的左孩子的左孩子为红色，为RR型，需要大右旋，
        if (root->rchild->lchild->color == 0) {//RL,需要小右旋，大左旋
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
insert_end:
    root->color = 0;//这里选择红色上浮，其实红色上浮，红色下沉均可，
    root->lchild->color = root->rchild->color = 1;
    return root;
}


Node *__insert(Node *root, int value) {
    if (root == NIL) return getNewNode(value);//根节点为空或者找到插入位置，插入新节点
    if (root->data == value) return root;//新插入的结点已经存在，不需要操作
    //在左子树中插入
    if (value < root->data) root->lchild = __insert(root->lchild, value);
    //在右子树中插入
    else root->rchild = __insert(root->rchild, value);
    //插入完之后进行平衡调整，然后 返回结果
    return insert_maintain(root);
}

Node *insert(Node *root, int value) {//插入
    root = __insert(root, value);
    root->color = 1;
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
     if (root->rchild->color != 2 && root->lchild->color !=  2) return root;
     if (!has_red_child(root)) {//1.双黑兄弟无红色
         if (root->lchild->color == 2) {//1.2左双黑结点
             if (!has_red_child(root->rchild)) {//1.2.1双黑结点在左，且右兄弟子结点无红色
                 //父结点增加1重黑，双重黑结点与兄弟结点减少1重黑
                 root->color += 1;
                 root->lchild->color -=1;
                 root->rchild->color -=1;
             } else {//1.2.2双黑结点在左，且右兄弟有红色子结点，分为RL,RR
                 root->lchild->color = 1;
                 if (root->rchild->rchild->color != 0) {// 1.2.2.3右兄弟结点，其右孩子不为红色,左孩子为红色，RL
                     //小右旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成RR型
                     //root->rchild->lchild->color = root->rchild->color;//=1改黑**
                     root->rchild->color = 0;//改红
                     root->rchild = right_rotate(root->rchild);
                     root->rchild->color = 1;//改黑**
                 }
                 //大左旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑
                 root->rchild->color = root->color;
                 root = left_rotate(root);
                 root->rchild->color = root->lchild->color = 1;
             }
         } else if (root->rchild->color == 2){//1.3右双黑结点
             if (!has_red_child(root->lchild)) {//1.3.1双黑结点在右，且左兄弟子结点无红色,
                 //父结点增加1重黑，双重黑结点与兄弟结点减少1重黑
                 root->color += 1;
                 root->lchild->color -=1;
                 root->rchild->color -=1;
             } else {//1.3.2双黑结点在右，且左兄弟有红色子结点，分为LR,LL
                 root->rchild->color = 1;//双重黑减一重黑
                 if (root->lchild->lchild->color != 0) {// 1.3.2.3左兄弟结点，其右孩子不为红色,即左孩子为红色,LL
                     //小左旋，原兄弟结点改成红色，新兄弟结点改成黑色，转变成LL型
                     //root->lchild->rchild->color = root->lchild->color;//=1
                     root->lchild->color = 0;//改红
                     root->lchild = left_rotate(root->lchild);
                     root->lchild->color = 1;//改黑
                 }
                 //大右旋，新根结点等于原根结点 [双黑结点的父结点] 的颜色，两个新的子结点改为黑色，双黑结点减少1重黑
                 root->lchild->color = root->color;
                 root = right_rotate(root);
                 root->rchild->color = root->lchild->color = 1;
             }
         }
     } else {
         //2.双黑兄弟结点有红色,抓着双黑结点的父结点，向双黑结点旋转，原根结点改为红色，新根结点改为黑色
         if (root->lchild->color == 0) {//2.2右双黑,左为红,向右旋转,原根结点改为红色，新根结点改为黑色
            //root->lchild->color = root->color;
            root->color = 0;
            root = right_rotate(root);
            root->color = 1;
            root->rchild = erase_maintain(root->rchild);
         } else {//2.3左双黑,右为红,向左旋转,原根结点改为红色，新根结点改为黑色
            //root->rchild->color = root->color;
            root->color = 0;
            root = left_rotate(root);
            root->color = 1;
            root->lchild = erase_maintain(root->lchild);
        }
     }
     return root;
}

Node *__erase(Node *root, int value) {
    //删除有两种情况，删除度为2，和删除度为0和1
    if (root == NIL) return NIL;//没有要删除的值
    if (value < root->data) root->lchild = __erase(root->lchild, value);// 要删除的值在左子树中
    else if (value > root->data) root->rchild = __erase(root->rchild, value);// 要删除的值在右子树中
    else {// 找到要删除的值，有4种情况
        // 1.要删除的结点的孩子结点有空节点，即删除度为1或者度为0的结点
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild != NIL ? root->lchild : root->rchild;
            temp->color += root->color;
            // 1.1删除度为1的结点，分两种情况
            // 1.1.1若删除的根节点为红色，不会对红黑树的平衡产生影响，
            // 1.1.2若删除的根节点为黑色，他的子孩子一定为红色，如果为黑色，树不会平衡；删除根节点为黑色，temp->color = 2;产生双重黑结点
            // 1.2删除度为0的结点，分两种情况
            // 1.2.1删除度为0的红色结点，不会产生影响
            // 1.2.2删除度为0的黑色结点，temp = NIL,color=2,产生双黑结点
            free(root);//释放要删除的结点
            return temp;
        // 2.删除度为2的结点，转换成度为1或0的结点，转换的方法是和他的前驱结点交换 
        } else {
            Node *temp = predecessor(root);
            root->data = temp->data;
            root->lchild = __erase(root->lchild, temp->data);
        }
    }
    root = erase_maintain(root);
    return root;
}

Node *erase(Node *root, int value) {//删除结点
    root = __erase(root, value);
    root->color = 1;//根节点为黑色
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void print(Node *root) {
    printf("%d %d %d %d\n",
        root->data, 
        root->color,
        root->lchild->data,
        root->rchild->data
    );
    return ;
}

void output(Node *root) {//中序遍历
    if (root == NIL) return ;
    output(root->lchild);
    print(root);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
            case 3: output(root);
        }
        //output(root);
        //printf("------------\n");
    }


    return 0;
}
```



















# 5.哈夫曼树

## 1.编码



### 什么是编码



'a' = 97 = $(0110\ 0001)_2$

'0' = 48 = $(0011\ 0000)_2$

注意：任何信息，在计算机中，都是二进制存储的



信息："aa00" = $01100001、01100001、00110000、00110000$

一台计算机   传输到  另外一台计算机，传输 32 个比特位

假设：计算机的网络是 32bit/s。所以用时：1 s



特定场静：只有 a,b,0,1 四种字符需要传输

海贼班编码：a:00, b: 01, 0: 10, 1: 11

"aa00" = 00001010

在带宽不变的情况下，当前只需要传输 0.25s





### 定长与变长编码



2. Ascii编码和特定场景下的编码，都属于定长编码
3. 对于每一个字符，编码长度相同，这就是定长编码
4. UTF-8编码是变长编码，UTF-16是定长编码
5. 对于每一个字符，编码长度不同，这就是变长编码
5. 将定长编码，看成是变长编码的特例
6. 变长编码，一定不差于定长编码





### 变长编码应用场景



特定场静：

1. 只有四种字符 : ab01
2. a: 0.8, b: 0.05, 0: 0.1, 1: 0.05

平均编码长度：

$l_i$：第 i 种字符，编码长度

$p_i$：第 i 种字符，出现概率

$avg(l) = \sum{l_i}\times{p_i}$



假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位



海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i}=2$

平均编码长度就是编码的定长



新·海贼班编码：

a: 1

b: 01

0: 000

1: 001



平均编码长度：$1*0.8+2*0.05+3*0.1+3*0.05=1.35$



100个字符，传输135个比特位

==>将定长编码看成变长编码的特例，变长编码不差于定长编码





## 2.哈夫曼编码



1. 首先，统计得到每一种字符的概率
2. 将 n 个字符，建立成一棵哈弗曼树
3. 每一个字符，都落在叶子结点上
4. 按照左0，右1的形式，将编码读取出来



![截屏2020-12-29 上午10.14.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8A%E5%8D%8810.14.23.png)



得到新编码：

a: 0 | b: 110 | 0: 10 | 1: 111

平均编码长度：$1*0.8+3*0.05+2*0.1+3*0.05=1.3$



结论：哈弗曼编码，是最优的变长编码







## 4.公式证明

1. 首先表示平均编码长度，求解公式最优解
2. 最终，和熵与交叉熵之间的关系



 证明$\sum{l_i}\times{p_i}$最小，令$l = -l’$，即证明$-\sum{l_i}\times{p_i}$最小

约束$\sum{l_i}\times{p_i} <=  1$



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.28.35.png" alt="截屏2020-12-29 下午12.28.35" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%8812.45.54.png" alt="截屏2020-12-29 下午12.45.54" style="zoom: 33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%881.02.11.png" alt="截屏2020-12-29 下午1.02.11" style="zoom:33%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.35.56.png" alt="截屏2020-12-30 上午9.35.56" style="zoom:33%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-30%20%E4%B8%8A%E5%8D%889.51.45.png" alt="截屏2020-12-30 上午9.51.45" style="zoom:33%;" />





## 5.代码演示



```c
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) { \
    __typeof(a) __c = a; \
    a = b, b = __c; \
}

typedef struct Node {
    char ch;
    double p;//概率值
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(char _ch, double _per) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->ch = _ch;
    p->p = _per;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *CombinNode(Node *a, Node *b) {//合并成新结点
    Node *p = getNewNode(0, a->p + b->p);
    p->lchild = a;
    p->rchild = b;
    return p;
}

void pick_min(Node **arr, int n) {//找到概率最小的结点
    for (int j = n - 1; j >= 0; --j) {
        if (arr[n]->p > arr[j]->p) {
            swap(arr[n], arr[j]);
        }
    }
    return ;
}

Node *getHaffmanTree(Node **arr, int n) {//生成n个结点的哈夫曼树，n个结点循环n-1次形成树
    for (int i = 1; i < n; i++) {
        pick_min(arr, n - i);//最小的放在最后面，次之放倒数第二
        pick_min(arr, n - i - 1);
        arr[n - i - 1] = CombinNode(arr[n - i], arr[n - i - 1]);
    }
    return arr[0];
}

void __output_encode(Node *root, char *str, int k) {
    str[k] = 0;
    if (root->lchild == NULL && root->rchild == NULL) {//根节点
        printf("%c %s\n", root->ch, str);
        return ;
    }
    str[k] = '0';
    __output_encode(root->lchild, str, k + 1);//左0右1
    str[k] = '1';
    __output_encode(root->rchild, str, k + 1);
    return ;
}

void output_encode(Node *root) {//
    char str[100];
    __output_encode(root, str, 0);
    return ;
}


void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

int main() {
    int n;
    Node **arr;//数组
    scanf("%d", &n);//要输节点数量
    arr = (Node **)malloc(sizeof(Node *) * n);
    for (int i = 0; i < n; i++) {
        char ch[10];
        double p;
        scanf("%s%lf", ch, &p);//输入节点
        arr[i] = getNewNode(ch[0], p);
    }
    Node *root = getHaffmanTree(arr, n);//获取哈夫曼树
    output_encode(root);//输出哈夫曼树
    clear(root);
    free(arr);
   

    return 0;
}
```









# 6.单调栈和单调队列

## 6.1课前热身

### 6.1HZOJ-261-数据结构

![截屏2021-01-14 下午9.40.35](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.35.png)

![截屏2021-01-14 下午9.40.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%889.40.47.png)

1. 关键就是新造一个数据结构，结构定义 + 结构操作

2. 模拟光标的功能，左移动、右移动、插入、删除，用对顶栈模拟

3. 实现对顶栈，用数组模拟、用链表模拟

4. 题目中的 BUG：Query K 中，K 可能大于当前位置

   ------

   

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <cinttypes>
using namespace std;

class NewStruct {
public:
    NewStruct() {
        sum[0] = 0;//sum[0] = 0;
        ans[0] = INT64_MIN;
    }
    void insert(int x) {//插入元素
        s1.push(x);//在s1中插入
        long long val = s1.top() + sum[s1.size() - 1];
        sum[s1.size()] = val;//前i项和
        ans[s1.size()] = max(ans[s1.size() - 1], val);//前i项和的最大值，在前i项和sum和前i-1项和中的最大值做比较
        return ;
    }
    void del() {
        if (s1.empty()) return ;
        s1.pop();
        return ;
    }
    void move_left() {
        if (s1.empty()) return ;
        s2.push(s1.top());
        del();
        //s1.pop();
        return ;
    }
    void move_right() {
        if (s2.empty()) return ;
        insert(s2.top());
        //s1.push(s2.top());
        s2.pop();
        //sum.pop_back(s2.top());
        //ans.push_back(s1.top() + sum[sum.size() - 1]);
    }
    long long query(int k) {
        return ans[k];
    }
private:
    stack<long long> s1, s2;
    long long sum[1005];
    long long ans[1005];
};

int main() {
    long long n;
    cin >> n;//输入第一行为操作数 𝑁。
    string op;
    int val;
    NewStruct s;
    for (int i = 0; i < n; i++) {
        cin >> op;
        switch(op[0]) {
        case 'I': cin >> val; s.insert(val); break;//在当前位置插入 𝑥 元素；
        case 'D': s.del(); break;// 删除当前位置的元素；
        case 'L': s.move_left(); break;//将当前位置左移一位，除非它已经是第一个元素；
        case 'R': s.move_right(); break;//将当前位置右移一位，除非它已经是最后一个元素
        case 'Q': cin >> val; cout << s.query(val) << endl; break;//𝑘  在当前位置之前，找到一个最大的 𝑆𝑖(1≤𝑖≤𝑘,𝑆𝑖=𝑎1+𝑎2+...+𝑎𝑖)
        default : cout << "error" << endl; break;
        }
    }


    return 0;
}
```



### 6.2HZOJ-263-火车进栈

------

![截屏2021-01-15 上午10.55.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png)

![截屏2021-01-15 上午10.56.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8A%E5%8D%8810.56.08.png)

------



1. 当前要进栈的最大数字是 x，序列中当前待出栈的数字是 y

2. $y <= x$，说明 y 一定是栈顶元素

3. $y > x$，将 $[x + 1, y]$ 入栈，此时栈顶元素一定是 y

   a[i]=3421

   要进栈的1，待出3

   3>1,123进栈，stack=123

   4进栈：stack=123，待出栈3(y)，待进栈4(x)，4>3==>3是栈顶，3出栈，4进栈

   stack=124,a[i]=3421

   依次出栈

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int a[30], stack[30], top;

bool is_valid(int *a, int n) {
    int j = 0;//要进栈元素
    top = -1;
    for (int i = 0; i < n; i++) {
        while(j < a[i]) {
            stack[++top] = ++j;
        }
        if (top == -1 || stack[top] - a[i]) return false;
        --top;
    }
    return true;
}

int main() {
    int n, ans = 20;;
    cin >> n;
    for (int i = 0; i < n; i++) a[i] = i + 1;
    do {
        if (!is_valid(a, n)) continue;
        for (int i = 0; i < n; i++) {
            cout << a[i];
        }
        cout << endl;
        --ans;
    } while(ans && next_permutation(a, a + n));
    return 0;
}
```

------



## 6.2.单调队列

![截屏2021-01-15 下午2.11.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.11.28.png)

![截屏2021-01-15 下午2.14.28](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.14.28.png)

![截屏2021-01-15 下午2.16.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.16.34.png)





1. 本质问题是：固定查询结尾的 RMQ 问题，例如 $RMQ(x, 7)$
2. 问题性质：维护滑动窗口最值问题
3. 入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队
4. 出队：如果队首元素超出了滑动窗口的范围，队首出队
5. 队首元素：滑动窗口内的最值
6. 均摊时间复杂度：$O(1)$



![截屏2021-01-15 下午2.18.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.18.02.png)





注：单调队列维护的区间最小值一定在队首



入队操作：

![截屏2021-01-15 下午2.28.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.28.58.png)









## 6.3单调队列例题HZOJ-271-滑动窗口

![截屏2021-01-15 下午2.43.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.25.png)

![截屏2021-01-15 下午2.43.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%882.43.34.png)



单调队列的裸题,主要要学习代码实现

**思考：**单调队列中是记录值还是记录下标的问题

**结论：**==记录下标，因为有了下标可以索引到值，记录值则反向不可查==





## 6.4单调队列及HZOJ271代码实现

```cpp
#include <iostream>
using namespace std;

#define MAX_N 300000
int queue[MAX_N + 5];//维护数组的单调队列，存储数组下标
int head = 0, tail = 0;//头指针，尾指针
int val[MAX_N + 5];//数组

int main() {
    int n, k;
    cin >> n >> k;//给出一个长度为 𝑁 的数组,一个长为 𝐾 的滑动窗口
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    for (int i = 1; i <= n; i++) {//滑动窗口最小值，用单调递增队列
        while ((tail - head) && val[queue[tail - 1]] > val[i]) --tail;
        //队列中有元素，并且当前队尾元素的值>要入队的元素，大于要入队的元素全部出队
      //维护单调队列的单调性
        queue[tail++] = i;//存储下标
        if (queue[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[queue[head]];
        }
    }
    cout << endl;

    head = tail = 0;//队列清空
    for (int i = 1; i <= n; i++) {//滑动窗口最大值，用单调递减队列
        while ((tail - head) && val[queue[tail - 1]] < val[i]) --tail;
        //队列中有元素，并且当前队尾元素的值 < 要入队的元素，小于要入队的元素全部出队
        queue[tail++] = i;//存储下标
        if (queue[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[queue[head]];
        }
    }
    cout << endl;
    return 0;
}

```



## 6.5单调栈

![截屏2021-01-151 下午4.34.26](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-151%20%E4%B8%8B%E5%8D%884.34.26.png)

![截屏2021-01-15 下午4.34.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.34.59.png)

1. 单调栈保留了单调队列的『入队』操作
2. 单调栈依然是维护了一种单调性
3. 问题性质：最近（大于/小于）关系
4. 入栈之前，符合单调性的栈顶元素，就是我们要找的最近（大于/小于）关系
5. 均摊时间复杂度：$O(1)$

![截屏2021-01-15 下午4.30.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.37.png)

![截屏2021-01-15 下午4.30.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.30.50.png)

![截屏2021-01-15 下午4.31.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.31.08.png)







## 6.6单调栈例题HZOJ-264-最大矩形面积

![截屏2021-01-15 下午4.56.22](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png)

![截屏2021-01-15 下午4.56.33](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.56.33.png)





1. 分析最优解的性质，是解决问题的第一步
2. 最大矩形的性质：一定是以其所在区域中最矮的木板为高度的
3. 以每一块木板做为矩形高度，求能得到的最大矩形面积，最后在所有面积中，取一个最大值
4. 需要求解：每一块木板最近的高度小于当前木板的位置，所以需要用单调栈





![截屏2021-01-15 下午4.57.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png)

![截屏2021-01-15 下午4.57.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%884.57.45.png)





```cpp
#include <iostream>
using namespace std;
#define MAX_N 100000
long long stack[MAX_N + 5];//单调栈，记录下标
long long top;//栈顶指针
long long h[MAX_N + 5];//记录每一块木板的长度
long long n;

long long l[MAX_N + 5],r[MAX_N + 5];//l

void read() {
    //cin >> n;
    scanf("%lld", &n);
    //输入共一行，第一个数表示矩形的个数 𝑁。接下来 𝑁 个数表示矩形的大小。（1≤𝑁≤100000）
    for (long long i = 1; i <= n; i++) scanf("%lld", h + i);
        //cin >> h[i];
    return ;
}

long long solve() {
    h[0] = h[n + 1] = -1;//最边上的两块木板,即边界木板
    top = -1;
    //求最近小于关系，单调递增栈
    //左边木板
    stack[++top] = 0;//0坐标先压栈
    for (long long i = 1; i <= n; i++) {
        while (top != -1 && h[stack[top]] >= h[i]) --top;//出栈
        l[i] = stack[top];
      //第i块木板左边离他最近的且高度小于他的木板编号
        stack[++top] = i;//入栈

    }
    //右边木板
    top = -1;//清空栈
    //求最近小于关系，单调递增栈
    stack[++top] = n + 1;//最右边坐标先压栈
    for (long long i = n; i >= 1; i--) {
        while (top != -1 && h[stack[top]] >= h[i]) --top;//出栈
        r[i] = stack[top];
      //第i块木板右边离他最近的且高度小于他的木板编号
        stack[++top] = i;//入栈
    }
    long long ans = 0;
    for (long long i = 1; i <= n; i++) {
        ans = max(ans, h[i] * (r[i] - l[i] - 1));
    }
    return ans;
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}

```





# 7.单调队列和单调栈习题

## 7.1HAIZEIOJ51矩形

 ![截屏2021-02-05 上午10.43.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-05%20%E4%B8%8A%E5%8D%8810.43.49.png)

![截屏2021-01-15 下午8.29.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-15%20%E4%B8%8B%E5%8D%888.29.51.png)





![截屏2021-01-17 上午9.46.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%889.46.36.png)

1. 左上角坐标和右下角坐标可以唯一确定一个子矩形
2. 确定一行，将问题转换成子问题，右下角坐标落在固定的一行上，求每个点能构成的合法子矩形数量
3. 通过观察，将问题变成两部分子问题
4. $f(x)$ 代表以 X 做为右下角坐标所能构成的合法子矩形数量
5. 首先找到左侧离 X 点最近的，小于 X 点的位置 i
6. $f(x) = h_x\times (x-i) + f(i)$
7. 因为需要求解离 X 最近的小于 X 的位置，所以要用到单调栈



```cpp
#include <iostream>
using namespace std;
#define MAX_N 1000
#define MOD_NUM 100007
int stack[MAX_N + 5], top;
int c[MAX_N + 5][MAX_N + 5];//c[i][j]从[i,j]向上数，有多少个连续的白色格子，即矩形高
int f[MAX_N + 5];//
int n, m;

void read() {
    cin >> n >> m;//第一行输入两个数字 𝑛,𝑚（2≤𝑛,𝑚≤1000），代表矩形的长和宽。
    //接下来 𝑛 行，每行 𝑚 个数字，0 代表黑色格子，1 代表白色格子。
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> c[i][j];
            if (c[i][j] == 1) c[i][j] += c[i - 1][j];
        }
    }
    return ;
}

int solve() {
    long long ans = 0;
    for (int i = 1; i <= n; i++) {//n行
        top = -1;
        stack[++top] = 0;
        c[i][0] = -1;
        f[0] = 0;
        for (int j = 1; j <= m; j++) {//每行m个数字
            while(top != -1 && c[i][stack[top]] > c[i][j]) --top;//出栈，找到第一个比c[i][j]矮的
            f[j] = c[i][j] * (j - stack[top]) + f[stack[top]];//子矩形个数=矩形高x宽(即f(i)右边的子矩形个数) + f(i)左边的子矩形个数
            //cout << "f[j]" << j << " " << f[j] << endl;
            stack[++top] = j;
            f[j] %= MOD_NUM;
            ans += f[j];
            ans %= MOD_NUM;
        }
    }
    return ans;
}


int main() {
    read();
    cout << solve() << endl;



    return 0;
}
```







## 7.2HZOJ-52-古老的打字机

![截屏2021-01-17 上午11.00.47](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.47.png)

![截屏2021-01-17 上午11.00.58](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.00.58.png)





### 状态定义

$dp[i]$ 代表打印前 i 个字符的最小消耗值



### 状态转移方程

定义： $s_i = \sum_{k=1}^{i}c_k$

$dp[i] = min(dp[j] + (s_i - s_j)^2 + M)$



**时间复杂度：**$O(n^2)$



### 斜率优化

假设从 j 转移要优于从 k 转移

$dp[j] + (s_i-s_j)^2+M < dp[k] + (s_i-s_k)^2+M$

$dp[j] + s_j^2-2s_is_j < dp[k] + s_k^2-2s_is_k$

$(dp[j] + s_j^2) -(dp[k] + s_k^2)< 2s_i(s_j-s_k)$

$\frac{(dp[j] + s_j^2) -(dp[k] + s_k^2)}{s_j-s_k}< 2s_i$

设：$f(i) = dp[i] + s_i^2$

$\frac{f(j) - f(k)}{s_j-s_k}< 2s_i$ ，这东西就是一个斜率



![截屏2021-01-17 上午11.08.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.08.58.png)

![截屏2021-01-17 上午11.09.10](Desktop/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.10.png)

![截屏2021-01-17 上午11.09.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.25.png)

==>$\frac{f(j) - f(k)}{s_j-s_k}< 2s_i$ 意味着从j点转移比从k点转移更优秀



![截屏2021-01-17 上午11.09.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.34.png)

1.从k转移优于从j转移，从l转移优于从k转移，所以选择从l转移

2.。

3..

![截屏2021-01-17 上午11.09.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8A%E5%8D%8811.09.39.png)

经过斜率优化以后，时间复杂度优化成了：$O(n)$



```cpp
#include <iostream>
using namespace std;

#define MAX_N 1000000
#define S(a) ((a) * (a))
long long  dp[MAX_N + 5], c[MAX_N + 5], s[MAX_N + 5];
int n, M;
long long f[MAX_N + 5];
int q[MAX_N + 5], head, tail;

double slope(int i, int j) {//求斜率
    return 1.0 * (f[i] - f[j])/(s[i] - s[j]);
}

void read() {
    cin >> n >> M;
    //第一行输入两个数字，𝑛,𝑀(1≤𝑛≤106,1≤𝑀≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。
    //第二行输入 𝑛 个数字，第 𝑖 个数字代表文章中第 𝑖 个字符的磨损值 𝐶𝑖(1≤𝐶𝑖≤100)。
    for (int i = 1; i <= n; i++) {
        cin >> c[i];//cin >> s[i];
        s[i] = s[i - 1] + c[i];//s[i] = s[i - 1] + s[i];
    }
    return ;
}

void set_dp(int i, int j) {//从i点转移到j点
    dp[i] = dp[j] + S(s[i] - s[j]) + M;
    f[i] = dp[i] + S(s[i]);
    return ;
}

long long solve()  {
    head = tail = 0;
    q[tail++] = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head >= 2 && slope(q[head + 1], q[head]) < 2 * s[i]) ++head;//
        set_dp(i, q[head]);
        while (tail - head >= 2 && slope(i, q[tail - 1]) < slope(q[tail - 2], q[tail - 1])) --tail;
        q[tail++] = i;
    }
    return dp[n];
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}
```



## 三、HZOJ-372-双生序列**1**

1. 因为两个序列的每个区间的 RMQ 值都相等，等价于两个序列的单调队列长得一样
2. 将两个序列，依次插入到单调队列中，过程中判断单调队列是否一样，如果不一样，就退出
3. 所以，需要使用单调队列

```

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 500000

class Queue {
public :
    Queue(int *arr) : arr(arr) {}
    void push(int i) {
        while (tail - head && arr[q[tail - 1]] > arr[i]) --tail;
        q[tail++] = i;
        return ;
    }
    void pop() { ++head; }
    int size() { return tail - head; }

private:
    int *arr;
    int q[MAX_N + 5], head, tail;
};

int a[MAX_N + 5], b[MAX_N + 5];
int n;
Queue q1(a), q2(b);

void read() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];
    return ;
}

int main() {
    read();
    int p;
    for (p = 0; p < n; p++) {
        q1.push(p);
        q2.push(p);
        if (q1.size() != q2.size()) break;
    }
    cout << p << endl;
    return 0;
}

```



## 四、HZOJ-270-最大子序和1

1. 有个限制条件：子序列的长度不超过 M
2. 转换成前缀和数组上的问题，就是 $S_i - S_j$，其中$i-j <= M$
3. 在前缀和数组上，维护一个大小为 M 的滑动窗口中的最小值
4. 所以，采用单调队列维护区间最小值

![image-20210110214945169](../guanghu/Library/Application%20Support/typora-user-images/image-20210110214945169.png)

```

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <climits>
using namespace std;
#define MAX_N 300000
int s[MAX_N + 5], n, m;
int q[MAX_N + 5], head, tail;

void read() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
        s[i] += s[i - 1];
    }
    return ;
}

int solve() {
    int ans = INT_MIN;
    head = tail = 0;
    q[tail++] = 0;
    for (int i = 1; i <= n; i++) {
        if (i - q[head] > m) head++;
        ans = max(ans, s[i] - s[q[head]]);
        while (tail - head && s[q[tail - 1]] > s[i]) --tail;
        q[tail++] = i;
    }
    return ans;
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}

```



# 8.双数组字典树

![截屏2021-01-27 上午9.54.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%889.54.32.png)



![截屏2021-01-27 上午10.16.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.16.09.png)





![截屏2021-01-27 上午10.21.23](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.21.23.png)





![截屏2021-01-27 上午10.25.11](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.25.11.png)





![截屏2021-01-27 上午10.31.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.31.37.png)





![截屏2021-01-27 上午10.53.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8810.53.14.png)





![截屏2021-01-27 上午11.03.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.03.38.png)

![截屏2021-01-27 上午11.07.01](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.07.01.png)

![截屏2021-01-27 上午11.07.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.07.20.png)

![截屏2021-01-27 上午11.12.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-27%20%E4%B8%8A%E5%8D%8811.12.14.png)





## 8.1传统字典树的缺点

1. 完全二叉树，实际存储结构是连续数组空间，思维逻辑结构是树型的
2. 完全二叉树，节省了大量的存储边的空间
3. 优化思想：节省空间的方法叫做 记录式 改 计算式
4. $n$ 个节点的字典树，有效使用 $n-1$ 条边，浪费了 $(k-1)*n+1$ 条边的存储空间
5. 参考完全二叉树的优点，提出了双数组字典树



## 8.2双数组字典树

1. 顾名思义，两个数组代表一棵字典树结构

2. base 数组信息与子节点编号相关，base + i 就是第 i 个子节点编号，base数组确定父亲的子孩子

3. check 数组信息负责做【亲子鉴定】，check 数组中用正负表示是否独立成词

4. 不擅长进行动态插入操作，不适合插入操作

5. 一次建立，终身使用

6. 为了方便，基于普通字典树实现的双数组字典树

7. 增加了 fail 数组，可以完成基于双数组字典树的 AC 自动机

8. 超小规模实验结果：双数组字典树压缩效率是 25 倍

9. 非常方便的输出到文件中，进行机器之间的共享

10. 课后作业：利用真实数据集，测试双数组字典树的压缩效率

    

```cpp
#include <iostream>
#include <cstring>
using namespace std;

#define BASE 26

typedef struct Node {//字典树
    int flag;
    struct Node *next[BASE];//存储26个英文字符的字典树
} Node;

typedef struct DANode {//双数组字典树结构
    int base, check;//
} DANode;//

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {//在字典树中插入
    int cnt = 0;
    Node *p = root;//指向当前插入字符串的位置
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {//相关子节点为空
            cnt++;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;//返回本次插入str时一共生成几个新节点
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;//如果存在check值，说明base值已经被占用
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    //字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标
    //返回最大的下标值
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;//当前节点独立成词
    int base = get_base_value(root, tree, ind);//获得当前节点的base值
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;//子节点check存储父节点下标
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {//依次确认每一个子节点是base值
        int temp = transform_double_array_trie(root->next[i], tree, base + i);
        if (temp > max_ind) max_ind = temp;
    }
    return max_ind;//返回最大下标
}

void clear_trie(Node *root) {
    if (root == NULL)  return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    int n, cnt =  1;//字典树中一共有cnt个节点
    char str[1000];
    scanf("%d", &n);//读入n个单词
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);//每次读入一个单词插入字典树中
        cnt += insert(root, str);
    }
    //将字典树转换成双数组字典树
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    printf("trie(%lu Byte), double array trie(%lu, Byte)\n", s1, s2);
    for (int i = 0; i <= max_ind; i++) {
        printf("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1 ) % 5 == 0) printf("\n");
    }
    cout << endl;
    free(tree);
    clear_trie(root);

    return 0;
}

```



```shell
./a.out < 18.input17
(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)
(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)
(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)
(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)
(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)
(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)
```

```c
//18.input17
5
haizei
kaikeba
harbin
hug
zpark
```



```cpp
#include <iostream>
#include <cstring>
using namespace std;

#define BASE 26
#define MSG_LEVEL 1
#define DEBUG_LEVEL 1
#define INFO_LEVEL 2

#define LOG(level, frm, args...) {\
    if (level >= MSG_LEVEL) {\
        printf(frm, ##args);\
    }\
}

#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args);
#define LOG_INFO(args...) LOG(INFO_LEVEL, args);



typedef struct Node {//字典树
    int flag;
    struct Node *next[BASE];//存储26个英文字符的字典树
} Node;

typedef struct DANode {//双数组字典树结构
    int base, check, fail;//
} DANode;//

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {//在字典树中插入
    int cnt = 0;
    Node *p = root;//指向当前插入字符串的位置
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {//相关子节点为空
            cnt++;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;//返回本次插入str时一共生成几个新节点
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;//如果存在check值，说明base值已经被占用
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    //字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标
    //返回最大的下标值
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;//当前节点独立成词
    int base = get_base_value(root, tree, ind);//获得当前节点的base值
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;//子节点check存储父节点下标
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {//依次确认每一个子节点是base值
        int temp = transform_double_array_trie(root->next[i], tree, base + i);
        if (temp > max_ind) max_ind = temp;
    }
    return max_ind;//返回最大下标
}

void dump_double_array_tree(DANode *tree, int n) {
    LOG_INFO("%d\n", n);
    for (int i = 0; i <= n; i++) {
        LOG_INFO("%d %d \n", tree[i].base, tree[i].check);
    }
    return ;
}

void clear_trie(Node *root) {
    if (root == NULL)  return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    int n, cnt =  1;//字典树中一共有cnt个节点
    char str[1000];
    scanf("%d", &n);//读入n个单词
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);//每次读入一个单词插入字典树中
        cnt += insert(root, str);
    }
    //将字典树转换成双数组字典树
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    LOG_DEBUG("trie(%lu Byte), double array trie(%lu, Byte)\n", s1, s2);
    LOG_DEBUG("rate : %.2lf\n", 1.0 * s2 / s1);
    for (int i = 0; i <= max_ind; i++) {
        LOG_DEBUG("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1 ) % 5 == 0) LOG_DEBUG("\n");
    }
    LOG_DEBUG("\n");
    //将字典树双数组输入到文件中去
    dump_double_array_tree(tree, max_ind);
    free(tree);
    clear_trie(root);

    return 0;
}
```



```
trie(5400 Byte), double array trie(336, Byte)
rate : 0.06
(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)
(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)
(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)
(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)
(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)
(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)
28
0 0
2 0
2 9
5 19
6 12
17 7
3 28
4 16
2 -22
2 1
3 2
2 -6
4 1
2 3
6 4
2 -13
3 14
2 -5
20 27
2 2
4 18
13 20
2 9
2 -21
0 0
0 0
0 0
3 1
2 10
```



## 8.3在双数组字典树中建立AC自动机

```cpp
#include <iostream>
#include <cstring>
using namespace std;

#define BASE 26
#define MSG_LEVEL 1
#define DEBUG_LEVEL 1
#define INFO_LEVEL 2

#define LOG(level, frm, args...) {\
    if (level >= MSG_LEVEL) {\
        printf(frm, ##args);\
    }\
}

#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args);
#define LOG_INFO(args...) LOG(INFO_LEVEL, args);



typedef struct Node {//字典树
    int flag;
    struct Node *next[BASE];//存储26个英文字符的字典树
} Node;

typedef struct DANode {//双数组字典树结构
    int base, check, fail;//fail用于在双数组字典树中建立AC自动机
} DANode;//

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {//在字典树中插入
    int cnt = 0;
    Node *p = root;//指向当前插入字符串的位置
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {//相关子节点为空
            cnt++;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;//返回本次插入str时一共生成几个新节点
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;//如果存在check值，说明base值已经被占用
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    //字典树转换成双数组字典树，双数组字典树存储在tree中，ind：根节点在双数组字典树中的下标
    //返回最大的下标值
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;//当前节点独立成词
    int base = get_base_value(root, tree, ind);//获得当前节点的base值
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;//子节点check存储父节点下标
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {//依次确认每一个子节点是base值
        int temp = transform_double_array_trie(root->next[i], tree, base + i);
        if (temp > max_ind) max_ind = temp;
    }
    return max_ind;//返回最大下标
}

void dump_double_array_tree(DANode *tree, int n) {
    LOG_INFO("%d\n", n);
    for (int i = 0; i <= n; i++) {
        LOG_INFO("%d %d %d\n", tree[i].base, tree[i].check, tree[i]. fail);
    }
    return ;
}

void clear_trie(Node *root) {
    if (root == NULL)  return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

void build_ac_base_double_array_trie(DANode *tree, int max_ind) {
    int *que = (int *)malloc(sizeof(int) * (max_ind + 5));
    int head, tail;
    head = tail = 0;
    tree[1].fail = 0;
    for (int i = 0; i < BASE; i++) {
        int child_ind = tree[1].base + i;
        if (abs(tree[child_ind].check) != 1) continue;//第i个节点有子孩子
        tree[child_ind].fail = 1;//fail节点指向子孩子
        que[tail++] = child_ind;
    }
    while (head < tail) {
        int p = que[head++];//当前节点不为空，取出当前节点
        for (int i = 0; i < BASE; i++) {
            int c = tree[p].base + i, k = tree[p].fail;
            if (abs(tree[c].check) != p) continue;
            while (k && tree[tree[k].base + i].check != k) k = tree[k].fail;//k节点下面没有第k个子孩子
            if (k == 0) k = 1;
            if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;
            tree[c].fail = k;//初始化c节点的fail值
            que[tail++] = c;
        }
    }
    free(que);
    return ;
}


int main() {
    int n, cnt =  1;//字典树中一共有cnt个节点
    char str[1000];
    scanf("%d", &n);//读入n个单词
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);//每次读入一个单词插入字典树中
        cnt += insert(root, str);
    }
    //将字典树转换成双数组字典树
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    LOG_DEBUG("trie(%lu Byte), double array trie(%lu, Byte)\n", s1, s2);
    LOG_DEBUG("rate : %.2lf\n", 1.0 * s2 / s1);
    for (int i = 0; i <= max_ind; i++) {
        LOG_DEBUG("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1 ) % 5 == 0) LOG_DEBUG("\n");
    }
    LOG_DEBUG("\n");
    //将字典树双数组输入到文件中去
    build_ac_base_double_array_trie(tree, max_ind);
    dump_double_array_tree(tree, max_ind);
    free(tree);
    clear_trie(root);

    return 0;
}

```



```
trie(5400 Byte), double array trie(336, Byte)
rate : 0.06
(0 | 0, 0)	(1 | 2, 0)	(2 | 2, 9)	(3 | 5, 19)	(4 | 6, 12)
(5 | 17, 7)	(6 | 3, 28)	(7 | 4, 16)	(8 | 2, -22)	(9 | 2, 1)
(10 | 3, 2)	(11 | 2, -6)	(12 | 4, 1)	(13 | 2, 3)	(14 | 6, 4)
(15 | 2, -13)	(16 | 3, 14)	(17 | 2, -5)	(18 | 20, 27)	(19 | 2, 2)
(20 | 4, 18)	(21 | 13, 20)	(22 | 2, 9)	(23 | 2, -21)	(24 | 0, 0)
(25 | 0, 0)	(26 | 0, 0)	(27 | 3, 1)	(28 | 2, 10)
28
0 0 0
2 0 0
2 9 1
5 19 1
6 12 1
17 7 1
3 28 1
4 16 1
2 -22 1
2 1 1
3 2 1
2 -6 1
4 1 1
2 3 1
6 4 1
2 -13 1
3 14 12
2 -5 1
20 27 1
2 2 1
4 18 1
13 20 1
2 9 1
2 -21 12
0 0 0
0 0 0
0 0 0
3 1 1
2 10 27
```





## 8.4 二叉字典树

1. 计算机中所有信息都是二进制存储的
2. 任何信息都可以看成一个二进制串
3. 插入二进制串的字典树，就是二叉字典树
4. 二叉字典树可以存储任意信息
5. 节省空间，浪费时间，本质：时间换空间的算法思维
6. 哈弗曼编码 + 二叉字典树 可能更配哦，既节省了空间，又在最大限度上节省了查找时间







**建议：**多看几本基本的算法书、【数论基础】、多接触离散型数学思维



end 2021.1.30



不积跬步，无以至千里。不积小流，无以成江海。 




