\---

title: 面试笔试算法下

date: 2020-12-22 08:08:15

tags: 面试笔试算法下

categories: 面试笔试算法下

\---





[TOC]

















































# 1.线段树



## 0.线段树结构

 

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.22.png" alt="截屏2020-12-31 上午11.32.22" style="zoom: 50%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.35.png" alt="截屏2020-12-31 上午11.32.35" style="zoom:50%;" />





## 1.问题背景

1. 单点修改，区间查询（基础版）
2. 区间修改，区间查询（进阶版）
3. 单点修改，单点查询（用不着线段树）
4. 区间修改，单点查询（是第二种情况的特例）



 

## 2.线段树区间查询及单点修改



### 1.操作

Modify(7,9) ：修改7位置上的值为9

Query(2, 6) : 查询[2,6]区间的和值==> 30

Modify(2,3) ：修改2位置上的值为3

Query(2, 6) : 查询[2,6]区间的和值==> 25



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.10.png" alt="截屏2020-12-31 上午11.32.10" style="zoom:50%;" />



### 2.具体过程

1）Modify(2,3)<!--图中0--1出有错误,tree[0]=8 -->



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.42.png" alt="截屏2020-12-31 上午11.32.42" style="zoom:50%;" />



2）将2上面的值改为3

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.48.png" alt="截屏2020-12-31 上午11.32.48" style="zoom:50%;" />

3）更新根节点上的和值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.32.56.png" alt="截屏2020-12-31 上午11.32.56" style="zoom:50%;" />

4）Query(2, 6) :

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.33.02.png" alt="截屏2020-12-31 上午11.33.02" style="zoom:50%;" />





## 3.基础版线段树

1. 线段树是对于一维序列的一种维护结构
2. 采用的分治的思想，将总区间分成左右两部分，一直进行下去，直到区间中只剩下一个节点为止
3. 线段树的叶子结点，代表了原序列中的单个位置的值
4. 如果采用完全二叉树的存储结构的话，最起码需要 $4n$ 的存储空间
5. 当面对区间修改的时候，基础版的线段树效率上还不如直接在一维序列上修改
6. 只适用于单点修改，区间查询







## 4.代码实现

![截屏2020-12-31 上午11.37.41](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8A%E5%8D%8811.37.41.png)







```cpp
#include <iostream>
#include <climits>
using namespace std;

//海贼OJ222

#define MAX_N 10000

struct {
    int max_num;//结点和值
    int l,r;
} tree[MAX_N << 2];
int arr[MAX_N + 5];

void update(int ind) {//更新结点的和值
    tree[ind].max_num = max(tree[ind << 1].max_num, tree[ind << 1 | 1].max_num);
    return ;
}

void build_tree(int ind, int l, int r) {//创建线段树,在tree[ind]上插入l，r
    tree[ind].l = l;
    tree[ind].r = r;
    if (l == r) {//l==r，l、r各代表一个值，不能再分裂
        tree[ind].max_num = arr[l];//将值挂在叶子结点上
        return ;
    }
    int mid = (l + r) >> 1;
    build_tree(ind * 2, l, mid);//递归左子树
    build_tree(ind * 2 + 1, mid + 1, r);//递归右子树
    update(ind);//更新和值
    return ;
}

void modify(int ind, int k, int val) {//修改tree[ind]上tree[k]的值为value,ind代表当前节点的编号
    if (tree[ind].l == tree[ind].r) {
        tree[ind].max_num = val;
        return ;
    }
    int mid = (tree[ind].l + tree[ind].r) >> 1;
    if (k <= mid ) {
        modify(ind << 1, k, val);
    } else {
        modify(ind << 1 | 1, k, val);
    }
    update(ind);
    return ;
}

int Query(int ind, int x, int y) {//查询[x,y]的和值
    if (tree[ind].l >= x && tree[ind].r <= y) {//要查找的值在这个根的
        return tree[ind].max_num;
    }
    int ans = INT_MIN;
    int mid = (tree[ind].l + tree[ind].r) >> 1;
    if (mid >= x) {//在左子树中查找
        ans = max(ans, Query(ind << 1, x, y));
    }
    if (mid < y) {//在右子树中查找
        ans = max(ans, Query(ind << 1 | 1, x, y));
    }
    return ans;
}



int main() {

    int m, n;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", arr + i);
    }
    build_tree(1, 1, n);
    int a, b, c;
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
        case 1: modify(1, b, c); break;
        case 2: {
                    if (b > c) {
                        cout << "-2147483648" << endl;
                        break;
                    }
                    cout << Query(1, b, c) << endl;
                } break;
        }
    }



    return 0;
}
```





==>总结

单点查询：log(n)

区间查询：log(n)

> 1.若采用完全能二叉树的存储方式，n个节点的线段树，最多需要多少个节点空间？
>
> $n + n - 1 + 2n = 4n -1$
>
> 2.如何做区间修改



![截屏2020-12-31 下午10.56.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.56.59.png)





![截屏2020-12-31 下午10.59.54](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.59.54.png)



其实节点上l，r可以省略



![截屏2020-12-31 下午11.01.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.01.08.png)







<!--more-->

```cpp
#include <iostream>
#include <climits>
using namespace std;

//海贼OJ222

#define MAX_N 10000

struct {
    int max_num;//子树的和值
} tree[MAX_N << 2];
int arr[MAX_N + 5];

void update(int ind) {//更新结点的和值
    tree[ind].max_num = max(tree[ind << 1].max_num, tree[ind << 1 | 1].max_num);
    return ;
}

void build_tree(int ind, int l, int r) {//创建线段树,在ind上插入l，r
    if (l == r) {//l==r，l、r各代表一个值，不能再分裂
        tree[ind].max_num = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build_tree(ind * 2, l, mid);
    build_tree(ind * 2 + 1, mid + 1, r);
    update(ind);
    return ;
}

void modify(int ind, int l, int r, int k, int val) {//在tree[ind](ind当前节点位置）维护的区间[l, r],上将tree[k]的值修改为val、
    if (l == r) {
        tree[ind].max_num = val;
        return ;
    }
    int mid = (l + r) >> 1;
    if (k <= mid ) {
        modify(ind << 1, l, mid, k, val);
    } else {
        modify(ind << 1 | 1, mid + 1, r, k, val);
    }
    update(ind);
    return ;
}

int Query(int ind, int l, int r, int x, int y) {//查询
    if (l >= x && r <= y) {//要查找的值在这个根的
        return tree[ind].max_num;
    }
    int ans = INT_MIN;
    int mid = (l + r) >> 1;
    if (mid >= x) {//在左子树中查找
        ans = max(ans, Query(ind << 1, l, mid, x, y));
    }
    if (mid < y) {//在右子树中查找
        ans = max(ans, Query(ind << 1 | 1, mid + 1, r, x, y));
    }
    return ans;
}



int main() {

    int m, n;
    scanf("%d%d", &n, &m);//n,数组长度，m,操作数
    for (int i = 1; i <= n; i++) {
        scanf("%d", arr + i);
    }
    build_tree(1, 1, n);//初始化线段树tree,根节点的范围是[1, n]
    int a, b, c;
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
        case 1: modify(1, 1, n, b, c); break;//在根节点[1, n]上修改tree[b]的值为c
        case 2: {
                    if (b > c) {
                        cout << "-2147483648" << endl;
                        break;
                    }
                    cout << Query(1, 1, n, b, c) << endl;//在根节点tree[1,n]上查找[b, c]区间上的和值
                } break;
        }
    }



    return 0;
}
```







## 5.线段树区间修改

明朝时期有一位官员，皇帝下放粮食，下发到县令手里，县令自己拿着粮食，不下发，突然有一天，皇帝要微服私访，此时县令下发粮食



### 1.Modify(0, 6, +3)

1)在区间[0, 6]的结点上加3，此时在懒标记上加3而不是在叶子结点上加3，县令自己拿了粮食不下发给百姓

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.02.12.png" alt="截屏2020-12-31 下午11.02.12" style="zoom: 67%;" />



2)叶子结点的值不变，但是区间根节点的值发生改变，农民没有拿到粮食，但是县令拿到了，县令上报农民已经拿到了粮食，向上更新区间和值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.05.35.png" alt="截屏2020-12-31 下午11.05.35" style="zoom: 67%;" />

### 2.Query(2,7)

1）查询[2,7]区间上的和值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.07.33.png" alt="截屏2020-12-31 下午11.07.33" style="zoom:67%;" />



2）开始递归向下查找

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.08.27.png" alt="截屏2020-12-31 下午11.08.27" style="zoom:67%;" />





3） `2 < 4`  = ( 9 / 2) 到左子树查找

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.27.png" alt="截屏2020-12-31 下午11.09.27" style="zoom:67%;" />



4)左子树中有懒标记，皇帝要来视察民情，县令下方粮食，懒标记下沉，

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.09.58.png" alt="截屏2020-12-31 下午11.09.58" style="zoom:67%;" />



5) 继续向下查询，

 `2 = 2`  = ( 4 / 2 )  向左子树递归

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.12.png" alt="截屏2020-12-31 下午11.10.12" style="zoom:67%;" />



6)左子树有懒标记，懒标记下沉

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.24.png" alt="截屏2020-12-31 下午11.10.24" style="zoom:67%;" />



7) `2 > 1` = 2 / 2 ,在右子树中查询，

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.38.png" alt="截屏2020-12-31 下午11.10.38" style="zoom:67%;" />



8）找到节点2,更新结点的值，返回节点2的值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.10.57.png" alt="截屏2020-12-31 下午11.10.57" style="zoom:67%;" />



9) 向上回溯，(4/2 + 1) = `3 > 2`，4 < 7  递归到右子树

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.10.png" alt="截屏2020-12-31 下午11.11.10" style="zoom:67%;" />



10) 结点的区间在待查找区间范围内，直接返回3-4结点的值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.22.png" alt="截屏2020-12-31 下午11.11.22" style="zoom:67%;" />



11） 向上回溯，(0 + 9) / 2  + 1= 5  < 7 递归到右结点5–-9

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.39.png" alt="截屏2020-12-31 下午11.11.39" style="zoom:67%;" />





12） (5 + 9) / 2 = 7 == 7,递归5–9左子树

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.11.51.png" alt="截屏2020-12-31 下午11.11.51" style="zoom:67%;" />

13) 找到结点 ，返回值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.06.png" alt="截屏2020-12-31 下午11.12.06" style="zoom:67%;" />



14) 向上回溯，返回区间和值

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8811.12.16.png" alt="截屏2020-12-31 下午11.12.16" style="zoom:67%;" />



 



## 6.进阶版线段树

1. 优化掉了代码实现中的：l，r。区间变量
2. 可以用于区间更新，区间查询
3. 增加了懒标记，达到能够区间更新的目的
4. 懒标记是需要向下下沉的
5. ==标记下沉发生在递归之前，向上更新发生在具有修改操作的递归之后==

 



## 7.代码实现



![截屏2020-12-31 下午10.48.39](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-31%20%E4%B8%8B%E5%8D%8810.48.39.png)



```cpp
#include <iostream>
using namespace std;

#define MAX_N 10000
typedef long long intl;
intl flag = 0;
struct {
    intl sum;//和值
    intl tag;//懒标记
} tree[MAX_N << 2];

intl arr[MAX_N + 5];

void update(intl ind) {//更新tee[ind]结点和值
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    //tree[ind].sum = tree[ind * 2].sum + tree[ind * 2 + 1].sum;
    return ;
}

void down(intl index, intl left, intl right) {//懒标记下沉
    if (tree[index].tag) {//如果存在懒标记值 > 0
        intl mid = (left + right) >>  1;
        intl value = tree[index].tag;
        tree[index << 1].sum += value * (mid - left + 1);//懒标记下沉左子树
        tree[index << 1].tag += value;
        tree[index << 1 | 1].sum += value * (right - mid);//right - (mid + 1)+1//懒标记下沉右子树
        tree[index << 1 | 1].tag += value;
        tree[index].tag = 0;
    }
    return ;
}

void build_tree(intl index, intl left, intl right) {
  //初始化线段树tree[index],线段树区间为[left, right],right = n,即有n个值要存在线段树中
    if (left == right) {//左右区间相等，即为叶子节点，存放值
        tree[index].sum = arr[left];
        return ;
    }
    intl mid = (left + right) >>  1;
    build_tree(index << 1, left, mid);//
    build_tree(index << 1 | 1, mid + 1, right);
    update(index);
    return ;
}
void modify(intl index, intl left, intl right, intl x, intl y, intl value) {
    flag && printf("modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n",
                       x, y, value, index, left, right, tree[index].sum
    );
    //从根节点tree[index]开始查询，根节点的区间是[left, right],找到区间[x, y],把[x, y]区间上的值加上value
    if (x <= left && right <= y) {//待操作区间在包含区间的范围内，即要修改的区间比根节点区间大
        tree[index].sum += value * (right - left + 1);
        tree[index].tag += value;//懒标记，皇帝给农民发放粮食，县令不放
        return ;
    }
    down(index, left, right);//懒标记下沉，皇帝要微服私访，县令下发粮食
    intl mid = (left + right) >>  1;
    if (mid >= x) {
        modify(index << 1, left, mid, x, y, value);
    }
    if (mid < y) {
        modify (index << 1 | 1, mid + 1, right, x, y, value);
    }
    update(index);
    return ;
}

intl Query(intl index, intl left, intl right, intl x, intl y) {
    if (x <= left && right <= y) {//要查询的区间[x, y]在[left, right]范围内
        return tree[index].sum;
    }
    down(index, left, right);
    intl mid = (left + right) >>  1;
    intl ans = 0;
    if (mid >= x) {
        ans += Query(index << 1, left, mid, x, y);
    }
    if (mid < y) {
        ans += Query(index << 1 | 1, mid + 1, right, x, y);
    }
    return ans;
}




int main() {
    intl n, m;
    scanf("%lld%lld", &n, &m);
    for (intl i = 1; i <= n; i++) {
        scanf("%lld", arr + i);
    }
    build_tree(1, 1, n);
    intl a, b, c, d;
    for (intl i = 0; i < m; i++) {
        scanf("%lld%lld%lld", &a, &b, &c);
        switch (a) {
        case 1: {
                    scanf("%lld", &d);
                    modify(1, 1, n, b, c, d);
                }break;
        case 2: {
                    if (b > c) {
                        printf( "0\n" );
                        break;
                    }
                    printf("%lld\n", Query(1, 1, n, b, c));//从根节点开始查询，根节点的范围是[1,n],查询[b,c]区间范围内的值
                }break;
        }
    }


    return 0;
}
```





# 2.从递推动归(上)

## 1.兔子繁殖问题

兔子繁殖问题：斐波那切数列

**题目：**如果1对兔子每月能生1对小兔子，而每对小兔在它出生后的第3个月就可以生1对小兔子，如果从1对初生的小兔子开始，1年后能繁殖多少兔子?





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.10.32.png" alt="截屏2021-01-01 下午8.10.32" style="zoom: 80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/IMG_20210101_194745.jpg" style="zoom:15%;" />





![截屏2021-01-01 下午8.12.49](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.12.49.png)



> 思考：当存在n = 40,程序会有什么问题？当n=60呢？



1. 程序运行效率问题(会出现重复计算的现象，如下图)

   解决方法：递归过程加记忆化(用数组记忆)  或  改成逆向递推求解(从f(1)求解到f(n),利用循环求解)

2. 程序计算结果超出整数范围，结果溢出出错

   解决方法：改成大整数求解



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.15.11.png" alt="截屏2021-01-01 下午8.15.11" style="zoom:67%;" />





## 2.如何求解递推问题



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%888.27.42.png" alt="截屏2021-01-01 下午8.27.42" style="zoom: 80%;" />



> 递推问题求解套路

1. 确定递推状态，一个数学符号 + 一个数学符号的语义解释
2. 确定递推公式，推导递推状态符号的自我表示方法
3. 程序实现，（递归+记忆化 / 循环实现）





### 确定递推状态

注意：这是学习递推问题的重中之重。学习确定递推状态的技巧。

$f(x) = y$

y：问题中的求解量，也是我们所谓的因变量

x：问题中直接影响求解量的部分，也是我们所谓的自变量

本质：就是寻找问题中的自变量与因变量



### 推导递推公式

本质：分析状态中的容斥关系(互相排斥)

$f(n)=f(n-1)+f(n-2)$

$f(n-1)$，代表 n-1个月的兔子数量，恰巧等于第 n 个月的成年兔子数量

$f(n-2)$，代表 n-2个月的兔子数量，恰巧等于第 n 个月的幼年兔子数量

所谓的推导，就是推导上面的这两句话的内容





## 3.爬楼梯问题



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g.jpg" alt="lALPDiQ3NHubpPPNB3LNCzg_2872_1906.png_720x720g" style="zoom:80%;" />



### 状态定义

$f(n)$ 代表爬 n 节楼梯的方法总数

### 递推公式

$f(n)=f(n - 2) + f(n - 3)$



==>用容斥原理对最后一种台阶的情况进行分类，展开讨论，分类后求和(站在最后面往前看)



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.03.04.png" alt="截屏2021-01-01 下午11.03.04" style="zoom:67%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-01%20%E4%B8%8B%E5%8D%8811.00.14.png" alt="截屏2021-01-01 下午11.00.14" style="zoom:67%;" />





## 4.凑钱币问题



![lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDgfLP1Vs-lrNCBrNC5Q_2964_2074.png_720x720g.jpg)



### 状态定义

$f(n, m)$ 代表用前 n 种钱币，拼凑 m 元钱的方案总数

### 递推公式

$f(n, m) = f(n - 1, m) + f(n, m - val[n])*1$

没有使用n种钱币的方法+使用n种钱币的方法（拼凑m元钱的方案中减去最后一种钱币金额，确保最后一种金额只能为第n中钱币，即val[n]）

==>递推技巧：用容斥原理对最后一种钱币讨论：（使用了第n种钱币/没有使用第n种钱币）拼凑了m元钱 



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhYBOei5ckPNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />





## 5.墙壁涂色



![lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lALPDhYBOeiGuN3NB-7NC1w_2908_2030.png_720x720g-1.jpg)



### 方法1

技巧：先按照非环情况做，保证所有方案之间，相邻墙壁颜色不同，最后再保证首尾颜色不同

#### 状态定义

$f(n, i, j)$ 代表 n 块墙壁，第一块涂颜色 i，最后一块涂颜色 j 的方案总数

#### 递推公式

$f(n, i, j) = \sum_{k}{f(n-1,i,k)}\ |\ k \ne j$



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDhJzu0Qm8ZvNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />

---



### 方法2

基于第一种做法，优化状态定义，忽略第一块的颜色

$f(n, 2, 3) == f(n, 1 , 3)$,即可以忽略i这个变量，变成隐藏的变量

#### 状态定义

$f(n, j)$ 代表 n 块墙壁，第一块涂颜色 0，最后一块涂颜色 j 的方案总数，总方案数：$f(n,j)*3$

#### 递推公式

$f(n, j) = \sum_{k}{f(n-1,k)}\ |\ k \ne j$

==>$(f(n,1) + f(n,2))*3 = f(n,1) * 6$

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDgfLP1XmGrbNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />









---



### 方法3

单刀直入，直接定义状态，求什么定义什么

#### 状态定义

$f(n)$ 代表 n 块墙壁，首尾颜色不同的方法总数

#### 递推公式

$f(n) = f(n-1) + 2 \times f(n-2)$



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g.jpg" alt="lADPDg7mPJ-KA9LNA3_NBQA_1280_895.jpg_720x720g" style="zoom:80%;" />



1，3不同的方案总数，1，3不同，4颜色一定，3属于正常状态，所以1，3不同的方案总数为$1 \times f(n-1) = f(n-1)$

1和3颜色不同的方法，1，3颜色不同  ==>1,2相同颜色，即1，3颜色不同的方案总数等于1，2相同颜色的方案总数；1，2不同的方案总数为$f(n-2)$,由于4有两种方案，计算总方案数时需要乘以2

总方案数$f(n)=1\times f(n-1)+2\times f(n-2)$



## 4.代码演示



![截屏2021-01-04 上午10.34.06](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8A%E5%8D%8810.34.06.png)



$f(n)=f(n-1)\times (k-2) + (k-1) \times f(n-2)$

(1,3不同+1,3相同)

```cpp
#include <iostream>
#include <vector>

using namespace std;
//定义一个大整型数据结构
class BigInt : public vector<int> {
public :
    BigInt() {
        push_back(0);
    }
    BigInt(int x) {
        push_back(x);
        process_digit();
    }
    BigInt operator*(int x) {
        BigInt ret(*this);
        ret *= x;
        return ret;
    }
    void operator*=(int x) {
        for (int i = 0; i < size(); i++) at(i) *= x;
        process_digit();
        return ;
    }
    void operator+=(const BigInt &num) {
         for (int i = 0; i < num.size(); i++) {
            if (i == size()) push_back(num[i]);
            else at(i) += num[i];
         }
        process_digit();
        return ;
    }

    BigInt operator+(const BigInt &num) {
        BigInt ret(*this);
        ret += num;
        return ret;
    }

    void process_digit() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};



ostream &operator<<(ostream &out, const BigInt &num) {
    for (int i = num.size() - 1; i >= 0; --i) {
        out << num[i];
    }
    return out;
}

int main() {
    int n, k;//n块墙壁k种颜色
    cin >> n >> k;
    BigInt f[3] = {0};
    f[1] = k;//有一块墙壁，，k种颜色，k>=1
    f[2] = k * (k - 1);//有两块墙壁，k种颜色,k>=2
    f[0] = k * (k - 1) * (k - 2);//有三块墙壁,k>=3

    for (int i = 4; i <= n; i++) {
        f[i % 3] = f[(i - 1) % 3] * (k - 2) + f[(i - 2) % 3] * (k - 1);
    }

    cout << f[n % 3] << endl;
    return 0;
}
```



# 3.从递推到动归(下)

> 2021.1.4



## 1.数字三角形



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.26.png" alt="截屏2021-01-04 下午12.32.26" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.32.59.png" alt="截屏2021-01-04 下午12.32.59" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%8812.45.491.png" alt="截屏2021-01-04 下午12.45.491" style="zoom:80%;" />





<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/0012.png" alt="0012" style="zoom:80%;" />





### 惊人的发现

$f(i, j)$ 代表从底边走到 i, j 点的最大值

$f(i, j)$ 代表从顶点走到 i, j 点的最大值

1. 数学符号完全一致
2. 语义信息不同
3. 递归公式不同
4. 结论：数学符号无法完全代表状态定义



### 两种方法的对比

本质：两种状态定义方式的对比

1. 第一种：不用做边界判断，最终结果，直接存储在 $f[0][0]$
2. 第二种：需要做边界判断，最终结果，存储在一组数据中
3. 结论：第一种要比第二种优秀



## 2.数学归纳法

用数学归纳法验证动态规划是否是正确的

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.41.45.png" alt="截屏2021-01-04 下午3.41.45" style="zoom:90%;" />





## 3.动态规划问题的求解套路

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%883.49.09.png" alt="截屏2021-01-04 下午3.49.09" style="zoom:80%;" />

1. 第一步：确定动归状态
2. 第二步：推导状态转移方程，理解：转移、决策
3. 第三步：正确性证明，利用数学归纳法
4. 第四步：程序实现
5. 所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。



## 4.递推问题求解方向



1.我从哪里来：一般用for循环求解

例如：数字三角形、兔子繁殖问题、钱币问题、墙壁涂色...

2.我到哪里去：递归

例如：杂务(P1113)、神经网络(P1038)、旅行计划(P1137)…(P洛谷)



### 补充:拓扑序

图形结构是最最抽象的数据结构，必须理解成思维逻辑结构

1. 拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一
2. 拓扑序的本质作用：是把图形结构上变成一个一维序列
3. 图形结构不能用循环遍历的，一维序列可以
4. 所有递推问题中的状态更新过程，本质上满足拓扑序



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.08.png" alt="截屏2021-01-04 下午4.28.08" style="zoom:80%;" />



<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.28.17.png" alt="截屏2021-01-04 下午4.28.17" style="zoom:80%;" />

## 5.例题1：最长上升子序列

![截屏2021-01-04 下午4.34.45](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.34.45.png)

![截屏2021-01-04 下午4.41.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-04%20%E4%B8%8B%E5%8D%884.41.03.png)



### 状态定义

$f(i)$ 代表以为 i 为结尾的，最长上升子序列的长度

### 状态转移方程

$f(i) = max\left\{f(j)\right\} + 1 | j < i, val[j] < val[i] $

状态转移的时间复杂度：$O(n^2)$



后续重点：优化转移过程

### 代码演示

```cpp
#include <iostream>
#define MAX_N 1000000
using namespace std;

int arr[MAX_N + 5];//子序列
int dp[MAX_N + 5];//记录上升子序列最长长度

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", arr + i);
    }
    int ans = 0;//记录最长长度
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++) {//在子序列中寻扎比他小的值
            if (arr[j] >= arr[i]) continue;
            dp[i] = max(dp[i], dp[j] + 1);
            cout << arr[j] << " ";
        }
        ans = max(ans, dp[i]);
        //cout << "ans = " << ans << endl;
    }
    cout << ans << endl;
    return 0;
}

```

 

[5.3.最长上升子序列优化](#5.3.最长上升子序列优化)







## 6.例题2:最长公共子序列

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.24.57.png" alt="截屏2021-01-05 上午9.24.57" style="zoom:80%;" />

<img src="https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8A%E5%8D%889.27.11.png" alt="截屏2021-01-05 上午9.27.11" style="zoom:80%;" />

### 状态定义

$f(i,j)$ 代表第一个字符串取前 i 位，第二个字符串取前 j 位的，最长公共子序列的长度

### 状态转移方程

$f(i,j) = \left\{\begin{aligned} & max[f(i - 1, j), f(i, j - 1)] &val(i) \neq val(j)\\ & f(i - 1, j - 1) &val(i) = val(j)\end{aligned} \right.$

状态转移的时间复杂度：$O(n \times m)$



学习的重点：注意到，参与决策的状态数量，是会根据条件不同而改变的



### 代码演示



```cpp
#include <iostream>
using namespace std;
#define MAX_N 1000
string s1, s2;
int dp[MAX_N + 5][MAX_N + 5] = {0};

int main() {
    cin >> s1 >> s2;
    for (int i = 1; i <= s1.size(); i++) {
        for (int j = 1; j <= s2.size(); j++) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
            }
        }
    }
    cout << dp[s1.size()][s2.size()] << endl;
    return 0;
}
```





## 7.课后作业题

1. **[HZOJ46-切割回文](http://oj.haizeix.com/problem/46)**
2. **[HZOJ47-0/1背包](http://oj.haizeix.com/problem/47)**
3. **[HZOJ48-完全背包](http://oj.haizeix.com/problem/48)**
4. **[HZOJ49-多重背包](http://oj.haizeix.com/problem/49)**



# 4.动归习题

## 1.切割回文

![截屏2021-01-09 下午2.43.31](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-09%20%E4%B8%8B%E5%8D%882.43.31.png)



**状态定义**

$dp[i]$ 代表取字符串的前 $i$ 位，最少分成多少段回文串

**状态转移**

$dp[i] = min(dp[j]) + 1\ |\ s[j + 1, i]\ is\ palindrome$



1. 根据状态转移，算法时间复杂度$O(n^2)$
2. 所以，我们需要对转移阶段进行优化
3. 动态规划优化章节的时候，重点解决





## 2.切割回文代码实现



```cpp
#include <iostream>
#define MAX_N 500000

using namespace std;
int dp[MAX_N + 5];//dp[i] 代表取字符串的前i位，最少分成多少段回文串

bool is_palindrome(string &s, int i, int j) {//判断i~j是否是回文字符串
    while(i < j) {
        if (s[i] - s[j]) return false;//s[i] != s[j]
        i++,j--;
    }
    return true;
}

int main() {
    string s;
    cin >> s;
    dp[0] = 0;
    for (int i = 1; i <= s.size(); i++) {
        dp[i] = dp[i - 1] + 1;
        for (int j = 0; j < i; j++) {
            if (is_palindrome(s, j, i - 1))//是回文串
                dp[i] = min(dp[i], dp[j] + 1);
        }
    }
    cout << dp[s.size()] - 1 << endl;



    return 0;
}

```

[5.4切割回文](#5.4切割回文)

## 3.HZOJ47-0/1背包

![截屏2021-01-13 上午11.09.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8A%E5%8D%8811.09.46.png)



**状态定义**

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值



**状态转移**

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$

𝑉𝑖,𝑊𝑖,分别代表第i件物品的重量𝑉𝑖和价值𝑊𝑖。

1. 第一种程序实现，状态如何定义的，程序就如何实现
2. 第二种程序实现，使用滚动数组，对代码进行了空间优化
3. 第三种程序实现，将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序



## 4.0/1背包代码演示

### 1.方法一

```cpp
#include <iostream>
using namespace std;
#define MAX_N 100
#define MAX_V 10000

int v[MAX_N + 5], w[MAX_N + 5];
int dp[MAX_N + 5][MAX_V + 5];

int main() {
    int V, n;
    cin >> V >> n;//背包的最大承重v和物品数n
    for (int i = 1; i <= n; i++) 
      cin >> v[i] >> w[i];
  		//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= V; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= v[i]) 
              dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);
            //前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值
        }
    }
    cout << dp[n][V] << endl;
    return 0;
}
```



### 2.利用滚动数组进行优化

减少存储空间

```cpp
#include <iostream>
using namespace std;
#define MAX_N 100
#define MAX_V 10000

int v[MAX_N + 5], w[MAX_N + 5];
int dp[2][MAX_V + 5];

int main() {
    int V, n;
    cin >> V >> n;//背包的最大承重v和物品数n
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];//物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= V; j++) {
            dp[i % 2][j] = dp[(i - 1) % 2][j];
            //此处只访问了dp[i]和dp[i-1]两行，可以利用滚动数组进行优化
            if (j >= v[i]) dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j - v[i]] + w[i]);
            //dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
            //前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值
        }
    }
    cout << dp[n % 2][V] << endl;
    return 0;
}
```



### 3.优化

将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序

```cpp
#include <iostream>
using namespace std;
#define MAX_N 100
#define MAX_V 10000

int dp[MAX_V + 5];

int main() {
    int V, n; //背包的最大承重V和物品数n。
    int v, w; //物品的重量v和价值w
    cin >> V >> n; 
    //for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    //物品从第一件开始,输入第i件物品的重量v[i]和价值w[i]
    for (int i = 1; i <= n; i++) {
        cin >> v >> w;
        for (int j = V; j >= v; j--) {
          //dp[j] = dp[j];
            //if (j >= v) dp[j] = max(dp[j], dp[j - v] + w);
            //前 i 个物品，背包最大承重为 j 的情况下，得到物品的最大价值
          dp[j] = max(dp[j], dp[j - v] + w);
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

理解：

1.j为什么逆序

==>需要理解为什么是一维的

dp数组经过$dp[j] = max(dp[j], dp[j - v] + w)$后变成了$dp[i][j]$的含义,之前是$dp[i - 1][j]$的含义

$dp[j]$更新需要$dp[j]$和$dp[j - v]$的值(相对于二维数组来说，此处需要$dp[i - 1][j]$和$dp[i - 1][j - v]$的值，即上一行的数据)，如果从前面开始更新数据，后面需要的数组会被新一层的数据覆盖,所以需要从后面开始更新

2.为什么不需要v、w数组

读入一件商品，处理一件商品

3.dp数组为什么第一维没了

dp数组的含义没有变,只是在代码实现中变成了一维的





## 5.海贼 OJ-48-完全背包



![截屏2021-01-13 下午2.38.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%882.38.25.png)







**状态定义**

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值

**状态转移**

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i][j-v[i]]+w[i] &选了若干个第 i 件\end{aligned}\right.$$



(0/1背包)$dp[i-1][j-v[i]]+w[i] 选了第 i 件$

程序实现的时候，参考01背包的程序实现，将逆向刷表，改成正向刷表



## 6.完全背包代码演示



```cpp
#include <iostream>
using namespace std;
#define MAX_N 10000
int dp[MAX_N + 5];

int main() {
    int V, n, w, v;
    //第一行为两个整数𝑁、𝑉(1≤𝑁,𝑉≤10000)，分别代表题目描述中的物品种类数量N和背包容量V。
    cin >> n >> V;
    for (int i = 0; i < n; i++) {
        cin >> v >> w;//c = v,v = w
        //第 𝑖 行两个整数𝐶𝑖、𝑉𝑖，分别代表每种物品的体积和价值。
        for (int j = v; j <= V; j++) {
            dp[j] = max(dp[j], dp[j - v] + w);
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

此处我们需要正向刷表，因为我们需要$dp[j - v[i]]$能够代表$dp[i][j - v[i]]$的值

$dp[i][j-v[i]]+w[i] 选了若干个第 i 件$此处需要的第$i$行的$dp[j-v[i]]$而不是需要第$i - 1$行的$dp[j-v[i]]$





## 7.海贼 OJ-49-多重背包



![截屏2021-01-13 下午3.17.52](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.17.52.png)





**问题模型转换**

1. 多重背包，每类物品多了一个数量限制
2. 01背包，每种物品只有一个
3. 将多重背包中的数量限制，当做多个单一物品来处理
4. 至此就将多重背包，转成了0/1背包问题

**状态定义**

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值

**状态转移**

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$



## 8.多重背包代码演示



```cpp
#include <iostream>
using namespace std;
#define MAX_N 100000
int dp[MAX_N];
int main() {

    int V, n, v, w, s;
    //第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。
    cin >> V >> n;
    for (int i = 0; i < n; i++) {
        //𝑉𝑖、𝑊𝑖、𝑆𝑖，分别代表第 𝑖 种物品的重量、价值和数量。
        cin >> v >> w >> s;
        for (int k = 0; k < s; k++) {
          //对数量分类，对每一种情况进行讨论
            for (int j = V; j >= v; j--) {
                dp[j] = max(dp[j], dp[j - v] + w);
            }
        }
    }
    cout << dp[V] << endl;


    return 0;
}

```



[5.2.多重背包的优化](#5.2.多重背包的优化)













## 9.海贼 OJ-50-扔鸡蛋

![截屏2021-01-13 下午3.56.18](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%883.56.18.png)





**状态定义**

$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次





**状态转移**

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$

楼层数k，最少min,最坏max,对于每一个枚举的k值中选一个值最小的方案，对于每一个确定的k值，都有两种解决方式，在这两种解决方式中取一个最大值

1. 程序所使用的存储空间与楼层数量强相关
2. 楼层数量达到了 $2^{31}$，所以在这种状态定一下不可行
3. 状态定义不可行，我们就需要优化状态定义
4. 时间复杂度 $O(n \times m^2)$，当 m 过大的时候，无法通过时间限制





## 10.扔鸡蛋代码演示



```cpp
#include <iostream>
using namespace std;

#define MAX_N 32
#define MAX_M 100000
int dp[MAX_N + 5][MAX_M + 5];
//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次

int main() {
    int n, m;
    cin >> n >> m;
    //输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚<231），代表 𝑛 个鸡蛋和 𝑚 层楼。
    for (int i = 0; i <= m; i++) dp[1][i] = i;
  	//一个鸡蛋测i层楼,有i种方法
    for (int i = 2; i <= n; i++) {//从两个鸡蛋开始
        for (int j = 1; j <= m; j++) {//楼层
            dp[i][j] = j;
            for (int k = 1; k <= j; k++) {//
                dp[i][j] = min(dp[i][j], max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
            }
        }
    }
    cout << dp[n][m] << endl;

    return 0;
}
```

30分，

时间复杂度$O(n \times m^2)$

[扔鸡蛋问题优化](##5.1.扔鸡蛋问题的优化)



# 5. 动态规划优化的分类

1. 状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程
2. 程序实现的优化，例如：01背包问题。状态定义没有变、转移过程也没变。
3. 状态定义的优化，大量训练，才能培养出来的能力，从源头进行优化
4. 状态定义->源头，转移过程->过程，程序实现->结果



程序优化：01背包，钱币问题，滚动数组



## 5.1.扔鸡蛋问题的优化



### **转移过程优化**

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$

$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测$dp[n][m]$次

通过观察 k 与 $dp[n-1][k-1]$与 $dp[n][m-k]$之间的关系，最优的转移 k 值，一定发生在两个函数的交点处

k增加，$dp[n-1][k-1]$增加，$dp[n][m-k]$减小(如果不理解，可以假如用1(n-1=1)个鸡蛋，测m(k - 1 = m)层楼有m种方法理解)

交叉点出的值满足：$dp[n-1][k-1] \le dp[n][m-k]$

![截屏2021-01-13 下午8.39.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.39.00.png)



m1<m2  ==> k1<=k2



![截屏2021-01-13 下午8.42.19](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.42.19.png)







![截屏2021-01-13 下午8.48.59](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-13%20%E4%B8%8B%E5%8D%888.48.59.png)



优化掉 min 以后，总体时间复杂度变成了 $O(n \times m)$



```cpp
#include <iostream>
using namespace std;

#define MAX_N 32
#define MAX_M 100000
int dp[MAX_N + 5][MAX_M + 5];
//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次

int main() {
    int n, m;
    cin >> n >> m;
    //输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚<231），代表 𝑛 个鸡蛋和 𝑚 层楼。
    for (int i = 0; i <= m; i++) dp[1][i] = i;//一个鸡蛋测i层楼,有i种方法
    for (int i = 2; i <= n; i++) {//从两个鸡蛋开始
        dp[i][1] = 1;
        int k = 2;
        for (int j = 2; j <= m; j++) {//楼层

            //1.
            //while(k < j && dp[i - 1][k - 1] < dp[i][j - k]) ++k;
            //dp[i][j] = max(dp[i - 1][k -1], dp[i][j - k]) + 1;
            //2.
            if(k < j && dp[i - 1][k - 1] < dp[i][j - k]) ++k;
            dp[i][j] = max(dp[i - 1][k -1], dp[i][j - k]) + 1;
           // while(dp[i - 1][k - 1 + 1] <= dp[i][j - k + 1]) ++k;
             //   dp[i][j] = dp[i][j - k] + 1;

        }
    }
    cout << dp[n][m] << endl;

    return 0;
}
```

60





### **状态定义的优化**

1. 原状态定义所需存储空间与 m 相关，m 值域大，所以存不下
2. 当发现某个自变量与因变量之间存在相关性的时候，两者即可对调
3. $dp[n][m]=k$ 重定义为$dp[n][k]=m$，代表 n 个鸡蛋扔 k 次，最多测多少层楼
4. k 的值域小，当 n=2 时，$k \le \sqrt{2m}$ 

![截屏2021-01-14 上午5.57.48](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.57.48.png)



![截屏2021-01-14 上午5.58.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%885.58.43.png)



**状态转移方程：**$dp[n][k] = dp[n-1][k-1]+dp[n][k-1] + 1$

本质上已经不是一个动态规划题目了，实际上变成了一个递推问题



```cpp
#include <iostream>
using namespace std;

#define MAX_N 32
#define MAX_K 100000
long long dp[MAX_N + 5][MAX_K + 5];
//dp[n][k]代表 n 个鸡蛋扔 k 次，最多测多少层楼

int solve(int n,int m) {
    if (n == 1) return m;
    for (int i = 1; i <= MAX_K; i++) dp[1][i] = i;//1个鸡蛋测i层楼有i种方法
    for (int i = 2; i <= n; i++) {
        for (int k = 1; k <= MAX_K; k++) {
            dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1;
        }
    }
    int k = 1;
    while(dp[n][k] < m) k++;//n个鸡蛋扔k次不足以测m层楼的时候增加k

    return k;
}


int main() {
    int n, m;
    cin >> n >> m;
    //输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚<231），代表 𝑛 个鸡蛋和 𝑚 层楼。
    cout << solve(n, m) << endl;
    return 0;
}

```

100





动态数组优化存储空间

```cpp
#include <iostream>
using namespace std;

#define MAX_N 32
#define MAX_K 100000
long long dp[2][MAX_K + 5];
//dp[n][m]用n个鸡蛋，测 m 层楼，最坏情况下最少测dp[n][m]次

int solve(int n,int m) {
    if (n == 1) return m;
    for (int i = 1; i <= MAX_K; i++) dp[1][i] = i;//1个鸡蛋测i层楼有i种方法
    for (int i = 2; i <= n; i++) {
        for (int k = 1; k <= MAX_K; k++) {
            dp[i % 2][k] = dp[(i - 1) % 2][k - 1] + dp[i % 2][k - 1] + 1;
        }
    }
    int k = 1;
    while(dp[n % 2][k] < m) k++;//n个鸡蛋扔k次不足以测m层楼的时候增加k

    return k;
}


int main() {
    int n, m;
    cin >> n >> m;
    //输入两个数字 𝑛,𝑚（1≤𝑛≤32,1≤𝑚<231），代表 𝑛 个鸡蛋和 𝑚 层楼。
    cout << solve(n, m) << endl;
    return 0;
}
```







## 5.2.多重背包的优化

[7.海贼 OJ-49-多重背包](#7.海贼 OJ-49-多重背包)

### 二进制拆分法

1. 本质上，对于某一类物品，我们具体要选择多少件，才是最优答案
2. 普通的单一拆分法，实际上只是想枚举某个物品选择 1--s 件的所有情况
3. 二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少
4. 拿14举例，普通拆分法 14 份，二进制拆分法 4 份物品(1 2 4 7)



**时间复杂度：**$O(nm\sum_{i=1}^{i=n}{logs_i})$

**最优时间复杂度：**$O(nm)$，借助单调队列，后续再讲

**01背包时间复杂度：**$O(nm)$

**完全背包时间复杂度：**$O(nm)$



![截屏2021-01-14 上午7.25.53](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8A%E5%8D%887.25.53.png)



### 代码演示



```cpp
#include <iostream>
using namespace std;
#define MAX_N 100000
int dp[MAX_N];
int main() {

    int V, n, v, w, s;
    //第一行输入两个数𝑉、𝑛，分别代表背包的最大承重和物品种类数。
    cin >> V >> n;
    for (int i = 0; i < n; i++) {
        //v、w、s代表物品的重量、价值和数量。
        cin >> v >> w >> s;
        for (int k = 1; s; k *= 2) {//当前一共有多少物品
            if (k > s) k = s;
            s -= k;//减去物品加上的数量
            for (int j = V; j >= k * v; j--) {//当前这一堆的总重量为k * v
                dp[j] = max(dp[j], dp[j - k * v] + k * w);
            }
        }
    }
    cout << dp[V] << endl;


    return 0;
}
```



## 5.3.最长上升子序列优化

[5.例题1：最长上升子序列](#5.例题1：最长上升子序列)

### 状态定义

$dp[i]$，代表以 i 位做为结尾的最长上升子序列的长度



### 状态转移

$dp[i] = max(dp[j]) + 1 | val_j < val_i$



### 优化方式

1. 维护一个单调数组 len，len[i] 代表长度为 i 的序列，结尾最小值
2. $dp[i]$ 在转移的时候，在 len 数组中查找第一个 $len[k]>=val_i$ 的位置，$dp[i] = k$
3. 更新 $len[k] = val_i$
4. 需要明确，len 数组为什么是单调的
5. 证明过程：假设，更新前是单调的，更新以后，一定是单调的
6. 在 len 数组中查找位置 k，实际上就是二分算法搞定



**时间复杂度：**$O(nlogl)$



![截屏2021-01-14 下午3.06.40](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png)

![截屏2021-01-14 下午3.06.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-14%20%E4%B8%8B%E5%8D%883.06.40.png)





### 代码演示

```cpp
#include <iostream>
#include <cstring>
#define MAX_N 1000000
using namespace std;

int len[MAX_N + 5];//长度为i的序列的最小值
int dp[MAX_N + 5];

int binary_search(int *arr, int n, int x) {//二分查找
    //在arr数组中查找第一个大于等于x的值
    int head = 0, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (arr[mid] < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

int main() {

    int n, val;
    int ans = 0;
    scanf("%d", &n);
    memset(len, 0x3f, sizeof(len));//极大值
    len[0] = 0;//极小值，0的位置为极小值，其他位置为极大值
   // for (int i = 0; i < n; i++) scanf("%d", val[i]);
    for (int i = 1; i <= n; i++) {
        cin >> val;
        dp[i] = binary_search(len, ans + 1,val);//找到第一个>=val[i]的值
        len[dp[i]] = val;
        ans = max(dp[i], ans);//最后一位有记录的下标
    }

    cout << ans << endl;

    return 0;
}
```



## 5.4切割回文

[4.1.切割回文](#1.切割回文)

提前处理得到 mark 数组，$mark[i]$ 存储的是所有以 i 位置做为结尾的回文串的起始坐标，在转移过程中，利用 mark 数组，就可以避免掉大量的无用循环遍历过程。



**时间复杂度：**$O(n+m)$，m 是字符串中回文串的数量



```cpp
#include <iostream>
#include <vector>
#include <cstring>
#define MAX_N 500000

using namespace std;
int dp[MAX_N + 5];//取字符串的前i位，最少分成多少段回文串
vector<int> mark[MAX_N + 5];
//以 i 位置做为结尾的回文串的起始坐标

int expand(string &s, int i, int j) {//回文字符串
    while (s[i] == s[j]) {
        mark[j + 1].push_back(i + 1);
      //以j+1为结尾的回文串的起始坐标i+1 
        --i, ++j;
        if (i < 0 || j >= s.size()) break;
    }
    return 1;
}


int main() {
    string s;
    cin >> s;//一个长度为n(1≤𝑛≤500000)的字符串S，只包含小写字母。
    dp[0] = 0;
    for (int i = 0; s[i]; i++) {//提前处理得到 mark 数组
        expand(s, i, i);//处理奇数类型字符串
        (i + 1 < s.size()) && expand(s, i, i + 1);
      	//处理偶数类型的字符串
    }
    for (int i = 1; i <= s.size(); i++) {
        dp[i] = i;//初始化dp[i],取字符串的前i位，最少分成多少段回文串
        for (int j = 0; j < mark[i].size(); j++) {
            dp[i] = min(dp[i], dp[mark[i][j] - 1] + 1);
        }
    }
    cout << dp[s.size()] - 1 << endl;//分多少段-1==>切多少刀



    return 0;
}
```







# 6.树状数组

2021.1.17 20:00

## 6.1前缀和与差分

### 原数组、前缀和、差分数组

1. 原数组：${a_1, a_2,a_3,....,a_n}$

2. 前缀和：$S_i=\sum_{k=1}^{k=i}{a_i}$，$a_i=S_i-S_{i-1}$

3. 差分数组：$X_i=a_i-a_{i-1}$

   $X_1 + X_2 + X_3 = (a_1 - a_0) + (a_2 - a_1) + (a_3 - a_2) = a_3 $

4. X 数组是 a 数组的差分数组，a 数组是 S 数组的差分数组

5. S 数组是 a 数组的前缀和数组，a 数组是 X 数组的前缀和数组

6. 前缀和数组以及差分数组，并没有增加信息，只是信息的另外一种表示形式

7. 前缀和数组用来优化==区间和==操作

8. 差分数组用来优化==区间修改==操作



### 问题1：原数组区间和操作

a 数组上的操作：$O(n)$

S 数组上的操作：$O(1)，S_i - S_{j-1}=a[j,i]区间和$



### 问题2：原数组区间元素修改（加法）

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



a 数组时间复杂度：$O(n)$

X 数组时间复杂度：$O(1)$



![截屏2021-01-17 下午8.51.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.51.02.png)

## 6.2树状数组

![截屏2021-01-17 下午8.54.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%888.54.51.png)



1. lowbit 函数求数字 i，二进制表示中的最低1所在的位权

2. lowbit(x) = x & -x

   正数=原码，负数=补码=正数的反码+1，

3. 树状数组本质上是对前缀和数组的一种优化，主要体现在单点修改操作上

4. 前缀和查询 $O(logn)$，单点修改$O(logn)$

5. 相比于最普通的前缀和数组，查询方面变差，单点修改操作变好，综合时间复杂度变好

6. 查询的时候，向前统计，$i$ 的前一位 $i-lowbit(i)$

7. 修改的时候，向后修改，$i$ 的后一位 $i + lowbit(i)$

![截屏2021-01-17 下午9.04.29](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.04.29.png)

![截屏2021-01-17 下午9.10.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.13.png)

![截屏2021-01-17 下午9.10.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.10.55.png)

![截屏2021-01-17 下午9.16.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.16.13.png)

![截屏2021-01-17 下午9.17.02](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.17.02.png)

![截屏2021-01-17 下午9.37.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.37.27.png)





### 代码实现

方便区间修改版

```cpp
#define MAX_N 100000
int c[MAX_N + 5];//维护的是原数组的差分数组
#define lowbit(x) (x & (-x))

void add(int i, int x, int n) {//单点修改
    //在c[n]中的c[i]加x
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

int query(int i) {//前缀和
    int sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;//原数组前n项和为第i项的值
}
```



## 6.3海贼 OJ-329-弱化的整数问题

![截屏2021-01-17 下午9.43.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.34.png)

![截屏2021-01-17 下午9.43.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%889.43.50.png)





**引入差分数组**

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



引入差分数组 X，将原数组 a 上的区间加操作，转换成 X 数组上的两次【单点操作】

对于查询原数组 a[i] 的值，等价于查询 X 数组前 i 位的【前缀和】





**结论**

由于，既要维护【前缀和】，又要进行【单点修改】，所以可以使用树状数组



```cpp
#include <iostream>
using namespace std;
#define MAX_N 100000
int c[MAX_N + 5];//维护的是原数组的差分数组
#define lowbit(x) (x & (-x))

void add(int i, int x, int n) {//单点修改
    //在c[n]中的c[i]加x
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

int query(int i) {//前缀和
    int sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;//原数组前n项和为第i项的值
}

int main() {
    int n, m, pre, a;
    cin >> n;//第一行一个整数𝑁,代表序列𝐴的长度
    //第二行是由空格分隔开的𝑁个数，分别代表𝐴1，𝐴2……𝐴𝑛
    pre = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a;//a代表当前输入的值
        add(i, a - pre, n);//pre代表上一个输出的值
        pre = a;
    }
    cin >> m;//接下来一行是一个整数𝑚，代表操作的次数。
    char str[10];
    //接下来𝑚行，每行代表这一条指令如题目所述
    int l, r, d, x;
    for (int i = 0; i < m; i++) {
        cin >> str;
        switch (str[0]) {
        case 'C': {
                      // 第一类指令形如𝐶 𝑙 𝑟 𝑑(1≤𝑙≤𝑟≤𝑁)，表示把数列中第𝑙...𝑟之间的数都加𝑑(0≤𝑑≤100000)
                      cin >> l >> r >> d;
                      add(l, d, n);
                      add(r + 1, -d, n);
                  } break;
        case 'Q': {
                      cin >> x;//第二类指令形如𝑄 𝑥(𝑥≤𝑁)，表示询问序列中第𝑥个数的值。
                      cout << query(x) << endl;
                } break;
        }
    }

    return 0;
}
```



## 6.4 海贼 OJ-330-加强的整数问题

![截屏2021-01-17 下午10.29.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.29.57.png)

![截屏2021-01-17 下午10.30.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.30.10.png)



**引入差分数组**

参考 HZOJ-329 的解法，主要为了维护原数组上的区间修改操作





**原数组上的区间和问题转化**

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$

$Query(l, r) = S(r) - S(l - 1)$，重点分析 S 怎么求，会求 S，万事大吉

$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k*X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k*X_k}$

设$Y_i = i \times X_i$

$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$



![截屏2021-01-17 下午10.27.25](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-17%20%E4%B8%8B%E5%8D%8810.27.25.png)



**结论**

$S_i$ 可以通过维护 X 与 Y 两个序列的前缀和得到

所以可以通过维护两个与差分数组 X 相关的前缀和数组，从而得到原数组 a 的前缀和值

需要维护两个：树状数组



**代码实现**

```cpp
#include <iostream>
using namespace std;
#define MAX_N 100000
#define lowbit(x) (x & -x)
long long c[2][MAX_N + 5];//差分数组

void add(long long k, long long i, long long x, long long n) {
    //在c[k][i]的位置加x
    while (i <= n) {
        c[k][i] += x;
        i += lowbit(i);
    }
    return ;
}

long long query(long long k, long long i) {
    //查询c[k][i]的前缀和
    long long sum = 0;
    while (i) {
        sum += c[k][i];
        i -= lowbit(i);
    }
    return sum;
}

long long S(long long i) {//S[i]前i项和
    return (i + 1) * query(0, i) - query(1, i);
}

void modify(long long i, long long x, long long n) {//在c[][i]位置上加上x
    add(0, i, x, n);
    add(1, i, i * x, n);
    return ;
}

int main() {
    long long m, n;
    //第一行包含两个整数𝑁,𝑀(1≤𝑁,𝑀≤100000)，代表序列的长度和询问的次数.
    //cin >> n >> m;
    scanf("%lld%lld", &n, &m);
    //第二行包含𝑁个整数，表示初始的序列𝐴(−1000000000≤𝐴𝑖≤1000000000)。
    for (long long i = 1, pre = 0, a; i <= n; i++) {
        //cin >> a;
        scanf("%lld", &a);
        modify(i, a - pre, n);
        pre = a;
    }
    char s[10];
    for (long long i = 0, l, r, d; i < m; i++) {
        //cin >> s;
        scanf("%s", s);
        switch (s[0]) {
        case 'C': {//"C a b c"表示给[a, b]区间中的值全部增加c (-10000 ≤ c ≤ 10000)。
                      //cin >> l >> r >> d;
                      scanf("%lld%lld%lld", &l, &r, &d);
                      modify(l, d, n);
                      modify(r + 1, -d, n);
                  }break;
        case 'Q': {//"Q a b" 询问[a, b]区间中所有值的和。
                      //cin >> l >> r;
                      scanf("%lld%lld", &l, &r);
                      printf("%lld\n", S(r) - S(l - 1));
                      //cout << (S(r) - S(l - 1)) << endl;
                  }break;
        }
    }

    return 0;
}
```



# 7.树状数组习题

## 一、海贼 OJ-331-丢失的奶牛1

1. 理解标记数组，标记数组记录的是每一个下标知否可用，可用为1，不可用为0
2. 根据题意，我们从后向前，依次确定每一头奶牛的编号
3. 例如，当前奶牛比他前面的2个奶牛编号大的话，当前奶牛的编号就是当前剩余可用编号中的第三大的编号
4. 如何找到可用的第 x 大的编号，可以在标记数组的前缀和数组上做二分查找
5. 设计到标记数组的前缀和维护和单点更新，所以可以使用树状数组
6. 时间复杂度：$O(nlogn)$



相似问题：海贼 OJ-332-买票

```

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 80000
int c[MAX_N + 5];
#define lowbit(x) (x & -x)
void add(int i, int x, int n) {
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

int query(int i) {
    int sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;
}

int n;
int cnt[MAX_N + 5];
int ind[MAX_N + 5];

void read() {
    cin >> n;
    ind[1] = 0;
    for (int i = 2; i <= n; i++) cin >> cnt[i];
    for (int i = 1; i <= n; i++) {
        add(i, 1, n);
    }
    return ;
}

int binary_search(int n, int x) {
    int head = 1, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (query(mid) < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

void solve() {
    for (int i = n; i >= 1; --i) {
        ind[i] = binary_search(n, cnt[i] + 1);
        add(ind[i], -1, n);
    }
    return ;
}

void output() {
    for (int i = 1; i <= n; i++) {
        cout << ind[i] << endl;
    }
    return ;
}

int main() {
    read();
    solve();
    output();
    return 0;
}

```





332

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 200000
int c[MAX_N + 5];
#define lowbit(x) (x & -x)
void add(int i, int x, int n) {
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

int query(int i) {
    int sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;
}

int n;
int cnt[MAX_N + 5];
int val[MAX_N + 5];
int ind[MAX_N + 5];
int ans[MAX_N + 5];

int binary_search(int n, int x) {
    int head = 1, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (query(mid) < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

void read() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> cnt[i] >> val[i];
        add(i, 1, n);
    }
    return ;
}

void solve() {
    for (int i = n; i >= 1; --i) {
        ind[i] = binary_search(n, cnt[i] + 1);
        add(ind[i], -1, n);
        ans[ind[i]] = val[i];
    }
    return ;
}

void output() {
    for (int i = 1; i <= n; i++) {
        i == 1 || cout << " ";
        cout << ans[i];
    }
    cout << endl;
    return ;
}

int main() {
    read();
    solve();
    output();
    return 0;
}

```



## 二、海贼 OJ-328-楼兰图腾1

1. 求在当前位置之前，小于当前位置值的元素数量，当前元素值记为 X，元素数量记为 a，元素位置记为 i
2. 前面小于 $X$ 的元素数量是 $a$
3. 后面小于 $X$ 的元素数量是$X - a - 1$
4. 前面大于 $X$ 的元素数量 $i - a - 1$
5. 后面大于X 的元素数量$n-X-i+a+1$
6. 解题关键：前面小于 $X$ 的元素数量是 $a$
7. 标记数组，记录当前位置之前有哪些元素出现过，出现过标记为 1，否则标记为 0
8. $a$ 等于标记数组在 $X$ 位置之前的前缀和
9. 对于标记数组的单点修改及前缀和查询，所以可以使用树状数组

```

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 200000
long long c[MAX_N + 5];
#define lowbit(x) (x & -x)
void add(long long i, long long x, long long n) {
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

long long query(long long i) {
    long long sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;
}

long long n;
long long val[MAX_N + 5];

void read() {
    cin >> n;
    for (long long i = 1; i <= n; i++) {
        cin >> val[i];
    }
    return ;
}

void solve(long long &x, long long &y) {
    x = y = 0;
    for (long long i = 1; i <= n; i++) {
        long long a1 = query(val[i]);
        long long a2 = val[i] - a1 - 1;
        long long b1 = i - a1 - 1;
        long long b2 = n - val[i] - b1;
        x += b1 * b2;
        y += a1 * a2;
        add(val[i], 1, n);
    }
    return ;
}

int main() {
    read();
    long long a, b;
    solve(a, b);
    cout << a << " " << b << endl;
    return 0;
}

```



## 三、海贼 OJ-333-区间最大子段和1

1. 线段树有点点儿难度的题目
2. 每个节点：区间和值，最大子段和值，左侧最大子段和，右侧最大子段和
3. 特殊性质：递归遍历时，是按照下标顺序得到的每一个查询区间内的线段树的节点
4. $|①②③④⑤|$，就是按照①②③④⑤的顺序遍历得到的每一个节点
5. 代码有点儿复杂，学会了，代码思维会更上一层楼



```

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 500000
#define L(ind) (ind << 1)
#define R(ind) (ind << 1 | 1)
#define SUM(ind) tree[ind].sum
#define INMAX(ind) tree[ind].inmax
#define LMAX(ind) tree[ind].lmax
#define RMAX(ind) tree[ind].rmax
struct Data{
    int sum, inmax, lmax, rmax;
} _tree[(MAX_N << 2) + 5];
Data *tree = _tree + 1;
int n, m, flag;
int val[MAX_N + 5];

void UP(int a, int b, int c) {
    SUM(a) = SUM(b) + SUM(c);
    LMAX(a) = max(LMAX(b), SUM(b) + LMAX(c));
    RMAX(a) = max(RMAX(c), SUM(c) + RMAX(b));
    INMAX(a) = max(max(INMAX(b), INMAX(c)), RMAX(b) + LMAX(c));
    return ;
}

void build(int ind, int l, int r) {
    if (l == r) {
        SUM(ind) = INMAX(ind) = LMAX(ind) = RMAX(ind) = val[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build(ind << 1, l, mid);
    build(ind << 1 | 1, mid + 1, r);
    UP(ind, ind << 1, ind << 1 | 1);
    return ;
}

void modify(int ind, int l, int r, int i, int x) {
    if (l == r) {
        SUM(ind) = INMAX(ind) = LMAX(ind) = RMAX(ind) = x;
        return ;
    }
    int mid = (l + r) >> 1;
    if (i <= mid) {
        modify(ind << 1, l, mid, i, x);
    } else {
        modify(ind << 1 | 1, mid + 1, r, i, x);
    }
    UP(ind, ind << 1, ind << 1 | 1);
    return ;
}

void query(int ind, int l, int r, int x, int y) {
    if (x <= l && r <= y) {
        if (flag) {
            tree[0] = tree[ind];
            flag = 0;
        } else {
            UP(-1, 0, ind);
            tree[0] = tree[-1];
        }
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) {
        query(ind << 1, l, mid, x, y);
    }
    if (y > mid) {
        query(ind << 1 | 1, mid + 1, r, x, y);
    }
    return ;
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    build(1, 1, n);
    for (int i = 0; i < m; i++) {
        int k, x, y;
        cin >> k >> x >> y;
        switch (k) {
            case 1: {
                if (x > y) swap(x, y);
                flag = 1;
                query(1, 1, n, x, y);
                cout << INMAX(0) << endl;
            } break;
            case 2: {
                modify(1, 1, n, x, y);
            } break;
        }
    }
    return ;
}

int main() {
    solve();
    return 0;
}

```





# 8.字符串的匹配算法(上)

## 8.1暴力匹配算法

1. 字符串匹配问题：单模匹配问题，顾名思义，只有一个模式串
2. 依次对齐模式串和文本串的每一位，直到匹配成功
3. 关键：不重不漏的找到答案

![截屏2021-01-18 上午10.36.32](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8A%E5%8D%8810.36.32.png)



```cpp
using namespace std;

int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; i++) {
        int flag = 1;
        for (int j =0; t[j]; j++) {
            if (s[i + j] && s[i + j] == t[j]) continue;
            flag = 0;
            break;
        }
        if (flag == 1) return i;
    }
    return -1;
}


int main() {
    char s[100], t[100];
    while (scanf("%s%s", s, t) != EOF) {
        printf("match(%s, %s) = %d\n", s, t, brute_force(s, t));
    }

    return 0;
}
```



## 8.2KMP 算法

推导**&**构建 **KMP** 算法 **By Hug** (转载时，请注明出处:By Hug)

曾经自己理解了 KMP 算法以后，跟小伙伴吹牛逼:你信不信，我五分钟给 你讲懂 KMP。事实证明，我失败了。KMP 就是这样的一种存在，理解了思想非 常简单，可是真想讲出来，还给对方讲懂，让对方忘不了，真的是一件困难的事 情。

静下心来，反复思索，形成如下推导过程，站在这个点上，我可以跟曾经的 那个小伙伴说一句:我曾经吹的牛逼，自己圆回来，也谢谢你陪我在百度大厦同 住了三个月。

经过如下推导过程，没有我曾经说的 5 分钟那么简单，但也绝对没有当初表 述的那么复杂。来吧，我们开始吧。

阅读此文之前，请自行阅读如下资料:

http://blog.csdn.net/yutianzuijin/article/details/11954939 有了以上资料的了解后，让我们一起来开始推导&构建 KMP 算法

定义:A 是问题中的模式串(短串)，长度为 n 定义:B 是问题中的文本串(长串)，长度为 m

A[i] 代表 A 字符串的第 i 位
 B[j] 代表 B 字符串的第 j 位
 A[i, j] 代表 A 字符串第 i 位到第 j 位，(注:下标从 1 开始) B[i, j] 代表 B 字符串第 i 位到第 j 位，(注:下标从 1 开始)

Sign(i, j) 为分段函数，取值{0, 1}， 当 A[i] = B[j] 的时候，sign(i, j) = 1 当 A[i] != B[j] 的时候，sign(i, j) = 0

重点一:原始问题的等价表示

max(∑! 𝑠𝑖𝑔𝑛(𝑖,𝑗+𝑖−1)| 𝑗∈[1,𝑚])?=𝑛 公式1 "#$

原始问题转化为如上公式的判定问题，判定最大值公式是否等于 n，公式1 与原问题等价

对于公式1做优化，其中 sign 的加和部分没有必要每次都运算 n 次，其实

第一次碰到 sign(i, j + i - 1) =0 的时候，就应该停止了。所以，假设，第一次碰到 sign(i, j + i - 1) = 0 的位置时，i 的值是 k + 1，则公式1，简化为如下公式:

max8∑% 𝑠𝑖𝑔𝑛(𝑖,𝑗+𝑖−1)9 𝑗∈[1,𝑚],𝑘+1位置失配)?=𝑛 公式2 "#$

公式1和公式2所求问题等价。 重点二:推导公式**2**等价问题的性质

公式2中有两个不定量，j 和 k，j 与文本串有关，k 与答案有关，所以设 置函数 f(j) = k，完成从文本串到答案的映射。
 原问题变成 max(f(j)) ?= n，与寻找 f(j) 函数的最大值等价
 设:

f(j) = k 条件1
 f(j + e) = l 条件2
 其中，l > k，e 为满足条件的最小正整数，具体含义是，未来能找到一个后面

的位置，其匹配成功的长度比之前匹配成功的长度 k 更大。 条件1等价于:A[1,k] = B[j, j + k - 1]
 条件2等价于:A[1, l] = B[j + e, j + e + l - 1]

将条件2与条件1对齐，看看我们能推出什么样的性质(这个性质，与原 问题不等价，但是不满足这个性质，原问题肯定不成立)

另:j+e+l–1=j+k–1 得 l=k–e，则有

A[1, k - e] = B[j + e, j + k - 1] = A[e + 1, k]

由此，我们推导得出 f(j) < f(j + e) 的一个重要性质，是通过 A 串来进行表达 的，这个性质就是:**A[1, k - e] = A[e + 1, k]** (也就是通常所说的，前半段等于后 半段)

由于 e 是满足条件的最小正整数，所以 **A[1, k - e] = A[e + 1, k]** 的含义如下: 1、 描述的物理含义是，前后最长相等的片段。
 2、当匹配 k+1失败的时候，如果此时 A 串前 k 位匹配成功了，说明从 B

串的 j + e 位开始匹配，最起码能够匹配成功 k – e 位，那么下一次判断， 应该是用 A[k-e + 1]位 与 B[j + k] 位进行比较。(对于这个性质的理解很 重要，在重点三中会用到)

重点三:推导 **k** 和 **e** 的映射关系

设置函数 g(k)=k–e 等价于A[1,k-e]=A[e+1,k]，现在讨论 g(k+1)的值: 操作一:当 A[k–e+1]=A[k+1]时，g(k+1)=g(k)+1
 操作二:当 A[k–e+1]!=A[k+1]时，说明:

A[1,k–e]A[k–e+1] 与串 A[e+1,k]A[k+1] 在最后一位上失配了

将 A[e + 1, k]A[k + 1]看做是文本串(与 B 串的性质类似)，A[1, k - e]A[k – e + 1] 看做模式串，则根据以上推导，在 k – e 位匹配成功，下一位失配的情况下，我 们应该用 A[g(k - e) + 1] (等价与 A[g(g(k)) + 1]) 位与 A[k + 1]进行比较，若相等， 则进行操作一的类似操作，否则继续进行操作二的操作。

由于我们的字符串下表是从 1 开始的，所以定义边界条件 g(1) = 0，下标如 果是从 0 开始，则 g(1) = -1

对于 g 函数的理解很重要，对于不同的 KMP 算法的实现，其实就是在维护 g 函数中不同的变量值，由于变量值涉及到 k 和 e 两个值，所以相应的，我们可 以定义如下三种不同的 g 函数，对于每一种 g 函数的定义，就对应了不同的 KMP 算法的具体实现:

g(k) = k - e g(k) = -e g(k) = e

文章写到这里，我相信你已经具备了自己应用的能力了，得到了 g 函数(所谓的 next 数组)所有的对应关系以后，怎样应用，请回顾重点二中的内容。



1. KMP 算法中，模式串中的第三部分的重要性

2. 第三部分是可以帮助我们加快匹配速度的，避免掉大量无用的匹配尝试

3. KMP 算法保证不漏：第三部分匹配到的是模式串的最长前缀

4. 普通编码：获得 NEXT 数组，使用 NEXT 数组

5. 高级编码：抽象化了一个状态机模型，j 所指向的就是状态机中的位置

6. getNext 方法相当于根据输入字符，进行状态跳转，实际上就是改变 j 的值

   



![截屏2021-01-18 下午4.43.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%884.43.10.png)



next数组:



![截屏2021-01-18 下午5.08.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.08.27.png)



![截屏2021-01-18 下午5.12.55 1](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%885.12.55%201.png)





```cpp
#include <iostream>
#include <cstring>
using namespace std;

int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; i++) {
        int flag = 1;
        for (int j =0; t[j]; j++) {
            if (s[i + j] && s[i + j] == t[j]) continue;
            flag = 0;
            break;
        }
        if (flag == 1) return i;
    }
    return -1;
}

void getNext(const char *t, int *next) {
  //预处理t字符串，储存在next数组中，next数组存储匹配到字符串的下标
    next[0] = -1;
    int j = -1;//指向上一位next数组的值
    for (int i = 1; t[i]; i++) {//遍历t字符串
      //如果上一位next数组的值不为-1且当前数组位置的值和字符串不匹配，
        while (j != -1 && t[j + 1] != t[i]) j = next[j];
      //字符串j+1位!=当前位置,但是t[j]=t[i - 1],
      //如果要使t[j + 1] = t[i],就可以跟着next[j]往回走，
      //直到t[j + 1] = t[i]或者没有找到，直到j = -1
        if (t[j + 1] == t[i]) j += 1;
        next[i] = j;
    }
    return ;
}

int kmp(const char *s, const char *t) {
    //初始化next数组
    int n = strlen(t);
    int *next = (int *)malloc(sizeof(int) * n + 1);
    getNext(t, next);
    //输出next数组的值
    /*
    for (int i = 0; i < n; i++) {
        printf("%d ", next[i]);
    }
    cout << endl;
    */
    //使用next数组进行匹配
    for (int i = 0, j = -1; s[i]; i++) {
        //s[i]!=t[j+1]
        while (j != -1 && s[i] - t[j + 1]) j = next[j];  
        if (s[i] == t[j + 1]) j += 1;
        if (t[j + 1] == 0) return i - n + 1;
    }
    free(next);
    return -1;
}


int main() {
    char s[100], t[100];
    while (scanf("%s%s", s, t) != EOF) {
        printf("brute_force(%s, %s) = %d\n", s, t, brute_force(s, t));
        printf("kmp(%s, %s) = %d\n", s, t, kmp(s, t));
        //printf("brute_force(%s, %s) = %d\n", s, t, brute_force(s, t));
    }

    return 0;
}
```



对代码进行优化



```cpp
#include <iostream>
#include <string>

using namespace std;

int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; i++) {
        int flag = 1;
        for (int j = 0; t[j] && flag; j++) {
            flag = flag && (s[i + j] && s[i + j] == t[j]);
        }
        if (flag == 1) return i;
    }
    return -1;
}

int getNext(const char *t, int &j, char input, int *next) {
  //传入j和当前位置的字符串
    while (j != -1 && t[j + 1] != input) j = next[j];
    if (t[j + 1] == input) j += 1;
    return j;
}

int kmp(const char *s, const char *t) {
    int n = strlen(t);
    int *next = (int *)malloc(sizeof(int) * n + 1);
    next[0] = -1;
    for (int i = 1, j = -1; t[i]; i++) next[i] = getNext(t, j, t[i], next);//初始化
    for (int i = 0, j = -1; s[i]; i++) {
        if (getNext(t, j, s[i], next) != n - 1) continue;
      //匹配成功
        return i - n + 1;//匹配完成
    }
    free(next);
    return -1;
}
 

int main() {
    char s[100], t[100];
    while (scanf("%s%s", s, t) != EOF) {
        printf("brute_force(%s, %s) = %d\n", s, t, brute_force(s, t));
        printf("kmp(%s, %s) = %d\n", s, t, kmp(s, t));
   
    }
    return 0;
}

```



## 8.3SUNDAY 算法

1. SUNDAY 算法理解的核心，在于理解黄金对齐点位
2. 是文本串的匹配尾部，一定会出现在模式串中的字符
3. 应该和模式串中最后一位出现该字符的位置对齐
4. 第一步：预处理每一个字符在模式串中最后一次出现的位置
5. 第二步：模拟暴力匹配算法过程，失配的时候，文本串指针根据预处理信息向后移动若干位





![截屏2021-01-18 下午9.06.30](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.30.png)

![截屏2021-01-18 下午9.06.51](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.06.51.png)

![截屏2021-01-18 下午9.07.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.07.10.png)

![截屏2021-01-18 下午9.30.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.57.png)

![截屏2021-01-18 下午9.30.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-18%20%E4%B8%8B%E5%8D%889.30.43.png)











```cpp
#include <iostream>
#include <cstring>
using namespace std;
int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; i++) {
        int flag = 1;
        for (int j = 0; t[j] && flag; j++) {
            flag = flag && (s[i + j] && s[i + j] == t[j]);
        }
        if (flag == 1) return i;
    }
    return -1;
}

int sunday(const char *s, const char *t) {
    int offset[256];
    int n = strlen(t), m = strlen(s);
  	//第一次匹配的时候会从t字符串末尾开始匹配
 	 //初始化offset数组，
    for (int i = 0; i < 256; i++) offset[i] = n + 1;
 	 //假如所有字符都没没有出现过，
    for (int i = 0; t[i]; i++) offset[t[i]] = n - i;
  	//遍历t字符串,字符串出现在倒数第n-i位
    for (int i = 0; i + n <= m; i += offset[s[i + n]]) {
        int flag = 1;
        for (int j = 0; t[j] && flag; j++) {
            flag = flag && (s[i + j] == t[j]);
        }
        if (flag) return i;
    }
    return -1;
}


int main() {
    char s[100], t[100];
    while (scanf("%s%s", s, t) != EOF) {
        printf("brute_force(%s, %s) = %d\n", s, t, brute_force(s, t));
        printf("sunday(%s, %s) = %d\n", s, t, sunday(s, t));
    }

    return 0;
}
```



```shell
brute_force(123456789, aeadaeadaeae) = -1
sunday(123456789, aeadaeadaeae) = -1
brute_force(hello, ll) = 2
sunday(hello, ll) = 2
brute_force(world, ld) = 3
sunday(world, ld) = 3
brute_force(haizei, hu) = -1
sunday(haizei, hu) = -1
```





# 9 字符串匹配算法(中)

## 9.1字符串的哈希匹配算法

### HAIZEIOJ-275.兔子与兔子

![截屏2021-01-19 下午2.16.17](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.17.png)

![截屏2021-01-19 下午2.16.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.16.34.png)







1. 可以使用哈希操作判断两个字符串是否相等
2. 哈希值不同的话，两个字符串一定不相等，从而就不需要按位比较了
3. $H = (\sum_{k=0}^{n-1}{C_k\times base^k})\%P$
4. 在文本串上，每一位字符串哈希值的前缀和，方便以后求区间和
5. $H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}\%P $//求i~j的哈希值



### 快速求逆元的推导过程

$$
\begin{aligned}
x\times x^{-1}&\equiv1\ (mod\ P) \\
令：P\%x&=r \\
P &= kx+r \\
kx+r &\equiv0\ (mod\ P) \\
kr^{-1}+x^{-1} &\equiv0\ (mod\ P) \\
x^{-1} &\equiv-kr^{-1}\ (mod\ P) 
\end{aligned}
$$



### 哈希值的计算

![](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.36.27.png)



逆元

![截屏2021-01-19 下午2.41.05](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.05.png)



逆元的推导：*

r=P%x

![截屏2021-01-19 下午2.41.13](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.41.13.png)





```cpp
#include <iostream>
using namespace std;
int inv[7] = {0};
//求1~7的7的逆元

int main() {
    inv[1] = 1;
    for (int i = 2; i < 7; i++) {//P = 7
        //inv[i] = (-(7/i) * inv[7 % i]);==>是负数，将负数变成正数
        inv[i] = ((-(7 / i) * inv[7 % i]) % 7 + 7) % 7;
        cout << i << ":" << inv[i] << endl;
    }

    return 0;
}
```

```bash
2:4
3:5
4:2
5:3
6:6
```



## 9.2 shift_and 算法

1. 第一步对模式串做特殊处理，把每一种字符出现的位置，转换成相应的二进制编码
2. 后续匹配的过程中跟模式串一毛钱关系都没有
3. $p_i = (p_{i-1}<<1 | 1) \& d[s_i]$
4. $p_i$第 j 位二进制为1，代表当前位置为结尾，可以匹配成功模式串的第 j 位

![截屏2021-01-19 下午8.38.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%888.38.00.png)

![截屏2021-01-19 下午2.46.34](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%882.46.34.png)



i = 1,P = 010000

i = 4, P = 010010



```cpp
#include <iostream>
using namespace std;
int brute_force(const char *s, const char *t) {//暴力匹配算法
    for (int i = 0; s[i]; i++) {
        int flag = 1;
        for (int j = 0; t[j] && flag; j++) {
            flag = flag && (s[i + j] && s[i + j] == t[j]);
        }
        if (flag == 1) return i;
    }
    return -1;
}

int shift_and(const char *s, const char *t) {
    int d[256] = {0}, n = 0;//处理模式串
    for (int i = 0; t[i]; n++,i++) d[t[i]] |= (1 << i);
    int p = 0;
    for (int i = 0; s[i]; i++) {
        p = (p << 1 | 1) & d[s[i]];
        if (p & (1 << (n - 1))) return i - n + 1;//判断p的第n位是否为1，是：完全匹配成功
    }
    return -1;
}

int main() {
    char s[100], t[100];
    while (scanf("%s%s", s, t) != EOF) {
        printf("brute_force(%s, %s) = %d\n", s, t, brute_force(s, t));
        printf("shitf_and(%s, %s) = %d\n", s, t, shift_and(s, t));
    }


    return 0;
}
```



## 9.3 字典树结构

1. 也叫做：前缀索引树
2. 把每个字符串按照前缀的顺序插入到树形结构中
3. 字典树可以用于==字符串的排序==，时间复杂度 $O(n)$



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
using namespace std;

#define BASE 26

typedef struct Node {//字典树
    int flag;//标记当前结点是否独立成词
    struct Node *next[BASE];//假如只有26个字符串
} Node;

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));//将p的子树的每一个值都初始化为0
    return p;
}

void insert(Node *p, const char *s) {
    for (int i = 0; s[i]; i++) {
        int ind = s[i] - 'a';
        if (p->next[ind] == NULL)  p->next[ind] = getNewNode();
        p = p->next[ind];//向下走动一个结点，继续向下插入
    }
    p->flag = 1;
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

void output(Node *root, int k, char *s) {
    s[k] = 0;//字符串的最后一位为0
    if (root->flag) {//当前结点独立成词
        printf("%s\n", s);
    }
    for (int i = 0; i < BASE; i++) {//遍历子节点
        if (root->next[i] == NULL) continue;//当前子节点为空
        //当前子节点不为空继续向下遍历
        s[k] = 'a' + i;
        output(root->next[i], k + 1, s);
    }
    return ;
}

int main() {

    int n;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    output(root, 0, str);//深度优先遍历，当前字典树所在结点地址root，所在层数0， 字符串
    clear(root);
    return 0;
}
```



## 9.4 海贼 OJ-282-最大异或对

![截屏2021-01-19 下午11.52.03](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-19%20%E4%B8%8B%E5%8D%8811.52.03.png)

1. 思考：如何使得异或结果尽可能大
2. 结论：参与异或运算的两个数字，参与异或运算的每一位尽可能不同
3. 问题转换为：确定一个数字的情况下，找到从高为到低位与当前数字尽量不同的另外一个数字
4. 把每个数字看成一个二进制字符串，插入到字符串中，采用贪心策略进行选择



```cpp
#include <iostream>
using namespace std;
#define MAX_N 310000
#define BASE 31

struct Node {
    Node *next[2];
} tree[MAX_N * BASE + 5];//假如 每个都是32位，所以需要flag

int cnt = 0;
Node *getNewNode() {
    return &tree[cnt++];
}

void insert(Node *root, int x) {//插入x
    for (int i = 30; i >= 0; i--) {
        int ind = !!(x & (1 << i));
        //归一化，将(1 << i) 转换成0或1,(1 << 1) == 2,!!(1 & 2) = 0,!!(2 & 2) = 1
        //ind = (x & (1 << i)) % 2;
        if (root->next[ind] == NULL) root->next[ind] = getNewNode();
        root = root->next[ind];
    }
}

int query(Node *root, int x) {
    //求和x所能形成的最大异或和
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        int ind = !(x & (1 << i));//
        if (root->next[ind]) {//判断第i位异或结果能不能为1
            ans |= (1 << i);//将ans的第i为置为1
            root = root->next[ind];
        } else {
            root = root->next[!ind];
        }
    }
    return ans;
}

int n;
int val [MAX_N + 5];

int main() {

    cin >> n;
    int ans = 0;
    int a;
    Node *root = getNewNode();
    cin >> a;
    insert(root, a);
    n--;
    while (n --) {
        cin >> a;
        ans = max(query(root, a), ans);
        insert(root, a);
    }
    cout << ans << endl;


    return 0;
}

```



# 10 字符串匹配算法(下)



字典树是字典数据的另一种表现形式，本质字典树+AC自动机s



## 10.1多模匹配问题

1. 有多个模式串的匹配问题，就是多模匹配问题
2. Step1：多个模式串，建立成一棵字典树
3. Step2：和文本串的每一位对齐匹配，模拟暴力匹配算法的过程



## 10.2AC 自动机的思想

1. 当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he
2. she 对应了字典树中的节点 P，he 对应了字典树中的节点Q
3. P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程
4. 在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作
5. 这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】
6. AC 自动机 = Trie + Fail 指针(字典树+fai指针)
7. 子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】
8. 没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）
9. 通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态
10. 第二种理解：当前状态，并不代表唯一状态。(当前状态、当前状态的fail的状态，当前状态的fail的fail的状态)



**AC 自动机优化：**使用路径压缩思想，使状态转移时可以一步跳转到目标状态。



优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。

![截屏2021-01-24 下午4.30.09](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-24%20%E4%B8%8B%E5%8D%884.30.09.png)



## 10.3代码实现

```cpp
#include <iostream>
#include <cstring>
using namespace std;

#define BASE 26

typedef struct Node {
    int flag;//是否独立成词，1是，0不是
    int tag[BASE];//记录每一条边是否被优化过：1字典树中的边，0：ac自动机中的边
    const char *str;
    struct Node *next[BASE];
    struct Node *fail;//等价关系指针
} Node;

int node_cnt = 0;//记录当前环境一共有多少个节点

Node *getNewNode() {
    node_cnt += 1;
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    p->fail = NULL;
    return p;
}

void insert(Node *root, const char *str) {//以字典树的形式插入
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a';
        if (root->next[ind] == NULL) root->next[ind] = getNewNode();//要插入的新节点为空
        root->tag[ind] = 1;
        root = root->next[ind];
    }
    root->flag = 1;
    root->str = strdup(str);
    return ;
}

void build_ac(Node *root) {//建立ac自动机
    //用层序遍历的方式遍历，建立fail指针,层序遍历使用队列
    Node **q = (Node **)malloc(sizeof(Node *) * (node_cnt + 5));
    int head = 0, tail = 0;
    root->fail = NULL;//初始化根节点fail指针
    for (int i = 0; i < BASE; i++) {//初始化其他节点
        if (root->next[i] == NULL) {
            root->next[i] = root;//根节点的next为空，默认指向根节点
            continue;
        }
        root->next[i]->fail = root;//根节点下面的第一层fail默认指向根节点
        q[tail++] = root->next[i];
    }
    while (head < tail) {//当队列不为空
        Node *p = q[head++];
        for (int i = 0; i < BASE; i++) {
            Node *c = p->next[i], *k = p->fail;
            if (c == NULL) {//当前节点没有子孩子
                p->next[i] = k->next[i];//没有子孩子，直接指向fail指向的节点
                continue;
            }
            while (k && k->next[i] == NULL) k = k->fail;//fail不为空且没有子孩子则直接指向fail
            if (k == NULL) k = root;
            if (k->next[i]) k = k->next[i];//k->next[i] != NULL,fail指向的节点那个节点和c指向的节点对应
            c->fail = k;
            q[tail++] = c;//c节点压入队列
        }
    }
    free(q);
    return ;
}

void match(Node *root, const char *text) {//AC自动机的匹配过程
    Node *p = root;//当前状态的位置
    Node *q;//下一次要跳转的状态
  // for (int i = 0; text[i]; i++) {//遍历文本串的每一位
    //     int ind = text[i] - 'a';
    //      while (p && p->next[ind] == NULL ) p = p->fail;//找不到文本串的内容，就通过fail指针向上跳
    //      if (p == NULL) p = root;;
    //      if (p->nex[ind]) p = p->ext[ind];
    //      q = p;
    //      while (q) {//当前的是fail对应的指针独立成词
    //      if (q->flag == 1) printf("find : %s\n", q->str);//输出
    //          q = q->fail;
    //      }
    //      if (q->flag == 1) printf("find : %s\n", q->str);//p所在的节点独立成词
    // }
  // 优化，将空节点指向fail
    for (int i = 0; text[i]; i++) {//遍历文本串的每一位
        int ind = text[i] -'a';
        p = p->next[ind];
        q = p;
        while (q) {
            if (q->flag == 1) printf("find : %s\n", q->str);
            q = q->fail;
        }
    }
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        if (root->tag[i]) clear(root->next[i]);//是字典树上的边
    }
    free(root);
    return ;
}


int main() {
    int n;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    build_ac(root);//建立AC自动机
    printf("build ac\n");
    scanf("%s", str);
    match(root, str);//匹配文本串
    clear(root);
    return 0;
}
```

输入

```
5
say
she
shr
he
her
sasherhs
```



输出

```
build ac
find : she
find : he
find : he
```



## 10.4字符串统计

![截屏2021-01-25 下午5.01.20](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.20.png)



![截屏2021-01-25 下午5.01.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-01-25%20%E4%B8%8B%E5%8D%885.01.42.png)

1. AC 自动机裸题

2. 解题的关键，在于如何维护每一个单词的计数量

3. 使用幼儿园必知必会的指针技巧维护的




```cpp

#include <stdio.h>
#include <stdlib.h>

#define BASE 26
#define MAX_N 20000

struct Node {
    int flag, *cnt;//是否独立成词,指针ans中的某个元素的位置
    int next[26], fail;//26条边,英文单词有26个,存储单词所在数组的下标编号
} tree[MAX_N + 5];

int que[MAX_N + 5], head, tail;//队列
int *ans[MAX_N + 5];//ans[i]:第i个单词出现的次数
int root = 1, cnt = 2;//根节点编号,当前可用节点编号
char str[100005];//文本串,即字符串 S,仅由小写字母组成，长度不超过 10^5,表示蒜头君看的文章
int n;

int getNewNode() { return cnt++; }
int *insert(const char *str) {//在字典树中插入单词
    int p = root;//p指向根节点
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a';//第i位所对应根的编号
        if (tree[p].next[ind] == 0) tree[p].next[ind] = getNewNode();//p节点的第ind条边
        p = tree[p].next[ind];
    }
    tree[p].flag = 1;//
    if (tree[p].cnt == NULL) {
        tree[p].cnt = (int *)malloc(sizeof(int));
        tree[p].cnt[0] = 0;
    }
    return tree[p].cnt;
}

void build() {//建立fail指针
    //初始化队列
    head = tail = 0;
    tree[root].fail = 0;//初始化根节点的fail指针
    for (int i = 0; i < BASE; i++) {//初始化根节点的子孩子
        if (tree[root].next[i] == 0) {//没有第i个子孩子，直接指向根节点
            tree[root].next[i] = root;
            continue;
        }
        tree[tree[root].next[i]].fail = root;//根节点的第i个子孩子的fail指针
        que[tail++] = tree[root].next[i];//入队列
    }
    while (head < tail) {//
        int p = que[head++];//取出当前节点
        for (int i = 0; i < BASE; i++) {//扫描当前节点的子孩子，建立fail指针
            int c = tree[p].next[i], k = tree[p].fail;
            if (c == 0) {
                tree[p].next[i] = tree[k].next[i];
                continue;
            }
            
            k = tree[k].next[i];
            tree[c].fail = k;
            que[tail++] = c;
        }
    }
    return ;
}

void match(const char *str) {
    int p = root;//当前状态
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a', q;
        p = tree[p].next[ind];
        q = p;
        while (q) {
            if (tree[q].flag) {//q节点独立成词
                (*tree[q].cnt) += 1;
            }
            q = tree[q].fail;
        }
    }
    return ;
}

int main() {
    scanf("%d", &n);//第一行输入一个整数 n（10001≤n≤1000），表示蒜头君学习的 n 个单词。
    for (int i = 0; i < n; i++) {//接下来 n 行，每行输入一个字符串，仅由小写字母组成，长度不超过 20。
        scanf("%s", str);
        ans[i] = insert(str);
    }
    scanf("%s", str);//文本串，输入一个字符串 S，仅由小写字母组成，长度不超过 10^5，表示蒜头君看的文章。
    build();
    match(str);
    for (int i = 0; i < n; i++) {
        printf("%d: %d\n", i, *ans[i]);
    }
    return 0;
}

```





















# 0.END

























