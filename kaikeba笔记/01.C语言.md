---

title: C语言

date: 2020-11-17 08:08:15

tags: C语言

categories: C语言

---

# 目录

[TOC]



2020.11.17-12.20









# 0.基础知识









**unsigned int （unsigned long）**

- 4字节8位可表达位数：2^32=42 9496 7296
- 范围：0 ～ 42 9496 7295 (42*10^8)

**int （long）**

- 4字节8位可表达位数：2^32=42 9496 7296
- 范围：-21 4748 3648 ～ 21 4748 3647 (21*10^8)

**unsigned long (unsigned __int64)**

- 8字节8位可表达位数：2^64=1844 6744 0737 0960 0000
- 范围：0 ～ 1844 6744 0737 0955 1615 (1844*10^16)

**long long (__int64)**

- 8字节8位可表达位数：2^64=1844 6744 0737 0960 0000
- 范围：-922 3372 0368 5477 5808 ～ 922 3372 0368 5477 5807 (922*10^16)



 



`while(~scanf()):~`按位取反,`scanf`返回值为-1时值不合法，-1（1111...1111）,-1按位取反结果为0循环终止



> `%d` —— 以带符号的十进制形式输出整数 
>
> `%o` —— 以无符号的八进制形式输出整数 
>
> `%x` —— 以无符号的十六进制形式输出整数
>
> `%u` —— 以无符号的十进制形式输出整数 
>
> `%c` —— 以字符形式输出单个字符 
>
> `%s` —— 输出字符串 
>
> `%f` —— 以小数点形式输出单、双精度实数
>
> `%e` —— 以标准指数形式输出单、双精度实数
>
> `%g` —— 选用输出宽度较小的格式输出实数，科学技术输出
>
> `%ld`用于long类型，`%lld`用于long long类型。
>
> `%lu` `sizeof(array)`
>
> `%p`   `&i`
>
> ` double`对应的是 `%lf`
> `float`对应的是 `%f`



![截屏2020-10-27 上午9.37.36](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-10-27%20%E4%B8%8A%E5%8D%889.37.36.png)





## 输入输出函数说明

## 1.printf函数

```C

  	头文件：stdio.h
  	原型：int printf(const char *fromat, ...);//返回成功打印字符个数
		format :格式控制字符串
    ...:可变参数列表
    返回值：输出字符的数量
//使用printf函数，求解一个数字n的十进制表示的数字位数
 #include<stdio.h>
int main(int argc,const char* argv[]){
	int n;
	scanf("%d", &n);
  n = printf("%d",n); 
	printf(" has %d digits! \n", n);
	return 0;
}
    
```



## 2.scanf函数

```c


  	头文件：stdio.h
  	原型：int scanf(const char *fromat, ...);//返回成功打印字符个数
		format :格式控制字符串
    ...:可变参数列表
    返回值：成功读入参数的个数
    //读入一个字符串(可能包含空格)，输出这个字符串中字符的数量，
#include<stdio.h>
int main(int argc,const char* argv[]){
	char str[1000] = {0};
	int n;
	while(scanf("%[^\n]s",str) != EOF){
		getchar();
    n =  printf("%s", str);
		printf("  has  %d digits!\n", n);
  }
	return 0;
}


```

> 使用scanf时其会将末尾的回车符保留在缓存当中，所以在用其输入字符串时一定要加一个getchar去吃掉回车符

`~scanf()`



## 3.sprinf,fprintf

```c


//

#include<stdio.h>
int main(int argc,const char* argv[]){
	int n;
	char str[1000] = {0};
# if 0
	//标准输入
	scanf("%d", &n);//stdin
	//标准输出
	printf("%d\n", n);
# endif
  //stdout stderr
	sprintf(str, "%d.%d.%d.%d", 192, 168, 1, 1);
  //字符串拼接
	printf("str = %s\n", str);
	FILE *fout = fopen("output", "w");
  fprintf(stdout, "stdout = %s\n", str);
	fprintf(stderr, "stdoerr = %s\n", str);
  
  
//stdout（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的I/O操作。 
//stderr（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。
	fprintf(stdout, "stdout = %s", str);
	fprintf(stderr, "stdoerr = %s", str);
  //stdoerr = 192.168.1.1stdout = 192.168.1.1%
  //在Linux环境下我们可以发现第一次会输出stdoerr,
  //是因为stdout将输出的字符串放到了缓冲区当中直到程序结束在将缓冲区中的数据刷新出来。
  fprintf(stdout, "stdout = %s\n", str);
	fprintf(stderr, "stdoerr = %s", str);
  //stdout = 192.168.1.1
	//stdoerr = 192.168.1.1%
  //这个属于stdout输出的第二种情况即遇到换行符(“\n”)时输出,因此在本例中顺序输出了该结果
	return 0;
}
```





# 2.基本运算符



> `&  `   按位与运算符
>
> `^`     异或 ==> 逆运算     自己是自己的逆运算
>
> 0异或任何数，其结果=任何数:0 ^ 0=0,0 ^ 1=1
>
> 1异或任何数，其结果=任何数取反:1 ^ 0=1,1 ^ 1=0
>
> 任何数异或自己，等于把自己置0:x ^ x=0
>
> ​					1 0 1 0
>
> ​	^	  <u>     1 1 1 1</u>      
>
> ​	==>    	0 1 0 1	     ， 
>
> 2^3 = 1   2^1=3  3^1=2
>
> `~`     
>
> ~x  ==> 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0
>
> 



> `<<`,`>>` 左移,右移
>
> 32bit
>
> 左移：
>
> 十进制整数2（0010）  2<<1 ==>(0100) = 4 = 2 * 2
>
>  





`math.h`

1.`pow`函数：指数函数

原型：`double pow(double a, bouble b);`

编译时需要`gcc -o ippanduan 1.pow.c -lm`

2.`sqrt`函数：开平方根函数

原型：`double sqrt(double x);`





`ceil`函数：上取整函数

`double ceil(double x);`

`floor`函数：向下取整



`abs`函数:整数绝对值

头文件：`stdlib.h`

原型：`int abs(int x);`

`fabs`函数：实数绝对值函数

`log`函数：以`e`为底对数函数

`log10`函数：以`10`为底对数函数

- ![formula](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/u=506614216,773713317&fm=58.png)





32bit

int : `2 ^ (-31) ~ 2 ^ 31 - 1`

`n %  2` ==` n & 1`







`!!`逻辑归一化，`!!(x)`,,,如果x=3， `!(x) == 0` `!!(x)== 1`,归一化

`false`  : `null` ,  `0`,`\0`



分支结构：顺序、分支、循环结构



switch 不可以用于double、float



```c
switch(expression) {
    case constant-expression  :
       statement(s);
       break; /* 可选的 */
    case constant-expression  :
       statement(s);
       break; /* 可选的 */
  
    /* 您可以有任意数量的 case 语句 */
    default : /* 可选的 */
       statement(s);
}

```



**循环结构**

> while
>
> while (表达式){
>
> ​	代码块;
>
> }
>
> do{
>
> 代码块;
>
> }  while  (表达式);
>
> 
>
> for (初始化; 循环条件; 执行后操作) {
>
> ​			代码块;
>
> }







# **3.程序流程控制方法**



## 1.短路原则：



> 要使（表达式1）&&（表达式2）运算结果为真则要求：表达式1，表达式2都为真，如果表达式1为假，则不计算表达式2了，因为此时已
> 经确定（表达式1）&&（表达式2）运算结果不可能为真，这就是&&运算的短路特性。

> 要使（表达式1）||（表达式2）运算结果为假则要求：表达式1，表达式2都为假，如果表达式1为真，则不计算表达式2了，因为此时已经
> 确定（表达式1）||（表达式2）运算结果不可能为假，这就是||运算的短路特性。





```C
int a =0;
    int b = 0;
    if( (a++) && (b++)) {
        printf("true a = %d, b = %d \n", a, b);
    }else{
        printf("false a = %d, b = %d \n", a, b);
    }

```

在第一个之后输出的数字输出空格

```c
	for (int i = 0; i < 5; i++){
		//if (i != 0) printf(" ");
	//	if (i) printf(" ");
		i && printf(" ");//逻辑与短路原则
		i == 0 || printf(" ");
		printf("%d", i);
	}
	printf("\n");
```





## 2.随机数

>srand()是随机数种子，s表示seed，种子的意思。

> rand()可以产生0到RAND_MAX(32767)之间的随机数，用rand()%x可以得到0到x之间的随机数。

> srand()和rand()都需要用到stdlib.h。
>
> srand()的种子主要有两种，srand(1)和srand((unsigned)time(NULL))，前者生成的随机数每次都是相等的，后者则是根据现在在走的时间取的随机数，是真随机数。



```c
#include<stdlib.h>
#include<time.h>
//伪随机数，结果固定
int val = rand() % 100;
printf("%d", val);
//伪随机数，结果随机
srand(time(0));
int val = rand() % 100;
printf("%d", val);

```







## 3.取模运算

```c
if (i % 2）//偶数
if (i & 1)//优化

//统计偶数个数
num += (val & 1);


```







## 4.循环结构代码演示





```c
//回文数
#include<stdio.h>
int rev_num(int n){
	if (n < 0) return 0;
	int x = n;
	int temp = 0;
	while (x){
		temp = temp * 10 + x % 10;
		x /= 10;
	}
	return temp == n;
}
int main(){
	int n;
	scanf("%d", &n);
	printf("%s\n", rev_num(n) ? "YES" : "NO");
	return 0;
}
```




```c
//回文数  base进制下的回文数 0110  4 + 2
#include<stdio.h>
int rev_num(int n, int base){
	if (n < 0) return 0;
	int x = n;
	int temp = 0;
	while (x){
		temp = temp * base + x % base;
		x /= base;
	}
	return temp == n;
}
int main(){
	int n;
	scanf("%d", &n);
	printf("%s\n", rev_num(n, 2) ? "YES" : "NO");
	return 0;
}
```





```c
int main(){

	int n;
	scanf("%d", &n);
	
	int x = n;
	int digit = 0;
  while(x){
	 	x /= 10;
	 	digit += 1;
	};
	printf("%d has %d digits !\n",n , digit);
	return 0;
}

//bug 
//0 has 0 digits !
//因为没有执行while循环

int main(){

	int n;
	scanf("%d", &n);
	
	int x = n;
	int digit = 0;
	 do{
	 	x /= 10;
		 digit += 1;
	}while(x);
	printf("%d has %d digits !\n",n , digit);
	return 0;
}
```





## 5.判断日期的合法性

>
>
>#### 题目描述
>
> 给出一个日期，请判断日期的合法性。特别注意一下几点：
>
>1. 年份是负数时，代表公元前，是合法的
>2. 月份和日子是负数是非法的
>3. 2月份要注意判断闰年的情况，闰年的判断标准是：能被4整除但不能被100整除，或者能被400整除
>
>------
>
>#### 输入
>
> 输入 𝑦,𝑚,𝑑y,m,d三个整数，分别代表年月日。
>
>#### 输出
>
> 如果日期合法，输出『Yes』，否则输出『No』。 

```c
#include<stdio.h>

int check(int y, int m, int d){
	if (m <= 0 || m > 12 || d <= 0) return 0;
	int mouth[13] = {0, 31, 28, 31, 30 ,31, 30, 31, 31, 30, 31, 30, 31};
	if ((y % 4 ==0 && y % 100) || y % 400 == 0) mouth[2] += 1;
	return d<= mouth[m];
}

int main(int argc,const char* argv[]){
	int y, m, d;
	scanf("%d%d%d", &y, &m, &d);
	printf("%s\n", check(y, m, d) ?  "YES" : "NO");
	return 0;
}
```









>题目描述
>
>所谓丑数，就是素因子中只含有 2、3、5 的数字。给出一个数字 N，请输出 N 以内所有丑数。特别的规定，1是第一个丑数。
>
>输入一个整数 𝑁（1≤𝑁≤1000）N（1≤N≤1000）
>
>
>
> 从小到达输出 𝑁N 以内的所有丑数，包括 𝑁N，每行输出一个数字 。

------



//***********30

约数定理：N= 2^n+3^n+5^n

```c
#include<stdio.h>
int check(int n){
	while(n % 2 == 0) n/= 2;
	while (n % 3) n/= 3;
	while (n % 5) n/= 5;
	return n == 1;
}
int main(){

	int n;
	scanf("%d",&n);
	for(int i= 1;i <= n; i++){
		if (!check(i)) continue;
		printf("%d\n", i);
	
	}
	
	return 0;
}
```





>`n % 2 ==0 ==> n & 1 ==0`      3%2  3&1
>
>​	0 0 1 1
>
>& 0 0 1 0
>
>-------------
>
>​	0 0 1 0 
>
>3 = 2^1 + 2^0  结果值与最后一位有关系
>
>`n % 4 == 0 => n & 3 == 0`
>
>`n % 4` :  结果值有：0 1 2 3
>
>​	0 1 0 0
>
>   0 0 1 1
>
>-------------
>
>​	0 0 1 0 
>
>`n % 6` !==>任何东西,转换成二进制后，前面的数，不一定都能被6整除
>
>`n % 7`
>
>`n % 8`==> `n & 7`
>
>`n % 16`==> `n & 15`
>
>







# 4.函数

## 1.函数

在没有特殊函数情况下C/C++函数开始的入口是main函数

> 函数:压缩了的数组
>
> 数组是展开的函数



## 2.递归

> 递归：
>
> ​		程序调用自身的变成技巧



递归程序的组成部分：

​		1.边界条件处理

​		2.针对问题的处理过程和递归过程

​		3.结果返回



## 3.函数指针





```c
int f(int (*f1)(int), int (*f2)(int), int (*f3)(int), int x) {
  if(x < 0){
    return f1(x);
  }
  if(x < 100){
    return f2(x);
  }
  return f3(x);
  
}
```



函数指针的应用：分段函数

二分查找

`(head + tail) / 2 等价于 (head + tail) >> 1` 

```c
int binary_search(int *num, int n, int x){
	int head = 0;
	int tail = n - 1;
	int mid;
  while (head <= tail) {
    mid = (head + tail) / 2;
    //mid = (head + tail) >> 1;
    if(num[mid]==x) return mid;
    if(num[mid] < x) head = mid + 1;
    else tail = mid - 1;
  }
  return -1;
```







`*(num)(long long)`函数指针

```c
#include <stdio.h>

long long Triangle(long long n) {
    return n * (n + 1) / 2;
}

long long Pentagonal(long long n) {
    return n * (3 * n - 1) / 2;
}

long long Hexagonal(long long n) {
    return n * (2 * n - 1);
}

long long binary_search(long long (*num)(long long), long long n, long long x) {
    long long head = 0, tail = n - 1, mid;
    while (head <= tail) {
        mid = (head + tail) >> 1;
        if (num(mid) == x) return mid;
        if (num(mid) < x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1;
}

int main() {
    int n = 285;
    while (1) {
        n++;
        long long val = Triangle(n);
        if (binary_search(Pentagonal, val, val) == -1) continue;
        if (binary_search(Hexagonal, val, val) == -1) continue;
        printf("%lld\n", val);
        break;
    }
    return 0;
}
```





## 4.欧几里得算法

辗转相除法(计算两个数字的最大公约数)



 

`while(~scanf())`:`~`按位取反,`scanf`返回值为-1时值不合法，-1（1111...1111）,-1按位取反结果为0循环终止





```c
#include<stdio.h>
int gcd(int a, int b) {
//	if (!b) return a;//==>	if (b == 0) return a;
//	return gcd(b, a % b);
	return (b ? gcd(b, a % b) : a);
}

int main(int argc,const char* argv[]){
	int a, b;
	while(~scanf("%d%d", &a, &b)) {
		printf("gcd(%d, %d) = %d\n", a, b, gcd(a, b));
	}
	return 0;
}
```



扩展：关键字`inline`内联函数

可能使函数调用更快，减少函数调用开销，递归函数和复杂的循环不能使用`inline`





## 5.扩展欧几里得算法



快速求解`ax+by=1`的方程组的一组整数解



```c

```



## 6.变参函数

实现可变参数 max_int ，从若干个参数中返回最大值

​	`int max_int(int a, ...);`

如何获得a往后的参数列表？va_list类型的变量

如何定位a后面第一个参数的位置？va_start函数

如何获取下一个可变参数列表中的参数？va_arg函数

如何结束整个获得整个可变参数列表的动作？va_end函数



```c

#include <stdio.h>
#include <inttypes.h>
#include <stdarg.h>

int max_int(int n, ...){
	int ans = INT32_MIN;//32位极小值
	va_list arg;//...参数与列表
	va_start(arg, n);
	while (n--){
		int temp = va_arg(arg, int);
		if (temp > ans) ans = temp;
	}
	va_end(arg);
	return ans;
}


int main() {
	printf("%d\n", max_int(3, 1, 2, 3));
	printf("%d\n", max_int(5, 1, 13, 3, 4, 7));
	printf("%d\n", max_int(5, 1, 13, 3, 4, 7, 21));
	return 0;
}

3
13
13
21a
```



## 7.简版printf函数实现



```c
#include <stdio.h>

int my_printf(const char *frm, ...) {
    int cnt = 0;
    for (int i =0; frm[i]; i++){
        putchar(frm[i]);
        ++cnt;
    }
    return cnt;
}

int main() {
    printf("hello, world!\n");
    printf("my_printf = %d\n", my_printf("hello, world!\n"));
    return 0;
}
```



`const  char *frm` frm的值为常量

const字符串字面量

传入变量也没有任何影响

 

```c

#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>

int my_printf(const char *frm, ...) {
    int cnt = 0;
    va_list arg;
    va_start(arg, frm);
    #define PUTC(a) putchar(a),++cnt

    for (int i =0; frm[i]; i++) {
        switch (frm[i]) {
        case '%': {
                      switch (frm[++i]) {
                      case '%':  PUTC(frm[i]);    break;
                      case 'd':{
                                  int x = va_arg(arg, int);
                                  if (x < 0) PUTC('-'),x = -x;
                                  int temp = 0;
                                  int digit = 0;
                                   do {
                                      temp = temp * 10 + x % 10;
                                      x /= 10;
                                      ++digit;
                                  } while(x);
                                  while (digit--) {
                                      PUTC(temp % 10 + '0');
                                      temp /= 10;
                                  }
                                  break;
                        }
                     }
                      break;
                }
            default : {PUTC(frm[i]); break;}
        }
       // putchar(frm[i]);

    }

    #undef PUTC
    va_end(arg);

    return cnt;
}

int main() {
    printf("printf == > hello, world!\n");
    printf("my_printf ==> %d\n\n", my_printf("hello, world!\n"));

    int a = 123;
    printf("int (a) = %d\n", a);
    my_printf("my_printf ==> int (a) = %d\n\n", a);

    printf("int (0) = %d\n", 0);
    my_printf("my_printf ==> int (0) = %d\n\n", 0);


    printf("int (10000) = %d\n", 10000);
    my_printf("my_printf ==> int (10000) = %d\n\n", 10000);

    printf("int (-123) = %d\n", -123);
    my_printf("my_printf ==> int (-123) = %d\n\n", -123);
    return 0;
}
```





优化



```c

#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>

int reverse_num(int x,int *temp) {
    int digit = 0;
    do {
        digit++;
        *temp = *temp * 10 + x % 10;
        x /= 10;
    } while (x);
    return digit;
}

int output_num(int num, int digit) {
    int cnt = 0;
    while(digit--) {
        putchar(num % 10 + '0');
        cnt++;
        num /= 10;
    }
    return  cnt;
}

int my_printf(const char *frm, ...) {
    int cnt = 0;
    va_list arg;
    va_start(arg, frm);
    #define PUTC(a) putchar(a),++cnt

    for (int i =0; frm[i]; i++) {
        switch (frm[i]) {
        case '%': {
                      switch (frm[++i]) {
                      case '%':  PUTC(frm[i]);    break;
                      case 'd':{
                        int x = va_arg(arg, int);
                        uint32_t xx = 0;
                        if (x < 0) PUTC('-'),xx = -x;
                        else xx = x;
                        int x1 = xx / 100000, x2 = xx % 100000;
                        int temp1 = 0, temp2 = 0;
                        int digit1 = reverse_num(x1, &temp1);
                        int digit2 = reverse_num(x2, &temp2);
                        int digit3 = 0;
                        if (x1) digit3 = 5 - digit2;
                        else digit1 = 0;
                        cnt += output_num(temp1, digit1);
                        cnt += output_num(0,digit3);
                        cnt += output_num(temp2, digit2);
                        } break;
                      case 's': {
                          const char *str = va_arg(arg, const char *);
                          for (int i = 0; str[i]; i++) {
                                PUTC(str[i]);
                          }
                               }
                      }
                      break;
                }
            default : {PUTC(frm[i]); break;}
        }

    }

    #undef PUTC
    va_end(arg);

    return cnt;
}

int main() {
    printf("printf == > hello, world!\n");
    printf("my_printf ==> %d\n\n", my_printf("hello, world!\n"));

    int a = 123;
    printf("int (a) = %d\n", a);
    my_printf("my_printf ==> int (a) = %d\n\n", a);

    printf("int (0) = %d\n", 0);
    my_printf("my_printf ==> int (0) = %d\n\n", 0);


    printf("int (10000) = %d\n", 10000);
    my_printf("my_printf ==> int (10000) = %d\n\n", 10000);

    printf("int (10050) = %d\n", 10050);
    my_printf("my_printf ==> int (10050) = %d\n\n", 10050);

    printf("int (-123) = %d\n", -123);
    my_printf("my_printf ==> int (-123) = %d\n\n", -123);

    printf("int (INT32_MAX) = %d\n", INT32_MAX);
    my_printf("my_printf ==> int (INT32_MAX) = %d\n\n", INT32_MAX);

    printf("int (INT32_MIN) = %d\n", INT32_MIN);
    my_printf("my_printf ==> int (INT32_MIN) = %d\n\n", INT32_MIN);

    char str[] = "I love China";
    printf("(str) = %s\n", str);
    my_printf("my_printf ==> str = %s\n\n", str);


    int n;
    while (~scanf("%d", &n)) {
        printf(" has %d digits!\n", printf("printf %d", n) - 7);
        my_printf(" has %d digits!\n\n", my_printf("my_printf %d", n) - 10);

    }
   return 0;
}
```









# 5.数组 



## 1.数组声明与初始化



`int arr[100] = {0}`数组清空,只有={0}时，全部的数组才能被初始化为0，

静态数组在内存栈区（8M）

动态数组molloc，calloc，rolloc



数组是展开的函数



## 2数组的运用

### 素数筛

时间复杂度`O(N* loglogN)`趋近于`O(N)`

> 思想：用素数标记掉不是素数的数字，例如我知道了i是素数，那么`2*i`，`3*i`...不是素数





```c
#include<stdio.h>
#define max_n 100

int prime[max_n + 5] = {0};
void init() {
	for (int i = 2; i <= max_n; i++) {
		if (prime[i]) continue;//if (prime[i] == 1){}
		for (int j = 2 * i; j <= max_n; j += i) {
				prime[j] = 1;
		}
	}
}
int main(int argc,const char* argv[]){
	init();
	for (int i = 2; i <= max_n; i++) {
		if (prime[i]) continue;
		printf("%d\n", i);
	}
	return 0;
}
```



**优化**

```c
#include<stdio.h>
#define max_n 10000

int prime[max_n + 5] = {0};
void init() {
	for (int i = 2; i <= max_n; i++) {
		if (prime[i]) continue;
		prime[++prime[0]] = i;///******!!!
		for (int j = i * i; j <= max_n; j += i) {
      //当 i = 10000是发生溢出
				prime[j] = 1;
		}
	}
}
int main(int argc,const char* argv[]){
	init();
	for (int i = 2; i <= prime[0]; i++){
		printf("%d\n", prime[i]);
	}
	return 0;
}
```



> `prime[++prime[0]] = i;`
>
> 会不会出现已经存储的还没有被标记
>
> 标记的速度很快，标记一群存储一个
>
> 3是素数，4是偶数，基数偶数相邻，除2以外，偶数都不是素数，





### 线性筛

时间复杂度O(n)



```c

#include<stdio.h>
#define max_n 10000

int prime[max_n + 5];

void init() {
	for (int i = 2; i <= max_n; i++) {
		if (!prime[i]) prime[++prime[0]] = i;
    //如果没有值，给他前面一个合数赋值
		for (int j = 1; j <= prime[0]; j++) {
			if (prime[j] * i > max_n) break;
			prime[prime[j] * i] = 1;
			if (i % prime[j] == 0) break;
		}
	}
}

int main(int argc,const char* argv[]){
    init();
	for (int i = 1; i <= prime[0]; i++) {
		printf("%d\n", prime[i]);
	}
	printf("prime[0] = %d\n", prime[0]);
	return 0;
}
```









## 3.折半查找/二分查找







数组转函数，剩下开辟数组空间的时间，时间换空间



```c
#include <stdio.h>

int binary_search(int (*arr)(int), int x, int n) {
    int head = 0;
    int tail = n - 1;
    int mid ;
    while (head <= tail) {
        mid = (tail + head ) / 2;
        if (arr(mid) == x) return mid;
        if(arr(mid) > x) {
            mid -= 1;
            tail = mid;
        }
        else {
            mid += 1;
            head = mid;
        }
    }

    return -1;
}

int binary_search1(int *arr, int x, int n) {
   int head = 0;
   int tail = n - 1;
   int mid;
   while(head <= tail) {
       mid = (head + tail) >> 1;
       if (arr[mid] == x) return mid;
       if (arr[mid] < x) head = mid + 1;
       else tail = mid - 1;
   }

    return -1;
}
int func(int x) {
    return x * x;
}
int main()
{
    int arr[100] = {0};
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
       arr[i] = i * i;
       //scanf("%d", &arr[i]);
    }
    int x;
    while(~scanf("%d", &x)) {
        printf("binary_search ==>%d\n", binary_search(func, x, n));

        printf("binary_search1==> %d\n", binary_search1(arr, x, n));
    }

    return 0;
}
```





>(2 + 4) / 2
>
>0010
>
>0100
>
>0111   ==>    >>1   == 0011 = 3  ,最后一位为1或0，
>
>



折半查找实现平方根



```c
#include <stdio.h>
#include <math.h>

double func(double x) {
    return x * x;
}

double binary_search(double (*arr)(double), double n) {
    double head = 0;
    double tail = n;
    double mid;

    if (n < 1.0) tail = 1.0;
    #define EPLS 1e-8
    while (tail - head > EPLS) {
        mid = (head + tail) / 2.0;
        if(arr(mid) < n) head = mid;
        else tail = mid;
    }
    #undef EPLS
    return head;

}

int main()
{
    double n;
    scanf("%lf", &n);
    printf("my_sqrt(%lf) = %g\n", n, binary_search(func, n));
    printf("sqrt(%lf) = %g\n", n, sqrt(n)) ;
    return 0;
}
```



## 4.牛顿迭代



> x2= x1 - (f(x1))/f`(x1)





牛顿迭代递推式：

![截屏2020-12-10 上午9.47.46](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-10%20%E4%B8%8A%E5%8D%889.47.46.png)









```c
#include <stdio.h>
#include <math.h>
double func(double x, double n) {
    return x * x - n;
}

double f(double x) {
    return 2 * x;
}

double NewTon(double (*F)(double,double), double (*f)(double), double n) {
    double x = n / 2.0;
    #define EPSL 1e-7
    while (fabs(F(x, n)) > EPSL) {
        x -=  F(x, n) / f(x);
    }
#undef EPSL
    return x;
}
double my_sqrt(double n) {
    return NewTon(func, f, n);
}
int main()
{
    double n;
    scanf("%lf", &n);
    printf("sqrt(%g) ==>%g\n", n, sqrt(n));
    printf("my_sqrt(%g) ==> %g\n", n, NewTon(func, f, n));
    printf("mysqrt %g==> %g\n", n, my_sqrt(n));

    return 0;
}
```









## 5.数组代码演示

静态数组 int arr[100];，存放在栈区

动态数组 通过molloc动态开辟空间 ，存放在堆区





```c
#include <stdio.h>
#define max_n 100



int arr[max_n +5];
//当将数组放在main函数外面的时候，数组的默认值为0
int main(){
  
    //变量存放在栈区
    int arr[max_n +5] = {0};//静态数组
    //将arr的每一位值都初始化为0，不过不初始化为0，默认值不一定为0
    //函数内部申明变量，放在栈区 8MB，初始化值太大会发生爆栈
  	
  
    scanf("%d", &n);
    //为什么传地址：
  	//程序的功能逻辑需要传变量的地址，
    //通过scanf写入值，通过scanf函数改变函数外部变量的值，需要传入地址
  	//传出参数
    for (int i = 0; i < n; i++) {
        //scanf("%d", &arr[i]);
        //等价于
        scanf("%d", arr + i);
        
    }
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
  	return 0;
  
}                                                                                            
```







## 6.数组传参



```cpp
#include <stdio.h>
#define max_n 100
  
    //printf("%d\n",arr[10];
int main(){
  	
  
  	int arr[max_n +5] = {0};
    
  	//105 * 4 = 420 bit
    int n;
   
    printf("sizeof(arr) = %lu\n", sizeof(arr));
    //420 , 4 * 105 = 420
    //sizeof(arr)输出arr的所占空间大小
  
    printf("arr = %p, &arr[0] = %p\n", arr, &arr[0]);//arr == &arr[0]
    printf("arr[1] = %p\n", &arr[1]);
    char str[max_n + 5];
    printf("str = %p, str + 1 = %p\n", str, str + 1);//1bit
    //arr[1] - arr[0] ==> 4bit,1个int  4 bit
  	// arr + 1 跳跃一个元素（（int）bit））的大小 
    //double 8 bit
/*
    int32_t <==> int  4 bit
    long / long long 64 bit
    int64_bit <inttypes.h>
 */   
  	
    return 0;
}                          
```









```cpp
#include <stdio.h>
#define max_n 100

void func(int *num) {
    //1.指针变量也是变量，存储地址，指针存储地址
    //2.传出参数，希望外部的函数也可以访问改变的变量
    
  
  	printf("sizeof(num) = %lu\n", sizeof(num));
  	//num=8bit   arr=420bit
   	//那出传进来的是数组还是指针变量，
    //num表现形式是指针，int类型指针，64位系统占8bit，所以传进来的是一个指针变量，
  	//num接收数组首地址
  
  	//表现形式一致性
  	//num arr不一样，表现形式一致，
    //arr + i 通过地址访问arr[i],,num+i可以访问nnum[i]
  	printf("num = %p, num + 1 = %p\n", num, num + 1);
  	//(num + 1) - num = 4 bit
    //(arr + 1) - arr = 4 bit  ===>表现形式一致
    
}

void func1(int *n) {
  //*n = 123;
  //等价于
  n[0] = 1234;
}


int main(){

    int arr[max_n +5] = {0};
  	printf("sizeof(arr) = %lu\n", sizeof(arr));
  	//420bit
    func(arr);
    
    n = 0;
    printf("n = %d\n", n);//0
    scanf("%d", &n);
    printf("n = %d\n", n);//
    func1(&n);
    printf("n = %d\n", n);//*n=123   n[0]=1234
    return 0;

}
```





二维数组传参

```cpp
#include <stdio.h>


void func(int (*num)[4]) {// num -> int[4]
    printf("arr = %p, arr + 1 = %p\n", num, num + 1);//16bit
}
void func1(int **num) {
    printf("num = %p, num + 1 = %p\n", num, num + 1);//8 bit
}
int main()
{
    int arr[2][4] = {0};

    func(arr);
    printf("arr = %p, atrr + 1 = %p\n", arr, arr + 1);//16bit
    int **num;//指针的指针

    func1(num);//8 bit 

    return 0;
}


```







![截屏2020-12-11 下午3.26.43](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-11%20%E4%B8%8B%E5%8D%883.26.43.png)







高维数组传参，省略最前面的一个

![截屏2020-12-11 下午3.42.42](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-11%20%E4%B8%8B%E5%8D%883.42.42.png)







# 6.预处理命令

预处理命令-宏定义



> 以`#`开头的都是C语言的预处理命令





## 1.定义符号常量

`#define PI 3.14`

`#define MAX_N 10000`





## 2.定义傻瓜表达式

`#define MAX(a,b) (a) > (b) ? (a) : (b)`

`#define S(a, b) a  * b`

> 
>
> `==> S(1 + 3, 4 + 2)  == 1 + 4 * 4 + 2`
>
> ​                                                `!= (1 + 3) * (4 + 2)`

> **宏：仅做符号替换，不做计算,只可以定义一行**





## 3.定义代码段 



> `#define P(a) {\`
>
> ``printf("%d\n", a);\`
>
> `}`
>
> `\`连接符,分行写,将当前行的代码与下一行的代码连接



## 4.预处理命令-预定义宏



|           宏           | 说明                          |
| :--------------------: | ----------------------------- |
|       `__DATE__`       | 日期：M mm dd yyyy            |
|       `__TIME__`       | 时间：hh:mm:ss                |
|       `__LINE__`       | 行号                          |
|       `__FILE__`       | 文件名                        |
|       `__func__`       | 函数名/***非标准***           |
|       `__FUNC__`       | 函数名/***非标准***           |
| `__PRETTY__FUNCTION__` | 更详细的函数信息/***非标准*** |





`__DATE__  、__TIME__`：编译时的日期

非标准：在不同的环境下名字可能不同



可以做：

确定最后一次编译时的时间

行号、文件、文件名：打印日志功能





## 5.预处理命令-条件式编译



|        函数        | 说明                                                |
| :----------------: | :-------------------------------------------------- |
|   `#ifdef DEBUG`   | 是否定义了DEBUG宏，作用于当前宏后面的代码           |
|   `#ifdef DEBUG`   | 是否没定义DEEBUG宏                                  |
|  `#if MAX_N == 5`  | 宏MAX_N是否等于5，MAX_N是宏不是变量，作用时期不一样 |
| `#elif MAX_N == 4` | 否则宏MAX_N是否等于4                                |
|      `#else`       |                                                     |
|      `#endif`      | //结束宏                                            |





> MAX_N不是变量是宏，
>
> 条件式编译解决非标准预定义宏，实现代码剪裁







![截屏2020-12-14 上午10.27.57](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8A%E5%8D%8810.27.57.png)





> C源文件：vim a.cpp
>
> ↓（预处理阶段 ： 处理预处理命令，将所有的预处理预处命令进行展开和替换，生成代码）
>
> 编译源码 ： 编译期
>
> ↓(一个.c/.cpp生成一个对象(.o/.obj)文件，如果有多个.cpp文件会生成多个对象文件)
>
> 对象文件： 生成.o/.obj(win)文件
>
> ↓链接期：链接过程(所有的对象文件生成一个可执行文件)
>
> 可执程序： 默认生成a.out（可被执行的二进制文件）
>
> 
>
> 预处理期 →编译期 →链接期





 

> 练习1:**实现打印LOG函数，需要输出所在函数及行号等信息**



```c
#include <stdio.h>

//#define DEBUG
#ifdef DEBUG
#define log(frm ,args...) {\
    printf("%s ==> %s : %d]", __FILE__, __func__, __LINE__);\
    printf(frm, ##args);\
}

#else
#define log(frm, args...)
#endif

//#args将args(任意类型都可)转换为字符串
//如果lon传入的参数为1个，变参列表就为空，编译器会报警告，too manny argument..
//##args连接，如将a和b连接为ab，连接时后面的可以为空

//#define concat(a, b) a##b
//如果去掉##，写ab的意思是将a、b变量替换成字符ab

int main()
{

    int a = 123;
    printf("printf==>hello 古子秋\n");
    log("log==>hello apricity\n");
    log("lon(a)==>%d\n", a);
    int abc = 2;
    int def = 3;
    int abcdef = 0;
//    concat(abc, def) = 234;
//    log("abcdef = %d\n", abcdef);

    return 0;
}

```



`g++ -DDEGBUG  32.LOG.c`





> 练习二：**实现没有BUG的MAX宏，需要通过如下测试**
>
> 1、MAX(2, 3)//3
>
> 2、 5 + MAX(2, 3)//8
>
> 3、MAX(2, MAX(3, 4))//4
>
> 4 、MAX(2, 3 > 4 ? 3 : 4)//4
>
> 5、 MAX(a++, 6), a = 7,return 8,a= 8//



`gcc -E 28.max.c`将所有的预处理命令展开生成代码



`__typeof(a)`获取a的类型

int a   == > typeof(int) 



```c
#include <stdio.h>

#define MAX(a,b) a > b ? a : b
//debug1提升优先级
#define MAX(a,b) (a > b ? a : b)
//debug2加上括号，防止与后面的内容发生关联
#define MAX(a,b) ((a) > (b) ? (a) : (b))
//debug3   
#define MAX(a,b) ({\
    __typeof(a) _a = (a);\
    __typeof(b) _b = (b);\
    _a > _b ? _a : _b;\
                  })

//__typeof(a) 根据值替换为该值的类型

#define P(func) {\
    printf("%s = %d\n", #func, func);\
}
//#func将func里面的内容转换为字符串

int main() {

    int a = 7;
    P(MAX(2, 3));
    P(5 + MAX(2, 3));
    P(MAX(2, MAX(3, 4)));

    P(MAX(2, 3 > 4 ? 3 : 4));
    P(MAX(a++, 6));
    P(a);


    return 0;
}

//gcc -E 28.max.c


int main() {

    int a = 7;
    { printf("%s = %d\n", "MAX(2, 3)", 2 > 3 ? 2 : 3);};
    { printf("%s = %d\n", "5 + MAX(2, 3)", 5 + 2 > 3 ? 2 : 3);};
  //(5 + 2) > 3 ? 2 : 3 = 7 > 3 ? 2 ； 3 = 2  ！！！！！！！
	//5 + (2 > 3 ? 2 : 3) = 5 + 3 = 8
  { printf("%s = %d\n", "MAX(2, MAX(3, 4))", 2 > 3 > 4 ? 3 : 4 ? 2 : 3 > 4 ? 3 : 4);};

    { printf("%s = %d\n", "MAX(2, 3 > 4 ? 3 : 4)", 2 > 3 > 4 ? 3 : 4 ? 2 : 3 > 4 ? 3 : 4);};
  //2 > 3 > 4 ? 3 : 4 ? 2 : 3 > 4 ? 3 : 4
  // 0 > 4 ? 3 : 4 ? 2 : 3 > 4 ? 3 : 4
  //4 ? 2 : 3 > 4 ? 3 : 4
  //2
  //与后面的内容发生关联
    { printf("%s = %d\n", "MAX(a++, 6)", a++ > 6 ? a++ : 6);};
  //a增加了两次  debug，将a++替换出来，
    { printf("%s = %d\n", "a", a);};


    return 0;
}



./a.out 

MAX(2, 3) = 3//√
  //debug1
5 + MAX(2, 3) = 2//×   =8
   //debug2
MAX(2, MAX(3, 4)) = 2//× 4
MAX(2, 3 > 4 ? 3 : 4) = 2//× 4
  //debug3
MAX(a++, 6) = 8
a = 9
```



```c
#include <stdio.h>

#define MAX(a,b) ({\
    __typeof(a) _a = (a);\
    __typeof(b) _b = (b);\
    _a > _b ? _a : _b;\
                  })

#define P(func) {\
    printf("%s = %d\n", #func, func);\
}

int main() {

    int a = 7;
    P(MAX(2, 3));
    P(5 + MAX(2, 3));
    P(MAX(2, MAX(3, 4)));

    P(MAX(2, 3 > 4 ? 3 : 4));
    P(MAX(a++, 6));
    P(a);
    return 0;
}
```





debug后

```c
gcc -E 28.max.c
  
int main() {

    int a = 7;
    { printf("%s = %d\n", "MAX(2, 3)", ({ __typeof(2) _a = (2); __typeof(3) _b = (3); _a > _b ? _a : _b; }));};
    { printf("%s = %d\n", "5 + MAX(2, 3)", 5 + ({ __typeof(2) _a = (2); __typeof(3) _b = (3); _a > _b ? _a : _b; }));};
    { printf("%s = %d\n", "MAX(2, MAX(3, 4))", ({ __typeof(2) _a = (2); __typeof(({ __typeof(3) _a = (3); __typeof(4) _b = (4); _a > _b ? _a : _b; })) _b = (({ __typeof(3) _a = (3); __typeof(4) _b = (4); _a > _b ? _a : _b; })); _a > _b ? _a : _b; }));};

    { printf("%s = %d\n", "MAX(2, 3 > 4 ? 3 : 4)", ({ __typeof(2) _a = (2); __typeof(3 > 4 ? 3 : 4) _b = (3 > 4 ? 3 : 4); _a > _b ? _a : _b; }));};
    { printf("%s = %d\n", "MAX(a++, 6)", ({ __typeof(a++) _a = (a++); __typeof(6) _b = (6); _a > _b ? _a : _b; }));};
    { printf("%s = %d\n", "a", a);};


    return 0;
}

./a.out 
  
MAX(2, 3) = 3
5 + MAX(2, 3) = 8
MAX(2, MAX(3, 4)) = 4
MAX(2, 3 > 4 ? 3 : 4) = 4
MAX(a++, 6) = 7
a = 8
```











> **函数从哪里开始????**



```c
#include <stdio.h>

__attribute__((constructor))
int add(int a, int b) {
    printf("add : %d\n", __LINE__);
    return a + b;
}

int main()
{
    printf("main : %d\n", __LINE__);
    add(2,3);
    return 0;
}

```



>add : 5
>main : 11
>add : 5



> 默认情况下从main函数开始执行
>
> `__attribute__((constructor))`    
>
> :  预处理命令——宏，给函数增加一个属性，使下面的函数先于主函数执行







宏嵌套

宏支持嵌套，可能会出现停止展开的现象

输出带颜色的符号

宏的作用：作用时期早，不涉及调用函数时间损耗

```c
#include <stdio.h>

#define COLOR(a,b) "\033[" #b "m" a "\033[0m"
//a本身就是一个字符串
//进行字符串拼接，
#define RED(a) COLOR(a, 31)
#define GREEN(a) COLOR(a, 32)
//宏所有的事情只是简单的替换、

__attribute__((constructor))
int add(int a, int b) {
    printf(RED("add : %d\n"), __LINE__);//输出红色
    return a + b;
}

int main()
{
    printf(GREEN("main : %d\n"), __LINE__);//输出绿色
    add(2,3);
    return 0;
}


```



运行结果：

![截屏2020-12-12 下午6.51.55](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-12%20%E4%B8%8B%E5%8D%886.51.55.png)







> 泛型宏？



# 7.字符串





定义字符串数组：`char str[size];`



初始化字符数组：

> `char str[ ] = "hello world";`
>
> //str占多少字节：一个字符一个字节，12个（11 + '\0'）长度为11
>
> `char str[size] = {'h', 'e', 'l', 'l', 'o'};`



\0 == 0

头文件`string.h`



| 函数                      | 说明                              |
| ------------------------- | --------------------------------- |
| `strlen(str)`             | 计算字符串长度，以'\0'作为结束符  |
| `strcmp(str1, str2);`     | 字符串比较，cpmpare               |
| `strcpy(dest, src);`      | 字符串拷贝copy(假如字符\0丢失)    |
| `strncmp(str1, str2, n);` | 安全的字符串比较                  |
| `strncpy(str1, str2, n);` | 安全的字符串拷贝(拷贝n个)         |
| `memcpy(str1, str2, n);`  | 内存拷贝(str2拷贝到str1，拷贝n位) |
| `memcmp(str1, str2, n);`  | 内存比较                          |
| `memset(str1, c, n);`     | 内存设置(str每一个字节设置为c)    |





> `strcmp(str1, str2);`  字符串比较
>
>   `strcpy(dest, src);`  字符串拷贝
>
> `strncmp(str1, str2, n);`  `安全的字符串比较` 
>
>  `strncpy(str1, str2, n);`  `安全的字符串拷贝`
>
> 字符串拷贝
>
> src 拷贝到 str，src字符\0丢失，会一直拷贝
>
> 如果'\0'丢失，strncpy会拷贝到第n位
>
>  







| 函数                         | 说明                 |
| ---------------------------- | -------------------- |
| `sscanf(str1, format, ...);` | 从字符串str1读入内容 |
| `sprintf(str1,fromat, ...);` | 将内容输出到str1     |





`fscanf`从文件读入

`fprintf`读入到文件



> 练习：使用字符串相关操作，计算一个整型16进制表示的位数



```c
#include <stdio.h>
#include <string.h>
 
int main()
{
    char str[11] = {0};
    int n;
    while(~scanf("%d", &n)) {
        sprintf(str, "%x", n);
      //将n转换为16进制，以字符串的形式读入str
      //%X和%x的区别，%X输出结果为字母时是大写，%x是小写
        printf("%s has %lu digits!\n", str, strlen(str));//输出str长度即为16整型的位数
    }
 
    return 0;
}
```







> 注：
>
> %c读入单个字符，可以读入任何字符，包括空格符和换行，
>
> %s读入一个字符串
>
> %c循环读入的时候发生错误，会将换行和空格符读入
>
> 解决办法：以字符数组str[10]的形式以%s读入字符串，输出str[0]即可
>
> 



![截屏2020-12-14 下午8.39.08](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-14%20%E4%B8%8B%E5%8D%888.39.08.png)













# 8.复杂结构体





## 1.结构体struct



```c
struct person {// struct + 结构体名字
	char name[20];	//姓名			20bit
	int age;				//年龄			4
	char gender;		//性别			1
	float height;		//身高			4
};
```





> struct person 			 // 结构体类型，没有结构体的名字时，称为匿名结构体
> struct person stu;	//结构体类型的变量
> stu.age;						//`.`直接引用，通过类型的变量直接访问用'`.`'直接访问
> stu->age;					//`->`间接引用，需要通过地址访问地址下某一字段的值，需要间接访问
> struct person *p;
> p = &stu;
> p->age;







>//结构体空间划分标准：对齐标准
>	
>
>```c
>char name[20];	//姓名			1bit  5块
>int age;				//年龄			4			1
>char gender;		//性别			1			1	
>float height;		//身高			4			1	
>```
>
>对齐标准：
>
>按照对齐标准的整数倍开辟空间，
>
>哪个**类型**所占空间字节数大就作为对齐标准，
>
>以4bit为标准开辟空间，
>
>name  20bit	→ 开辟连续的五块4bit空间
>
> 一共开辟8 * 4 = 32bit



>```c
>char name[20];	//姓名			1bit  3块(24 = 20 + 4)
>int age;				//年龄			4			0(age用name剩下的4bit)
>char gender;		//性别			1			1	
>double height;	//身高			8			1	
>```
>
>5 * 8 = 40bit





对齐标准不是固定的

>```c
>struct node1 {
>	char a;		//1（4bit（使用了1bit剩下3bit））
>	char b;		//0(使用开辟a时剩下的1bit)
>	int c;		//1
>}
>struct node2 {
>  char a;			//1
>  int c;			//1
>  char b;			//1
>}
>```
>
>node1   8bit
>
>node2	12bit
>
>划分空间时从上至下依次划分空间
>
>==>相同类型的字段放在一起排布，可以节省空间



宏：强制改变对齐方式



对齐的作用，方便访问





## 2.共用体/联合体

> 共用体：当前公用体内的各个字段共用一片存储单元



> 共用体的大小就是共用体内所有字段中所占空间最大的字段



```c
union reginster {
		struct {
				unsigned char byte1;	//1bit
				unsigned char byte2;	
				unsigned char byte3;
				unsigned char byte4;
		} bytes;
  unsigned int number;				//4bit
}																//共用体占4bit
```



![截屏2020-12-18 上午1.47.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-18%20%E4%B8%8A%E5%8D%881.47.10.png)





找占空间最大的作为整个共用体的标准



![截屏2020-12-16 下午11.47.50](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8B%E5%8D%8811.47.50.png)

改变bytes的值，number也会改变





共用体的作用

使用共用体实现ip转整数

```c
#include <stdio.h>

union IP {
    struct {
        unsigned char a1;
        unsigned char a2;
        unsigned char a3;
        unsigned char a4;
    } ip;
    unsigned int num;
};


int main()
{
    union IP p;
    char str[100] = {0};
    int arr[4];
    while (~scanf("%s", str)) {//输入
        sscanf(str, "%d.%d.%d.%d", arr, arr + 1, arr + 2, arr + 3);
      //将str中的字符串以%d格式读如到arr中
        p.ip.a1 = arr[0];
        p.ip.a2 = arr[1];
        p.ip.a3 = arr[2];
        p.ip.a4 = arr[3];
        printf("%u\n", p.num);
      //由于是共用体，四个unsigned char类型和unsigned int类型占空间一样
    }
    return 0;
}


192.168.0.1
16820416
192.168.0.2
33597632

```



![截屏2020-12-18 上午1.47.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-18%20%E4%B8%8A%E5%8D%881.47.24.png)





> 大端小端
>
> 小端机：数字低位→存储在低地址位   
>
> 大端机：数字低位→存储在高地址位   
>
> 内存地址以字节为单位编址，
>
> 

![截屏2020-12-17 上午12.14.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%8812.14.10.png)







![](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%8812.15.56.png)





```c
#include <stdio.h>

union IP {
    struct {
        unsigned char a1;
        unsigned char a2;
        unsigned char a3;
        unsigned char a4;
    } ip;
    unsigned int num;
};


int main()
{
    union IP p;
    char str[100] = {0};
    int arr[4];
    while (~scanf("%s", str)) {
        sscanf(str, "%d.%d.%d.%d", arr, arr + 1, arr + 2, arr + 3);
        p.ip.a1 = arr[3];
        p.ip.a2 = arr[2];
        p.ip.a3 = arr[1];
        p.ip.a4 = arr[0];
      //反向存储，小端机数字低位→存储在低地址位   
      //将ip地址首位存到低地址位上
        printf("%u\n", p.num);
    }
    return 0;
}



192.168.0.1
3232235521
192.168.0.2
3232235522
```





```c
//判断大端机还是小端机

#include <stdio.h>
int is_little() {
  int num = 1;
  return ((char *)(&num))[0];
  //将num强制转换为char类型，取其低位地址，如果为1则为小端机
}

int main() {
  printf("%d\n", is_little());
  //返回1，小端机,返回0大端机
  return 0;
}
```







# 9.指针

## 0.指针含义

> 指针：变量的地址



> 64位操作系统指针占8字节，32问操作系统占4字节



> 指针变量也是变量：是变量就可以存储值，指针变量存储地址，变量本身也有地址
>
> 指向整型的指针变量占8个字节
>
> 是变量就会占用空间
>
> 变量的地址为字节中最小的地址
>
> `int  a;`
>
> `int *p = &a; `
>
> `*`取值操作，*p取地址里面的值
>
> p是指针变量
>
> 





![截屏2020-12-17 上午1.33.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%881.33.00.png)







![截屏2020-12-17 上午1.34.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-17%20%E4%B8%8A%E5%8D%881.34.00.png)



是变量：变量的作用是用来存储值的，指针变量能接收到的值是地址

变量本身有地址，指针变量本身也有地址。





指向指针的指针

```c
int **q;//
struct person stu;
int *p;
p = stu;
//p+1向后跳跃了一个类型的字节

```









## 2.指针等价形式转换

![截屏2020-12-20 下午4.23.27](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%884.23.27.png)



```cpp
#include<iostream>
using std::cin;
using std::cout;
using std::endl;
struct Data{
    int x, y;
};

 
int main() {
    struct Data a[2], *p = a;
    a[0].x = 3;a[0].y = 3;
    a[1].x = 5;a[1].y = 5;
    
    cout << endl;
    cout << a[1].x << endl;

    cout << (*(a+1)).x << endl;
    cout << (*(&(a[0]) + 1)).x << endl;

    cout << (a + 1)->x << endl;
    cout << (*(a + 1)).x << endl;
    
    cout << (*(&a[0] + 1)).x << endl;
    
    cout << (p + 1)->x << endl;
    cout << (*(p + 1)).x << endl;

    
    cout << (*(p+1)).x << endl;
    cout << (*(&(*p) + 1)).x << endl;
     
    
    
//地址->变量
  //变量.变量
     
    return 0;
}
```



## 2.函数指针

![截屏2020-12-20 下午5.24.14](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.24.14.png)



函数指针变量

`int (*add)(int, int)`

函数指针类型

`typedef int (*add)(int, int)`



## 3.空指针计算相对地址偏移量

> 结构体类型和变量的相对地址偏移量计算

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define offset(T, a) ({\
    T temp;\
    (char *)(&temp.a) - (char *)(&temp);\
})
//将地址转换成char * 类型方便做计算(因为类型不一样不可以做计算)
#define offset1(T, a) (long)(&(((T *)(NULL))->a))
//不定义变量，相当于temp不存在（相当于temp）,地址从0开始

struct Data {
    int a;
    double b;
    char c;
};
 

int main(int argc, char *argv[], char *env[]) {
   
    int num = 0x0626364;
  //0 62  63 64
  //64 63 62 0/小端机
    printf("%s\n", (char *)(&num));
  //dcb        
  //98 b,99 c, 100 d

  //结构体类型和变量的相对地址偏移量
    printf("%ld\n", offset(struct Data, a));
    printf("%ld\n", offset(struct Data, b));
    printf("%ld\n", offset(struct Data, c));

     
    return 0;
}
```







## 4.typedef用法

![截屏2020-12-20 下午5.33.24](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.33.24.png)





func函数指针类型





## 5.typdef和define别名的区别



```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
//
#define ppchar char *
typedef char * pchar;

int main(int argc, char *argv[], char *env[]) {
 		pchar p1,p2;
    ppchar p3,p4;
    printf("p1 = %lu, p2 = %lu\n", sizeof(p1), sizeof(p2));
    printf("p3 = %lu, p4 = %lu\n", sizeof(p3), sizeof(p4));

    return 0;
}
```

>p1 = 8, p2 = 8
>p3 = 8, p4 = 1
>
>```c
>		 pchar p1,p2;
>    char * p3,p4;==>char * p3;char p4;
>```
>
>==>define 只是简单是替换
>
>typedef是重命名



# 10.main函数

## 1.main函数

系统调用main函数

mian 参数 参数个数，参数，环境变量



![截屏2020-12-20 下午5.53.10](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2020-12-20%20%E4%B8%8B%E5%8D%885.53.10.png)





## 2.main函数参数

> argc:参数个数
>
> argv：传入的参数以字符串的形式存储
>
> env:环境变量，存储环境的变量的字符串，
>
> ```c
> ./a.out hello world "hello world"
> agrc = 3
> argv[0] = ./a.out
> argv[1] = hello
> argv[2] = world
> argv[3] = hello world
> ```
>
>
> 
> 



```c
#include <stdio.h>
//__attribute__((constructor))
void output(int argc, char *argv[], char *env[]) {
    printf("argc = %d\n", argc);
    for (int i = 0; i < argc; i++) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }
    for (int i = 0; env[i]; i++) {
        if (!strncmp(env[i], "USER=", 5)) {//判断前5个字符串是不是USER=
            if (!strcmp(env[i] + 5, "apricity")) {//对比，相减等于0
                printf("welcome apricity...!\n");
            } else {
              printf("you are not the user! please exit\n");
              exit(0);
            }
        }
        printf("env[%d] = %s\n", i, env[i]);
    }

}

int main(int argc, char *argv[], char *env[]) {
  
 		output(argc, argv, env);
    return 0;
}

./a.out hello world "hello world"
argc = 4
argv[0] = ./a.out
argv[1] = hello
argv[2] = world
argv[3] = hello world
env[0] = LC_TERMINAL_VERSION=3.4.3
env[1] = LANG=en_US.UTF-8
env[2] = LC_TERMINAL=iTerm2
welcome apricity...!
env[3] = USER=apricity
env[4] = LOGNAME=apricity
env[5] = HOME=/home/apricity
env[6] = PATH=/home/apricity/.autojump/bin:/home/apricity/.autojump/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
env[7] = MAIL=/var/mail/apricity
 
```





# 11.工程项目开发



正常示例

```cpp
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

void funA(int);
void funB(int);
//两个函数互相调用，需要写申明
void funB(int n) {
    if (n == 0) return ;
    printf("funB : %d\n", n);
    funA(n - 1);
    return ;
}

void funA(int n) {
    if (n == 0)  return ;
    printf("funA : %d\n", n);
    funB(n - 1);
    return ;
}



int main() {
    add(2, 3);
    funA(5);
    return 0;
}
```







## 11.1 函数未声名和未定义





有了函数申明后可以把函数定义写在函数申明后面，可以快速阅读代码，增加代码阅读性



源文件.c/cpp

预编译：宏替换

编译期：检查语法错误，生成对象文件，一个（多个）源文件生成一个（多个）对象文件（`g++ -C 40.main.cpp`）

生成可执行文件(g++ 40.mian.cpp -o main)(-o起别名)

链接过程报错：编译生成可执行文件，未找到对应的函数，即未定义



> 函数未申明：编译期报错
>
> 函数未定义：函数链接过程报错





## 11.2 头文件与源文件



头文件：后缀名为.h的文件

源文件：写代码的文件.c/.cpp/.cc



> 为什么区分头文件源文件？

头文件放函数声名，避免项目工程中发生函数重定义





## 11.3头文件源文件代码演示

```cpp
// 41.main.cpp
#include <stdio.h>

#include "42.40.main.header1.h"
#include "43.40.main.header2.h"

int main() {
    funcA(5);
    funcC(5, 6);
    return 0;
}

```





```cpp
// 42.40.main.header1.h
//解决了编译过程中函数重定义的问题

#include <stdio.h>
void funA(int);
void funcB(int);
void funcA(int n) {
    if (n == 0) return ;
    printf("funcA :%d\n", n);
    funcB(n - 1);
    return ;
}

void funcB(int n) {
    if (n == 0) return ;
    printf("funcB :%d\n", n);
    funcB(n - 1);
    return ;
}
```



```cpp
// 43.40.main.header2.h
void funcC(int, int);
void funcC(int a, int b) {
    printf("funcC ：%d\n", a + b);
    funcA(a);
    return ;
}
```



运行可以通过编译

```shell
g++ 40.main.cpp
./a.out
funA : 5
funB : 4
funA : 3
funB : 2
funA : 1
```



修改main.cpp

```cpp
// 41.main.cpp
#include <stdio.h>
#include "43.40.main.header2.h"
#include "42.40.main.header1.h"
//将头文件的顺序

int main() {
    funcA(5);
    funcC(5, 6);
    return 0;
}

// 会报错,funcA函数未声明
In file included from 41.main.cpp:3:
./43.40.main.header2.h:8:5: error: use of undeclared identifier 'funcA'
    funcA(a);
    ^
1 error generated.


// 给43的头文件加上声明
#include <stdio.h>
#include "42.41.main.header1.h"
void funA(int);

void funcC(int, int);
void funcC(int a, int b) {
    printf("funcC ：%d\n", a + b);
    funcA(a);
    return ;
}
//报错==>重定义
      In file included from 41.main.cpp:4:
./42.41.main.header1.h:9:6: error: redefinition of 'funcA'
void funcA(int n) {
     ^
./42.41.main.header1.h:9:6: note: previous definition is here
void funcA(int n) {
     ^
In file included from 41.main.cpp:4:
./42.41.main.header1.h:17:6: error: redefinition of 'funcB'
void funcB(int n) {
     ^
./42.41.main.header1.h:17:6: note: previous definition is here
void funcB(int n) {
     ^
2 errors generated.
       
//修改main.cpp，去掉42头文件，可以编译通过
#include <stdio.h>
#include "43.40.main.header2.h"
//#include "42.40.main.header1.h"   
       
       
```



==>另一种修改方法

```cpp
#ifndef _HEADER1_H
#define _HEADER1_H
//解决了编译过程中函数重定义的问题
//判断是否包含当前宏,条件式编译

#include <stdio.h>
void funA(int);
void funcB(int);
void funcA(int n) {
    if (n == 0) return ;
    printf("funcA :%d\n", n);
    funcB(n - 1);
    return ;
}


void funcB(int n) {
    if (n == 0) return ;
    printf("funcB :%d\n", n);
    funcB(n - 1);
    return ;
}

#endif
```









```cpp
#ifndef _HEADER1_H
#define _HEADER1_H
//解决了在一次编译过程中函数重定义的问题
//判断是否包含当前宏,条件式编译

#endif
```



## 11.4 工程开发示例



```cpp
//41.main.cpp
#include <stdio.h>

#include "42.41.main.header1.h"
#include "43.41.main.header2.h"
#include "44.41.main.header3.h"

int main() {
    funcA(5);
    funcC(5, 6);
    funcD(5,6);
    return 0;
}
```



```cpp
//42.41.main.header1.h

#ifndef _HEADER1_H
#define _HEADER1_H
//解决了编译过程中函数重定义的问题
//判断是否包含当前宏,条件式编译

#include <stdio.h>

void funcA(int);
void funcB(int);

#endif
```





```cpp
//47.41.main.header1.cc
#include <stdio.h>
#include "42.41.main.header1.h"
void funcA(int n) {
    if (n == 0) return ;
    printf("funcA :%d\n", n);
    funcB(n - 1);
    return ;
}

void funcB(int n) {
    if (n == 0) return ;
    printf("funcB :%d\n", n);
    funcB(n - 1);
    return ;
}
```





```cpp
//43.41.main.header2.h
#ifndef _HEADER2_H
#define _HEADER2_H

#include <stdio.h>
#include "42.41.main.header1.h"
void funcA(int);
void funcC(int, int);

#endif
```



```cpp
//46.41.main.header2.cc

#include <stdio.h>
#include "42.41.main.header1.h"

void funcC(int a, int b) {
    printf("funcC ：%d\n", a + b);
    funcA(a);
    return ;
}
```





```cpp
//44.41.main.header3.h

#ifndef _HEADER3_H
#define _HEADER3_H

void funcD(int, int);

#endif
```



```cpp
//45.41main.header3.cc

#include "42.41.main.header1.h"
#include <stdio.h>

void funcD(int a, int b) {
    printf("Apricity : %d \n", a + b);
    funcA(a);
    return ;
}
```



```shell
g++ -c 47.41.main.header1.cc -o header1.o
g++ -c 46.41.main.header2.cc -o header2.o
g++ -c 46.41.main.header2.cc -o header2.o
g++ -c 45.41main.header3.cc -o header3.o
g++ -c 41.main.cpp -o main.o

g++ header1.o header2.o header3.o main.o


./a.out
funcA :5
funcB :4
funcB :3
funcB :2
funcB :1
funcC ：11
funcA :5
funcB :4
funcB :3
funcB :2
funcB :1
Apricity : 11
funcA :5
funcB :4
funcB :3
funcB :2
funcB :1
```



头文件里面放声名，源文件放定义





## 11.5 `<>`和`""`的区别



`<>`在系统路径下查找头文件

`""`从当前目录查找头文件



如果要对当前目录下的头文件使用`<>`，则在编译的时候使用`g++ -I ./ -c mian.cpp`

`-I ./`将当前目录添加到系统目录下





## 11.6 makefile



```makefile
.PHONY: clean
CC=g++ -I./ -c
all : 41.main.o 45.41main.header3.o  46.41.main.header2.o 47.41.main.header1.o
	g++ 41.main.o 45.41main.header3.o  46.41.main.header2.o 47.41.main.header1.o
41.main.o: 41.main.cpp
	${CC} 41.main.cpp
45.41main.header3.o: 45.41main.header3.cc 44.41.main.header3.h
	${CC} 45.41main.header3.cc
46.41.main.header2.o: 46.41.main.header2.cc 43.41.main.header2.h
	${CC} 46.41.main.header2.cc
47.41.main.header1.o: 47.41.main.header1.cc 42.41.main.header1.h
	${CC} 47.41.main.header1.cc
clean:
	rm *.o a.out
```



## 11.6 动态静态链接库









src:源文件

include:头文件



```shell
#include : 42.41.main.header1.h 43.41.main.header2.h 44.41.main.header3.h
#src : 45.41main.header3.cc  47.41.main.header1.cc header2.o 46.41.main.header2.cc header1.o             header3.o
#lib : 

#打包成静态链接库
ar -r libhaizei.a *.o
ar: creating archive libhaizei.a

ls
45.41main.header3.cc  47.41.main.header1.cc header2.o             libhaizei.a
46.41.main.header2.cc header1.o             header3.o



mv libhaizei.a ../lib
cd ../lib
ll
total 8
-rw-r--r--  1 apricity  staff   3.0K  2 22 22:07 libhaizei.a

```

使用静态链接库



```shell
g++ -I ./include -c 41.main.cpp -o main.o
g++ -L ./lib main.o -l haizei
#-L使用静态链接库 -l haizei 引入lib下的haizei库
```







动态链接库和静态连接库的区别：

动态链接库只需要链接一次，静态每次都需要链接





# 12. C语言测试框架-谷歌测试框架gtest

下载地址

```shell
git clone https://github.com/google/googletest
```



测试框架：

## 12.1  测试框架的使用

CMake:根据当前环境生成makefile文件



```shell
cmake CMakeLists.txt
#产生makefile文件
make
//使用测试框架
mkdir 43.project
cp -R 42.googletest/lib 43.project
cp -R 42.googletest/googletest/include 43.project

g++ -I ./include -c main.cpp
g++ -L ./lib/ main.o -lgtest  -lpthread
```



```cpp
//main.cpp
#include <stdio.h>
#include <gtest/gtest.h>

int add(int a, int b) {
    return a + b;
}

TEST(func, add) {
    EXPECT_EQ(add(1, 2), 3);
    EXPECT_EQ(add(2, 4), 7);
    EXPECT_EQ(add(2, 4), 6);
}

TEST(func, add2) {
    EXPECT_EQ(add(-1, 1), 0);
    EXPECT_EQ(add(3, -2), 1);
}

int main(int argc, char *argv[]) {
    testing::InitGoogleTest(&argc,argv);
    return RUN_ALL_TESTS();
}

```





![截屏2021-02-23 下午5.51.37](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-23%20%E4%B8%8B%E5%8D%885.51.37.png)





## 12.2  实现简版gtest

环境ubutu18.04

gcc version 7.5.0

include : .h文件

src: .cpp源文件

目录结构

```cpp
43.project
					include  //gtest include文件夹(.h头文件)
					lib  // gtest 生成的静态连接库文件
					module //测试框架的实现 
 module
       bin/haizei  //编译后的文件
  		 include/test.h  // 头文件
  		 main.cpp  // 主函数
  		 makefile   // 
  			src/test.cc			//源文件
```



```cpp
//main.cpp
#include <stdio.h>
#include <test.h>

int add(int a, int b) {
    return a + b;
}

TEST(func, add) {
    EXPECT_EQ(add(1, 2), 3);
    EXPECT_EQ(add(2, 4), 7);
    EXPECT_EQ(add(2, 4), 6);
}

TEST(func, add2) {
    EXPECT_EQ(add(-1, 1), 0);
    EXPECT_EQ(add(3, -2), 1);
}

TEST(f, uncadd) {
    EXPECT_EQ(add(0, 0), 0);
    EXPECT_EQ(add(12, -12), 0);
}

int main(int argc, char *argv[]) {
    //testing::InitGoogleTest(&argc,argv);
    return RUN_ALL_TESTS();
}

```



`makefile`

```makefile
.PHONY: clean
all: ./src/test.o main.o
	g++ ./src/test.o main.o -o ./bin/haizei
./src/test.o: ./src/test.cc ./include/test.h
	g++ -I ./include -c ./src/test.cc -o ./src/test.o
main.o: main.cpp ./include/test.h
	g++ -I ./include -c main.cpp
clean:
	rm ./bin/haizei ./src/*.o main.o
```



```cpp
//include/test.h       
#ifndef  _TEST_H
#define _TEST_H

#define TEST(a, b)\
__attribute__((constructor))\
void a##_haizei_##b()//函数的名字是ab,中间加入符号，解决重名的问题

#define EXPECT_EQ(a, b) {\
    printf("%s = %s ? %s \n", #a, #b, a == b ? "TRUE" : "FASE");\
}

int RUN_ALL_TESTS();


#endif
```



```cpp
//src/test.cc    
 
int RUN_ALL_TESTS() {  
  for (int i = 0; i < func_cnt; i++) {
        func_arr[i].func();
    }
    return 0;
}
```



```cpp
make
./bin/haizei
//运行结果

add(1, 2) = 3 ? TRUE
add(2, 4) = 7 ? FASE
add(2, 4) = 6 ? TRUE
add(-1, 1) = 0 ? TRUE
add(3, -2) = 1 ? TRUE
add(0, 0) = 0 ? TRUE
add(12, -12) = 0 ? TRUE
```





## 12.3 最终版getest

最终运行结果展示

![截屏2021-02-25 下午6.12.00](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-25%20%E4%B8%8B%E5%8D%886.12.00.png)

增加输出颜色



泛型宏：

```cpp
_Genericl(a) --> 转换成格式控制字符串
```





![截屏2021-02-25 下午6.06.38](https://guziqiu-pictures.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-02-25%20%E4%B8%8B%E5%8D%886.06.38.png)



```c
// ./include/test.h

#ifndef _TEST_H 
#define _TEST_H

//颜色
#define COLOR(a, b) "\033[" #b "m" a "\033[0m"         //正常颜色
#define COLOR_HL(a, b) "\033[1;" #b "m" a "\033[0m"    //高亮颜色

#define GREEN(a) COLOR(a, 32)
#define RED(a) COLOR(a, 31)
#define BLUE(a) COLOR(a, 34)
#define YELLOW(a) COLOR(a, 33)

#define GREEN_HL(a) COLOR_HL(a, 32)
#define RED_HL(a) COLOR_HL(a, 31)
#define BLUE_HL(a) COLOR_HL(a, 34)
#define YELLOW_HL(a) COLOR_HL(a, 33)

#define TEST(a, b)\
void a##_haizei_##b();\
__attribute__((constructor))\
void add##_haizei_##a##_haizei_##b() {\
    add_function(a##_haizei_##b, #a "." #b);\
}\
void a##_haizei_##b()//函数的名字是ab,中间加入符号，解决重名的问题 

#define TYPE(a) _Generic((a), \
    int: "%d", \
    double: "%lf", \
    float: "%lf", \
    long long: "%lld", \
    const char*: "%s", \
    char*: "%s")
//TYPE(a)获取a的类型转换成格式占位符

#define P(a, color) {\
    char frm[1000];\
    sprintf(frm, color("%s"), TYPE(a));\
    printf(frm, a);\
}
#define EXPECT(a, b, comp) {\
    __typeof(a) _a = (a);\
    __typeof(b) _b = (b);\
    haizei_test_info.total += 1;\
    if (_a comp _b) haizei_test_info.sucess += 1;\
    else {\
        printf("\n");\
        printf(YELLOW_HL("\t%s:%d: failure\n"), __FILE__, __LINE__);\
        printf(YELLOW_HL("\t\texpect : " #a " " #comp " " #b "\n\t\t" "actual : "));\
        P(_a, YELLOW_HL);\
        printf(YELLOW_HL(" vs "));\
        P(_b, YELLOW_HL)\
        printf("\n\n");\
    }\
    printf(GREEN("[-----------]"));\
    printf(" %s %s %s ? %s \n", #a, #comp, #b, _a comp _b ? GREEN("TRUE") : RED("FASE"));\
}
// __typeof(a) _a = (a) // 避免add(a++, b)
// 判断ab的关系
#define EXPECT_EQ(a, b) EXPECT(a, b, ==) // ==
#define EXPECT_NE(a, b) EXPECT(a, b, !=) // !=
#define EXPECT_LT(a, b) EXPECT(a, b, <)  // <
#define EXPECT_LE(a, b) EXPECT(a, b, <=) // <=
#define EXPECT_GT(a, b) EXPECT(a, b, >)  // >
#define EXPECT_GE(a, b) EXPECT(a, b, >=) // >=

typedef void (*TestFuncT)();//函数指针

typedef struct Function {//将信息打包成结构体
    TestFuncT func;//指向函数
    const char *str;//名字
} Function;

struct FunctionInfo {
    int total;//总测试点信息
    int sucess;//成功通过的总数
};

extern struct FunctionInfo haizei_test_info;//用当前结构体类型定义一个变量,extern 申明一个外部变量
void add_function(TestFuncT, const char *);
int RUN_ALL_TESTS();


#endif



// ./src/test.c
#include <stdio.h>
#include <test.h>
#include <string.h>
#include <math.h>

Function func_arr[100];
//指针数组
int func_cnt = 0;//测试用例
struct FunctionInfo haizei_test_info;//当前变量定义放在源文件里面 

void add_function(TestFuncT func, const char * str) {
    func_arr[func_cnt].func = func;
    func_arr[func_cnt].str = strdup(str);//将str拷贝一份，返回新的地址到strl;名字
    func_cnt += 1;
    return ;
}

int RUN_ALL_TESTS() {
    for (int i = 0; i < func_cnt; i++) {
        printf(GREEN("[====RUN====]") RED_HL(" %s\n"), func_arr[i].str);
        haizei_test_info.total = 0;
        haizei_test_info.sucess = 0;
        func_arr[i].func();
        double rate = 100.0 * haizei_test_info.sucess / haizei_test_info.total;
        printf(GREEN("[ "));
        if (fabs(rate - 100.0) < 1e-6) {
            printf(BLUE_HL(" %6.2lf%% "), rate);
        } else {
            printf(RED_HL(" %6.2lf%% "), rate);
        }
        //printf(GREEN("[-----------]\n"));
        printf(GREEN(" ]" " sucess : %d  total : %d\n"), 
               haizei_test_info.sucess, 
               haizei_test_info.total);
    }
    return 0;
}

// ./main.c 

#include <stdio.h>
//#include <gtest/gtest.h>
#include <test.h>

int add(int a, int b) {
    return a + b;
}

double double_add(double a, double b) {
    return a + b;
}

TEST(func, add) {
    EXPECT_EQ(add(1, 2), 3);
    EXPECT_EQ(add(2, 4), 7);
    EXPECT_EQ(add(2, 4), 6);
    EXPECT_GT(add(0, 9), -9);
    EXPECT_GE(add(0, 9), 9);
}

TEST(func, doubleAdd) {
    EXPECT_EQ(double_add(0.5, 2), 2.5);
    EXPECT_EQ(double_add(2.1, 0.9), 3);
    EXPECT_EQ(double_add(3.2, 3.2), 6);
    EXPECT_GT(double_add(0, 3.7), -9);
}

TEST(func, add2) {
    EXPECT_EQ(add(-1, 1), 0);
    EXPECT_EQ(add(3, -2), 1);
    EXPECT_NE(add(2, 3), 4);
    EXPECT_LT(add(-1, -2), 3);
    EXPECT_LE(add(0, 6), 5);
}

TEST(f, uncadd) {
    EXPECT_EQ(add(0, 0), 0);
    EXPECT_EQ(add(12, -12), 0);
}

int main(int argc, char *argv[]) {
    //testing::InitGoogleTest(&argc,argv);
    return RUN_ALL_TESTS();
}


// ./makefile

.PHONY: clean
all: ./src/test.o main.o
	gcc ./src/test.o main.o -o ./bin/haizei
./src/test.o: ./src/test.c ./include/test.h
	gcc -I ./include -c ./src/test.c -o ./src/test.o
main.o: main.c ./include/test.h 
	gcc -I ./include -c main.c 
clean: 
	rm ./bin/haizei ./src/*.o main.o
run: 
	./bin/haizei


```



运行

```shell
make
gcc -I ./include -c ./src/test.c -o ./src/test.o
gcc -I ./include -c main.c
gcc ./src/test.o main.o -o ./bin/haizei
 
make
gcc ./src/test.o main.o -o ./bin/haizei

make run
./bin/haizei
[====RUN====] func.add
[-----------] add(1, 2) == 3 ? TRUE

	main.c:15: failure
		expect : add(2, 4) == 7
		actual : 6 vs 7

[-----------] add(2, 4) == 7 ? FASE
[-----------] add(2, 4) == 6 ? TRUE
[-----------] add(0, 9) > -9 ? TRUE
[-----------] add(0, 9) >= 9 ? TRUE
[   80.00%  ] sucess : 4  total : 5
[====RUN====] func.doubleAdd
[-----------] double_add(0.5, 2) == 2.5 ? TRUE
[-----------] double_add(2.1, 0.9) == 3 ? TRUE

	main.c:24: failure
		expect : double_add(3.2, 3.2) == 6
		actual : 6.400000 vs 6

[-----------] double_add(3.2, 3.2) == 6 ? FASE
[-----------] double_add(0, 3.7) > -9 ? TRUE
[   75.00%  ] sucess : 3  total : 4
[====RUN====] func.add2
[-----------] add(-1, 1) == 0 ? TRUE
[-----------] add(3, -2) == 1 ? TRUE
[-----------] add(2, 3) != 4 ? TRUE
[-----------] add(-1, -2) < 3 ? TRUE

	main.c:33: failure
		expect : add(0, 6) <= 5
		actual : 6 vs 5

[-----------] add(0, 6) <= 5 ? FASE
[   80.00%  ] sucess : 4  total : 5
[====RUN====] f.uncadd
[-----------] add(0, 0) == 0 ? TRUE
[-----------] add(12, -12) == 0 ? TRUE
[  100.00%  ] sucess : 2  total : 2

make clean
rm ./bin/haizei ./src/*.o main.o
```





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 错误总结

## 1.`collect2: error: ld returned 1 exit status `

```c
/tmp/ccgbUZFw.o: In function `main':
21.my_sqrt.c:(.text+0x12c): undefined reference to `sqrt'
collect2: error: ld returned 1 exit status
```



编译的时候使用 `gcc a.c -lm`





## 2.stack smashing detected ***: <unknown> terminated

数组越界







## 3.warning: backslash and newline separated by space



将\后面的空格去掉就可以了.











































